{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"Classifying gapped phases in 1D","text":"矩阵积态在解析和数值应用中都非常有用。张量网络分析领域最有力的结果之一是在一维中对间隙相进行了完整的分类。 先介绍量子相位，然后，将讨论在缺乏对称约束的情况下，所有MPS处于同一阶段。最后，将展示对称性是如何改变这种分类的。这些材料本身就很有趣，同时也展示了TNN的分析能力。 Quantum phases经典的相位定义，特别是相变，通常与自由能密度的某些非解析性质有关 f(\\beta,v) = -\\frac{log \\ tr \\ e^{-\\beta H(v)}}{\\beta}其中$v$为模型参数(压力、质量、耦合强度等)的某个向量，$H$为系统的哈密顿量。显然当我们采取量子限制(β→∞)时，自由能就是基态能量。因此，量子相变就与基态联系起来了。 在经典相变时，相关系数变化范围较长 \\langle O_0 O_x \\rangle - \\langle O_0 \\rangle \\langle O_x \\rangle \\sim |x|^{-v}取一些热分布的平均值。因此，我们说，热(经典)相变是由热波动驱动的，其中的方差衡量了这些波动的范围越来越长。量子相变也有发散的相关长度，但是没有热平均——统计在起源上是纯量子的。 经典相位对应于$H$和$\\beta$一系列的变化，不会引起自由能$f$的非分析性。同样地，当基态能量成为某些哈密顿参数(不是温度)的函数时(在热力学极限下)，量子相变就发生了。假设我们有一个连续的一族量子哈密顿量$H(\\lambda)$。最低能级通常以下列方式之一起作用 在左边，没有相变，而在右边，当基态和第一激发态的角色交叉时发生相变。 因此，相变将与频谱中的相交点相联系。如果有连续的一族哈密顿量$H(\\lambda)$使$|\\psi_0 \\rangle$处于基态$H(0)$，且$| \\psi_1 \\rangle$处于基态$H(1)$，且对$\\lambda \\in [0,1]$存在相交点，可以说两态处于同相。 一个等价的概念是局部哈密顿下的有限时间演化。如果两种状态可以通过有限时间内的时间演化相互转换，则它们处于同相。这与一种状态自然演变成另一种状态的可能性有关。 可以演变为被深度常数的局部量子电路的等价表达。如果施加了对称性，相位会如何变换呢？如果使哈密顿量$H(\\lambda)$与一些对称群$U_g(\\lambda)$对易。在电路图中，这相当于把栅极限制在只有与这种对称交换的栅极上。 Injective MPS在这一讲中，我们将只讨论单射MPS的情况。如果我们假设MPS是左正则形式 那么单射MPS是那些单位是唯一特征值的传递矩阵的左特征向量。此外，这意味着存在一个唯一的全秩密度矩阵ρ是1右特征向量 这些MPS对应于局部哈密顿的唯一间隙基态。","link":"/2020/02/24/Classifying-gapped-phases-in-1D/"},{"title":"TensorNetwork documentation","text":"这是阅读TensorNetwork documentation的一些简单记录，因为原文档的类操作没有目录。这里用目录的形式记录方便查询，详细的内容要看原文档。 TensorNetwork注意，对节点的操作都是生成新节点，而不是在原节点上操作。 tensornetwork.conj共轭 tensornetwork.copy复制 tensornetwork.transpose转置 tensornetwork.reachable计算从节点或边缘可到达的所有节点 tensornetwork.remove_node从网络中删除一个节点 tensornetwork.splittensornetwork.split_node奇异值分解 tensornetwork.split_node_qrQR分解 tensornetwork.split_node_rqRQ分解 tensornetwork.split_node_full_svd全奇异值分解 tensornetwork.checktensornetwork.check_connected检查节点列表中的所有节点是否都连接了 tensornetwork.check_correct检查节点定义的网络是否满足必要的一致性关系 tensornetwork.gettensornetwork.get_all_nodes返回连接到边的节点集 tensornetwork.get_all_edges返回所有节点的边集 tensornetwork.get_all_nondangling返回所有非悬空边的集合 tensornetwork.get_all_dangling返回所有悬空边的集合 tensornetwork.get_parallel_edges得到所有与给定边平行的边 tensornetwork.get_shared_edges获取两个节点之间共享的所有边 tensornetwork.contracttensornetwork.contract_trace_edges缩并节点的所有迹边 tensornetwork.contract缩并连接两个节点的边 tensornetwork.contract_copy_node在给定的复制节点上缩并所有的边 tensornetwork.contract_between缩并两个给定节点之间的所有边 tensornetwork.contract_parallel缩并所有与这条边平行的边。 tensornetwork.outertensornetwork.outer_product计算两个节点的外积 tensornetwork.outer_product_final_nodes得到节点集的外积 tensornetwork.flattentensornetwork.flatten_edges把边压扁成单边 tensornetwork.flatten_all_edges将所有属于节点的边压平 tensornetwork.flatten_edges_between将给定两个节点之间的所有边压平 Contractorstensornetwork.contractors.greedy贪心缩并 tensornetwork.contractors.branch分支缩并 tensornetwork.contractors.optimal最优缩并 tensornetwork.contractors.auto根据网络大小自动选择上述算法之一 tensornetwork.contractors.custom使用用户创建的自定义路径优化器来计算缩并路径 NodesTensorNetwork的操作都是对边进行的，以下为节点类 class tensornetwork.Node class tensornetwork.CopyNodecompute_contracted_tensor calss tensornetwork.BaseNode节点的基类，可以从它派生出子类 add_axis_names向节点添加轴名称 add_edge向节点的给定轴上添加一条边 get_all_dangling返回连接到此节点的悬空边集 get_all_nondangling返回连接到此节点的非悬挂边集 get_axis_number获取给定轴名或值的轴号 get_dimension得到给定轴上的维数 get_rank返回张量的秩 reorder_axes重新排列节点张量的轴 reoder_edges对给定节点的边重新排序 set_signature设置节点的签名 Edgesclass tensornetwork.Edgedisconnect断开链接 get_nodes得到连接边的节点 is_being_used检查此边所指向的节点是否使用了此边 is_dangling检查是否是悬边 update_axis更新边所连接的节点 Ncontensornetwork.ncon根据一个张量网络规范缩并张量或节点列表 tensornetwork.ncon_netwrok根据张量从张量列表创建一个网络 Matrix Product Statesclass tensornetwork.matrixprductstates.base_mps.BaseMPSMPS的基类。BaseMPS是一个有限单元的无限矩阵乘积状态。 apply_one_site_gateapply_transfer_operatorapply_two_site_gatebond_dimensioncheck_orthonormalityget_nodemeasure_local_operatormeasure_two_body_correlatorphysical_dimensionspositionswitch_backend class tensornetwork.matrixprductstates.finite_mps.FiniteMPS表示有限系统的MPS类 canonicalizecheck_canonicalleft_envsclassmethod randomright_envs class tensornetwork.matrixprductstates.infinite_mps.InfiniteMPS表示无限系统的MPS类 canonicalizeclassmethod randomtransfer_matrix_eigs","link":"/2020/02/27/TensorNetwork-documentation/"},{"title":"TensorNetwork--a open source library","text":"TensotNetwork是Google开源的以tensorflow为后端用来执行张量网络算法的Python库。 IntroductionTensor networks最初是被设计用来模拟量子多体物理的稀疏数据结构，但现在也被用于很多其它领域。 近年来，张量网络在机器学习中的应用取得了很大的进展。Stoudenmire和Schwab使用矩阵乘积状态(MPS)对MNIST数据集进行分类。Levine等人证明了deep convolutional algorithm circuit (ConvAC)等价于tree tensor network，并对张量网络与convolutional network architecture之间更一般的关系提供了经验支持。Liu等人在MNIST和CIFAR-10上使用二维分层树张量网络进行图像识别。 Google创建TensorNetwork库的主要目标之一就是加速这项研究。 The TensorNetwork API在本节中，将介绍TensorNetwork API的主要组成部分。API的功能被设计成紧密地模拟对张量网络的图形表示的操作。也就是说，基本对象是表示张量网络的图的节点和边，API的基本功能是允许用户定义这些对象，并在网络中将它们合并在一起。 三种常用的张量网络。彩色图形表示张量，连接它们的边表示缩并。 Basic ObjectsTensorNetworksTensorNetworks是库的主要对象。它保持跟踪自己的节点(Node)对象集，并包含用于添加额外节点、用边连接节点、缩并节点和以其他方式操作节点的方法。 Nodes节点是张量网络的基本构件之一。它们在计算中表示一个张量。每个轴都有对应的边，可以将不同的节点(甚至相同的节点)连接在一起。边的数目表示底层张量的秩。例如，没有任何边的节点是标量，只有一条边的节点是向量，等等。通过向add_node传递张量的方式，在张量网络中创建节点。 12345import tensornetworkimport tensorflow as tfnet = tensornetwork.TensorNetwork()a = net.add_node(tf.eye(2)) # Numpy arrays can also be passed.print(a.get_tensor()) #This is how you access the underlying tensor. Edges边描述了张量网络中底层张量的不同缩并。每条边都指向要缩并的张量轴。张量网络中有三种基本的边 Standard Edges：标准边和无向图中的任何边一样。它们连接两个不同的节点，并定义给定向量空间之间的点积。在numpy术语中，这条边定义了给定轴上的tensordot操作。 Trace Edges：迹边将节点连接到自身。要缩并这种类型的边，需要对由两个给定轴创建的矩阵求迹。 Dangling Edges：悬边表示尚未连接到其他悬空边的输出轴或中间轴。这些边是在向网络中添加节点时自动创建的。 Basic OperationsConnecting Dangling Edges在缩并一个边之前，它必须连接在网络中。在构造张量网络时，可以使用connect方法连接以悬空开始的边。这个方法将创建一个新的Edge对象，它指向要连接的两个节点，替换悬边。 用一个量子计算的例子来说明。在这里，有一个单比特的量子电路，我们应用了几次Hadamard运算。即将比特的悬边连接到Hadamard操作，并返回结果边: 12345678910111213def apply_hadamard(net, edage): hadamard_op = np.array([[1.0, 1.0], [1.0, -1.0]]) / np.sqrt(2.0) hadamard_node = net.add_node(hadamard_op) # Connect the \"qubit edge\" to the operator \"input edage\". net.connect(edge, hadamard_node[1]) return hadamard_node[0] #This is the \"output edge\".# Build the quantum circuit.net = tensornetwork.TensorNetwork()qubit = net.add_node(np.array([1.0, 0.0])) # A \"zero state qubit\".qubit_edge = qubit.get_edge(0) # qubit[0] is equivalent.for i in range(5): qubit_edge = apply_hadarmard(net, qubit_edge) Edge Flattening两个节点之间通常有多条边连接在一起。如果一次只缩并一条边，那么所有剩余的边都成为迹边。这通常对计算非常不利，因为新节点分配的内存将远远大于所需的内存。此外，由于迹边只对底层矩阵的对角线求和，因此在第一次缩并期间计算的所有其他值都是无用的。扁平化是一种有效的自由操作，所以每次都应该这样做。如下图所示： 在API中扁平化非常简单： 12345a = net.add_node(np.eye(2))b = net.add_node(np.eye(2))edge1 = net.connect(a[0], b[0])edge2 = net.connect(a[1], b[1])flattened_edge = net.flatten_edges([edge1, edge2]) 所有连接一对节点的边都可以通过调用flatten_edges_between来扁平化： 1flattened_edge = net.flatten_edges_between(a, b) 为了便于预先优化，可以使用flatten_all_edges来平坦化网络中的所有边。这将返回网络中所有非悬空边: 1contractible_edges = net.flatten_all_edges() Edge Contraction缩并一条边只是一个简单的调用。张量网络API足够智能，可以计算出传递的边的类型，并相应地进行正确的计算。这是一个计算两个向量的点积的例子。 123456net = tensornetwork.TensorNetwork()a = net.add_node(tf.ones(2))b = net.add_node(tf.ones(2))edge = net.connect(a[0], b[0])c = net.contract(edge)print(c.get_tensor().numpy()) #Should print 2.0 也可以通过调用contract_between来自动地将连接两个节点的所有边压平和缩并: 1c = net.contract_between(a, b) Node Outer Product两个张量的外积(也称为张量积或克罗内克积)在给定的指标分配上的值是具有相同分配的每个组成张量的值的元素乘积。外积的形式是用下标符号显式表示的 (A \\otimes B)_{i_1\\cdots i_r j_1 \\cdots j_s} = A_{i_1 \\cdots i_i}B_{j_1 \\cdots j_s}从图形上看，外部积只是由两个相邻的节点表示，并作为单个单元处理。 简单使用API就可以直接实现： 1c = net.outer_product(a, b) 这将创建一个新节点来替换网络中的旧节点。这看起来像是一个奇怪的操作，因为张量网络有效之处在于这些节点没有合并成一个高维的物体。然而，以这种方式组合两个节点通常是有用的，因为将用不同的分解方式将它们再次分开。这是下一节的主题。 Node Splitting张量网络算法的一个常见步骤是对一个张量进行奇异值分解。例如，在DMRG算法中用于计算量子系统的低能态，以及在机器学习中的MPS。 在API中，可以调用split_node或split_node_full_svd来实现。这个函数需要3个参数：node，left_edges和right_edges。参数节点是要分割的节点，left_edges是要在分割后附加到$U$节点上的边，right_edges是在分割后添加到$V^\\dagger$节点上的边。这个函数需要left_edges和right_edges都与节点连接，且不能为迹边。 分割后创建的新边将指向维度轴 new \\ dim = min(\\Pi \\ left \\ edge \\ dims ,\\Pi \\ right \\ edge \\ dims)例如，如果我们要分割一个节点的形状为(2,3,4,5,6)左边沿为前三组，维度为(2,3,4)，右边为剩下的两组。则新的左结点形状为(2,3,4,24)，右边的新节点为(24,5,6)。根据处理奇异值的方式，可以使用两种不同的方法来决定是否拆分单个节点。现在将解释这两种选择 Split Node：对于默认的split_node方法，节点被分成两个新节点。这些节点的值是酉矩阵乘以奇异值的平方根。通过去掉小的奇异值可以得到更有效的近似奇异值分解。在trun_err中返回丢弃的奇异值， 1u_s, s_vh, trun_err = net.split_node(node, left_edges, right_edges) Split Node Full SVD：通过使用split_node_full_svd，可以在单独的节点中获得奇异值。参数完全相同，只是现在返回三个节点而不是两个。 1u, s, vh, trun_err = net.split_node_full_svd(node, left_edges, right_edges)","link":"/2020/02/22/TensorNetwork-google/"},{"title":"Tensor network algorithms","text":"张量网络在凝聚态系统的低温模拟方面取得了非凡的实际成功。一个比较容易理解的玩具模型是寻找一维旋转系统的基态。即使是在假设的局域哈密顿函数，这个看起来很窄的问题也保留了QMA -completeness，粉碎了通用模拟方法的希望，即使是在量子计算机上。虽然这乍一看似乎是一个重大的问题，但许多“物理现实”系统并没有表现出这种令人望而却步的复杂性。张量网络可以用来开发，并在一定程度上理解这种结构。 就像前面讨论的，低纠缠态可以很好的用MPS来表达。如果考虑局部间隙哈密顿量，研究表明相关基态不可能高度纠缠。这种限制性纠缠意味着这些的态允许有效的MPS近似，表明缺口(gap)的存在导致复杂性从QMA-complete一路下降到P，消除了模拟的复杂性障碍。我们注意到，尽管在将MPS应用于无gapless模型时存在复杂性理论和物理上的挑战，但也有一些成功的例子的。 更详细的是，在限制域$D$中用最小化哈密顿量$H$的Rayleigh quotient方法来近似基态$| \\Gamma \\rangle$ | \\Gamma \\rangle : = \\mathop{arg \\ min}_{| \\psi \\rangle \\in D} \\frac{\\langle \\psi | H | \\psi \\rangle}{\\langle \\psi | \\psi \\rangle}我们知道MPS很好地逼近了精确解，限制在有界键维的MPS的定义域$D$上。DMRG和TEBD是在一些MPS状态下开始，然后沿着这个区域变化移动，在移动过程中最小化能量。两种方法的区别在于执行这个变化步骤的方式，DMRG和TEBD分别采用了更多的计算的方法和物理的方法。 虽然我们在这里讨论的算法是为寻找MPS基态而设计的，但是它们可以被用来模拟时间演化，找到Gibbs states，或者优化其他操作符。 DMRG(the computer scientist’s approach)DMRG是目前该领域研究最多、最成功的算法。为了清楚起见，我们限制在有限的DMRG上，尽管确实存在热力学变量。DMRG是一个包含多个类似算法的概括性术语，在这里讨论的算法是一个简化但仍然有效的示例。由于该算法的提出要早于TNN，它的描述在历史上一直是以一种更有物理动机和技术上更复杂的方式呈现的。由于在解释上的相应转变，最初的缩略语现在与DMRG的现代张量网络解释几乎没有关联，因此为了清楚起见，我们有意省略了精确地将DMRG的扩展定义为缩略语。 用MPO表示哈密顿函数，在MPS上优化Rayleigh quotient的过程如下: 困难在于我们需要这些MPS张量的压缩;整体目标函数是高度非线性的，但它确实只是二次地依赖于每个张量。DMRG背后的关键启发是利用这些局部问题的简单性，通过迭代单变量(单张量)优化逼近多元(多张量)优化。 需要注意的是，虽然DMRG算法只计算基态，但相关的归纳可以用来模拟激发态、动力学等。 One-site对上述DMRG简图的最简单解释是DMRG1(或单点DMRG)。对于一个固定的点$i$，依次对这个点以为的MPS张量进行优化 A_i \\leftarrow \\mathop{arg \\ min}_{A_i} \\frac{\\langle \\psi(A_i) | H | \\psi(A_i) \\rangle}{\\langle \\psi (A_i) | \\psi(A_i) \\rangle}在TNN中，这样的步骤表现为 接着，定义环境张量 它对应于取封闭的张量网络，分别取$H$和$I$的期望值，然后去掉目标张量。在这样的环境下，6.4图变为 向量化这个方程会得到结果 A_i \\leftarrow \\mathop{arg \\ min}_{A_i} \\frac{\\langle A_i | H_i | A_i \\rangle}{\\langle A_i | L_i | A_i \\rangle}最后，我们可以简化这个目标函数的分母，适当地将MPS确定为标准形式。通过将站点左侧的MPS部分以左正则形式显示，将右侧的MPS部分以右正则形式显示，我们可以得到$L_i$简化为恒等式： 考虑到这种规范化，问题就简化为 A_i \\leftarrow \\mathop{arg \\ min}_{A_i} \\frac{\\langle A_i | H_i | A_i \\rangle}{\\langle A_i | A_i \\rangle}因为$H_i$是厄米的，这个优化有一个由$H_i$的最小特征向量给出的闭合解。通过沿着链来回扫描，解决这个局部特征向量问题，然后根据需要沿着规范化移动，我们完成了对算法的描述。 DMRG1的主要优点是状态保持在MPS流形内，键长不增加，这意味着算法是贪婪的。然而，这种对键的严格限制可能是一把双刃剑;这意味着在算法运行时，没有特别方便的方法来缓慢增长键的尺寸，关于键的尺寸选择的适当性，没有得到任何信息。这两个问题都通过改进来解决，尽管稍微复杂一些，导出DMRG2算法。 Two-siteDMRG2的想法是将两个节点合并在一起，在DMRG1表示中执行优化，然后将两个位置分开。这种分裂过程赋予了DMRG2其能力，允许动态控制键的维度，并提供有关修剪所导致的误差量的信息，这有助于键维度的选择。 首先进行优化 可以再次通过取一个环境张量关于两个位置的最小特征向量来求解，$H_{i,i+1}$，同样是混合正则形式。在这之后，通过执行SVD和键切将两节点张量分解: 这种裁剪的SVD有两个关键特性。首先，我们修剪的键的尺寸可以比我们最初开始时的尺寸大，这样我们就可以慢慢地扩展到更高的键尺寸MPS的空间。其次，我们可以使用截断的奇异值来量化与此投影相关的误差，使其回归到更低的键维空间，从而更好地告知我们对键维的选择。 TEBD (the physicist’s approach)时间演化合并抽取(time-evolving block decimation(TEBD))是一个张量网络算法，允许模拟一维自旋系统的动力学。通过模拟虚时间演化(imaginary-time-evolution)，还可以计算出基态等低温特征。 为了模拟虚拟时间演化，我们需要近似虚时间演化算子$U(\\tau) = \\exp(-\\tau H)$。这里的问题是，虽然我们可能有一个$H$的有效表示，但它的任何指数不一定有一个简洁的表示。以相应的虚时间演化的二体哈密顿函数为例 U(\\tau)=e^{-\\tau \\sum_i h_i} \\qquad H=\\sum_i h_i$h_i$是一个作用于自旋$i$和$i + 1$的相互作用项。同时$H$有恒定的Schmidt阶，可以有效的用MPO表示，$U(\\tau)$一般对于所有的$\\tau$都有指数的键维度。 让$H_o(H_e)$分别表示奇(偶)指标$i$的$h_i$的和。因为所有的$H_o(H_e)$中的所有项都为对易的，$e^{-\\tau H_o}(e^{-\\tau itH_e})$可以被有效的计算和表达。近似$U(\\tau)$的问题转变为当$e^{-\\tau A}$和$e^{-\\tau B}$都可计算时近似$e^{-t(A+B)}$的问题。 TEBD的核心数学工具是指数积近似。这些近似的第一阶是Suzuki-Trotter公式，它通过简单地演化每个子系统来近似总的演化: e^{-\\tau (A+B)} = e^{-\\tau A}e^{- \\tau B} +O(\\tau^2)结果是存在这样的近似的整个家族，尽管我们的目的只是为了说明Suzuki-Trotter的过程。 TEBD算法的工作原理是通过上述指数积公式近似虚时间演化算子，将其应用于给定的MPS，并调整键维以投射回MPS空间。我们对虚时间演化算符的近似是由只包含最近邻的两个位置算符的层的乘积给出的，这意味着我们只需要将这些算符压缩到我们的MPS中。假设我们想对$i$和$i + 1$处的自旋应用算子U。其思想是应用算符，把所有的量都压缩成一个张量，然后再一次使用SVD裁剪来截断键的维数。 dmrg2的优点也体现在TEBD中，即控制键尺寸的增长和对修剪误差的量化。由于上面的过程是完全局域化的，TEBD也允许大量的并行处理，这是DMRG通常不支持的。 Problem1.考虑临界横场Ising模型 H = - \\sum_{i=1}^{n-1} X_i X_{i+1} - \\sum_{i=1}^{n}Z_i对于开放边界条件，我们知道基态能量作为$n$的函数具有这种形式 E(n) = 1-csc(\\frac{\\pi}{\\alpha n + \\beta})对于一些整数$\\alpha$和$\\beta$。使用DMRG和TEBD，对几个链长度估计基态能量和计算$\\alpha$和$\\beta$。 2.已知一维间隙哈密顿函数的局部哈密顿量问题存在于P中。DMRG和TEBD是对这类系统基态进行数值计算的最常用技术。对于一个有间隙的一维哈密顿函数，证明它对于DMRG或TEBD收敛。","link":"/2020/02/25/Tensor-network-algorithms/"},{"title":"Matrix product states","text":"矩阵积态(Matrix product states(MPS))是模拟实际物理系统一维量子低能态的一种很自然的选择。这节将以从两个定义MPS的方式开始，给出一些分析MPS的例子，展示这个简单网络的复杂度。介绍MPS的一些性质之后，后续将直接对网络进行操作而不再是操作量子态。 令$|\\psi\\rangle = \\sum_{j_1 j_2\\ldots j_N=0}^{d-1}C_{j_1 j_2\\ldots j_N=0} |j_1\\rangle \\otimes |j_2\\rangle \\otimes \\cdots \\otimes |j_N\\rangle$为$N$比特的量子态表示，这个量子态可以完全的由$N$阶张量$C$确定。 将第一个指标分离出来，再执行奇异值分解(SVD)，可以得到施密特分解(Schmidt decomposition) |\\psi\\rangle = \\sum_i \\lambda_i|L_i\\rangle \\otimes |R_i\\rangle其中$\\lambda_i$为施密特权值，${|L_i\\rangle}$和${|R_i \\rangle}$为正交的向量集合。 图像化表示如下 $\\lambda$是包含施密特权值的对角矩阵。 $\\alpha$-Renyi entropy为 S_\\alpha(\\rho)=\\frac{1}{1-\\alpha}\\log Tr\\rho^\\alpha其中$\\rho$是密度矩阵。 执行连续的SVD依次分割 将奇异值张量$\\lambda^{(i)}$并入局部张量$M^{(i)}$，可以得到更一般的形式 这就是矩阵积态(matrix product state)。这个结构是通用且精确的，可以添加更多的系数来讨论更复杂的形式。 考虑链上任意对分纠缠有界的量子态，假设施密特权值中只有$D$非零。因此可以使用这个性质来截断$\\lambda$矩阵，进而优化MPS的表示。特别的，任意满足strong area law，即对任意对分满足$S_0 \\leq \\log c$($c$为常数)，的量子态可以表示为仅需要$\\Omicron(dNc^2)$个系数的MPS。在许多相关状态下，冯诺依曼熵的面积定律($S_1=\\Omicron(1) $)足以保证在MPS只有$poly(N)$的结合维度的情况下也有任意的良好近似。 在TNN中，矩阵积态是一种误称，因为大多数参与的张量为3阶。未参与缩并的指标为物理(physical)指标，而另外的两个指标为虚(virtual)指标，键(bond)指标或矩阵(matrix)指标。为了方便，也为了最有效地捕获周期状态，MPS ansatz通常表示为 |\\psi[A^{(1)},A^{(2)},\\ldots,A^{(N)}]\\rangle = \\sum_{i_1,i_2,\\ldots,i_N}Tr[A_{i_1}^{(1)}A_{i_2}^{(2)}\\ldots A_{i_N}^{(N)}] |i_1 i_2 \\ldots i_N \\rangle或者在平移不变的情况下表示为 |\\psi[A]\\rangle = \\sum_{i_1,i_2,\\ldots,i_N}Tr[A_{i_1}A_{i_2}\\ldots A_{i_N}] |i_1 i_2 \\ldots i_N \\rangle注意，在这种形式中，矩阵索引被忽略，矩阵乘法是隐含的。该MPS的图形形式为 1D projected entangled pair states除了上述的结构，MPS可以视为投影纠缠对态(projected entangled pair states(PEPS))结构的特殊结构。这个过程为将纠缠对态$|\\phi \\rangle$布局在晶格上，然后对每对纠缠态施加映射$P$。 这样的结构等价于使用$|\\phi \\rangle = \\sum_{j=0}^{d-1}|dd \\rangle$构建张量网络。将线性映射$P$写为 P=\\sum_{i,\\alpha,\\beta}A_{i;\\alpha,\\beta}|i\\rangle\\langle\\alpha\\beta|.其中张量$A$实际上是上面介绍的MPS张量。纠缠对的选择保证了，作用在Bell态上的PEPS“投影”对应的张量$A$就是对应的张量$A$的缩并： \\begin{align} P^{(1)} \\otimes P^{(2)} |\\phi\\rangle_{2,3}&= \\sum_{i_1,i_2;\\alpha_1,\\beta,\\alpha_2,\\beta_2,j}A_{i_1;\\alpha_1,\\beta_1}^{(1)} A_{i_2;\\alpha_2,\\beta_2}^{(2)}|i_1i_2\\rangle \\langle \\alpha_1 \\beta_1 \\alpha_2 \\beta_2 |(1 \\otimes |jj\\rangle \\otimes 1) \\\\ &=\\sum_{i_1,i_2;\\alpha_1,\\beta_1,\\beta_2} A_{i_1;\\alpha_1,\\beta_1}^{(1)} A_{i_2;\\beta_1,\\beta_2}^{(2)}|i_1i_2\\rangle \\langle \\alpha_1 \\beta_2 | \\end{align}因此，我们看到这两种描述是等价的，通过将局部单元应用于A的虚指数，或者等价地改变PEPS中最大纠缠对都可以进行交换。 应注意到，这一般不应被视为一种实际的准备程序。一般来说，PEPS张量会将状态映射到一个非平凡的子空间，而这种物理实现需要后选择的测量。如果其中一个失败了，我们需要从头开始构建，这意味着这个过程通常是不可伸缩的。 Some MPS statesProduct state令 A_0 = \\begin{pmatrix} 1 \\end{pmatrix}, \\quad A_1 = \\begin{pmatrix} 0 \\end{pmatrix}.对于态$|00 \\ldots 0\\rangle$，表示为 A_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}, \\quad A_1 = \\begin{pmatrix} 0 & 0 \\\\ 0 & 0 \\end{pmatrix}.W state下列的矩阵对应什么态 A_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}, \\quad A_1 = \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}.选择MPS的边界条件为 有$A_0 A_0 = A_0,A_0 A_1 =A_1,A_1^2=0$和$Tr[A_1 X]=1$，所以有 |W\\rangle = \\sum_{j=1}^N |000\\ldots01_j 000\\ldots0 \\rangle这就是W态。 GHZ state如果选择$|\\phi\\rangle = |00\\rangle +|11\\rangle ,P=|0\\rangle\\langle00| +|1\\rangle\\langle 11|$，或者等价的MPS张量 A_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}, \\quad A_1 = \\begin{pmatrix} 0 & 0 \\\\ 0 & 1 \\end{pmatrix}.可以得到Greenberger-Horne-Zeilinger(GHZ)态 |GHZ\\rangle = |00\\ldots 0\\rangle + |11\\ldots 1\\rangle .AKLT state假设要构建一个$SO(3)$对称自旋单态(spin-1 state)。令$|\\phi\\rangle = |01\\rangle - |10\\rangle$为$SO(3)$的不变单重态，$P:\\mathbb{C}^{2 \\times 2} \\rightarrow \\mathbb{C}^3$为作用到自旋单态子空间上的投影算符。 P = |\\tilde 1 \\rangle \\langle 00 | + |\\tilde0 \\rangle \\frac{\\langle 01 | + \\langle 10|}{\\sqrt2} + |- \\tilde1 \\rangle \\langle 11|这样做的好处是，对应系统上的自旋算符通过$P$，意味着它与旋转交换。令$(S_x,S_y,S_z)$为自旋单粒子的自旋向量，$(X_i,Y_i,Z_i)/2$为第$i$的比特上的自旋向量，这意味着： \\begin{align} S_ZP &= (|\\tilde1\\rangle \\langle \\tilde1|-|-\\tilde1\\rangle\\langle - \\tilde1|)(|\\tilde 1 \\rangle \\langle 00 | + |\\tilde0 \\rangle \\frac{\\langle 01 | + \\langle 10|}{\\sqrt2} + |- \\tilde1 \\rangle \\langle 11|) \\\\ &=|\\tilde1\\rangle\\langle00|-|-\\tilde1\\rangle\\langle11| \\\\ &=P\\frac{Z_1+Z_2}{2} \\end{align} \\begin{align} S_XP &= \\frac{|\\tilde0 \\rangle (\\langle\\tilde1|+\\langle-\\tilde1|)+(|\\tilde1\\rangle+|-\\tilde1\\rangle)\\langle \\tilde0|}{\\sqrt2} (|\\tilde1 \\rangle \\langle00| + |\\tilde0\\rangle \\frac{\\langle01|+\\langle10|}{\\sqrt2}+|-\\tilde1\\rangle\\langle11|) \\\\ & = (\\frac{|\\tilde0 \\rangle(\\langle00|+\\langle11|)}{\\sqrt2}+\\frac{(|\\tilde1\\rangle+|-\\tilde1\\rangle)(\\langle01|+\\langle10|)}{2}) \\\\ &= P \\frac{X_1 + X_2}{2} \\end{align}对$S_Y$也有相似的结果。因此，在这个投影之后得到的状态是完全$SO(3)$对称的，但是有一个非平凡的纠缠结构(例如，如果在每个位置上的状态仅仅是一个单线态，就不会得到)。 这个态有许多有趣的性质。可以为这样的基态写出2-local Hamiltonian。令$\\Pi_2$为自旋1粒子对的自旋2s子空间上的投影。这个算符的特征值为${0,1}$。$\\Pi_2$淹没相邻的自旋1粒子，因为它们是由两个自旋1/2s和一个自旋0构成的，所以它们与自旋2的子空间没有重叠。在周期边界条件下，很容易检查出$H=\\sum \\Pi_2$的基态是唯一的。 如果研究绕自旋1的三个轴旋转的作用，可以看到 R_{\\hat n}(\\theta)P=PR_{\\hat n}(\\theta) \\otimes R_{\\hat n}(\\theta).特别的，$R_{\\hat x}(\\pi) \\rightarrow -XX , R_{\\hat y}(\\pi) \\rightarrow -YY, R_{\\hat z}(\\pi) \\rightarrow -ZZ$。后面将看到，这告诉我们AKLT状态处于非平凡对称保护拓扑(SPT)相位。 Cluster state在物理位置包含一对自旋的状态下，可以方便地写出键维度为2的MPS。令 A_{00} = \\begin{pmatrix} 1 & 0 \\\\ 1 & 0 \\end{pmatrix}, \\quad A_{01} = \\begin{pmatrix} 0 & 1 \\\\ 0 & 1 \\end{pmatrix}. \\quad A_{10} = \\begin{pmatrix} 1 & 0 \\\\ -1 & 0 \\end{pmatrix}, \\quad A_{11} = \\begin{pmatrix} 0 & -1 \\\\ 0 & 1 \\end{pmatrix}.或者等效于从虚粒子到物理自旋1/2粒子的映射 P=\\begin{pmatrix} 1 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 1\\\\ 1 & 0 & -1 & 0\\\\ 0 & -1 & 0 & 1\\\\ \\end{pmatrix}其中纠缠对处于Bell态$|\\psi\\rangle = |00\\rangle + |11\\rangle$。映射$P$对应于电路 注意到在这种情况下，PEPS张量$P$简单的对应于统一的电路。因此，这是可以将PEPS描述视为可伸缩准备过程的例外情况之一。 给出了这种状态的显式MPS描述，我们现在可以推导出它是基态的哈密顿量，从而允许我们推断出某些性质。 初始状态由纠缠对$\\Pi |\\phi \\rangle_{2j,2j+1}$构成，而且是唯一的基态对于哈密顿量 H = -\\sum_j (X_{2j}X_{2j+1} + Z_{2j}Z_{2j+1})应用这个电路(在第一个比特为奇，第二个比特为偶的Bell对间)，我们看到这个变换为 \\begin{align} H' &= -\\sum_j (Z_{2j-1}X_{2j}Z_{2j+1}+Z_{2j}X_{2j+1}Z_{2j+2}) \\\\ &= -\\sum_k Z_{k-1}X_k Z_{k+1} \\end{align}这就是聚态(cluster state)哈密顿量。这个物理模型的对称性为$\\mathbb{Z}_2 \\times \\mathbb{Z}_2$，其中$S_1 = \\Pi_j X_{2j-1}$，$S_2 = \\Pi_j X_{2j}$。把这个电路回推，可以看到它相当于将$S_1 = \\Pi_j Z_{2j} Z_{2j+1}$和$S_1 = \\Pi_j Z_{2j} Z_{2j+1}$作用于虚自旋。 这个行为告诉我们，与AKLT状态一样，聚态也具有SPT顺序。 MPS propertiesMPS构成了整个希尔伯特空间中一个极小的角落，因此我们不能指望用它们来近似任意的状态。如果物理相关的状态对应于那些可以被MPS很好地近似的状态，并且MPS表现出与这些物理状态相同的非通用属性，那么MPS就是研究这些系统的一个非常有用的工具。 Decay of correlations我们可以看到MPS只表现有限的纠缠度，接下来将研究可以表示的相关性的类型。令$O$为计算两点关联性的算子 \\langle \\psi [A]| O_0 O_{j+1} | \\psi[A] \\rangle下标表示操作符O作用的位置。这个期望值用图形表示为: $\\mathbb{E}_o$为$O$的转移矩阵。通常将$\\mathbb{E_1}$视为转移矩阵，简单的表达为$\\mathbb{E}$。 相关因子(在热力学极限下)可以写成 \\langle \\psi [A]| O_0 O_{j+1} | \\psi[A] \\rangle =Tr(\\mathbb{E}^{\\infty} \\mathbb{E}_{O_0} \\mathbb{E}^j \\mathbb{E}_{O_{j+1}} \\mathbb{E}^\\infty) \\qquad \\propto V_L^\\dagger \\mathbb{E}^j V_R其中$V_L$和$V_R$分别是$\\mathbb{E}$的左右主特征值。在计算较长距离相关器时，唯一需要做的改变是在方程中插入$\\mathbb{E}$的较高次幂。$\\mathbb{E}$的特征值可以控制相关因子的衰减。我们可以将$A$归一化，使得$E$的主特征值为1，其余的在单位圆内。因此任意相关因子要么随距离呈指数衰减，要么保持恒定。因此我们看到MPS只能捕获指数衰减相关的状态 Gauge freedom不是所以的MPS都表达不同的物理状态。保持物理状态不变的描述的转换集称为规范变换(gauge transformations)。在MPS的情况下，这些对应于虚拟层上的基变换: 其中$B_j = M A_j M^{-1}$。注意，M只需要有一个左逆，所以可以是矩形和放大键的维度。在更大的物理范围上，可以将几个MPS张量$A_{i_1},A_{i_2},\\ldots,A_{i_j}$整合为单个有效张量$B_k$。 存在一些规范的形式，其中部分为规范修正MPS描述。最常见的一种是左等距或左正则形式(与右等距或右正则类似地定义)。在这情况下MPS张量遵循 \\sum_{j=0}^{d-1}A_j^\\dagger A_j = 1_{D \\times D}, 这是最有用的开放边界系统，存在一个简单的算法来将任何MPS转换为这样的形式。它常常被用于数值应用，特别是使用变分最小化优化一个基态(DMRG)的MPS描述时，混合的左/右等距形式将被使用。 将MPS转换成这样的形式是部分规范的固定(gauge fixing)。剩下的自由度是单元在虚拟层上的自由度，而不是一般的可逆矩阵。该技术作为一种提高数值稳定性的方法，在张量网络算法中得到了广泛的应用。 Renormalising matrix product states当重整一个系统时，我们通常考虑尝试在一个更长的长度范围内(捕获原始模型的低能量部分)写出一个有效的模型。这可以通过将节点连接到一起，然后忽略自由度来实现，确保描述仍然是有用的。在MPS中，连接通过简单的将张量缩并到一起来实现。如何只忽略掉高能的自由度是一个挑战性的问题。但MPS允许我们不需要考虑这个问题。 因为只关心算符的期望值，所以可以完全在转移矩阵图中操作。把不同的位点连接在一起，简单地说就是取转移矩阵的乘积 \\tilde{\\mathbb{E}} = \\mathbb{E}\\mathbb{E}\\mathbb{E}\\mathbb{E}\\mathbb{E}\\ldots\\mathbb{E}同时中间操作$\\mathbb{E}_O$也被重整。注意到$\\tilde{\\mathbb{E} }$的维度始终保持为$D^4$，所以不需要担心忽略了一些自由度。我们也可以使用不同MPS构成的转移矩阵来得到非对角项的形式$\\langle \\psi | O | \\phi \\rangle$。 Mixed states and many body operators就像上面所描述的，MPS可被用于表示纯态。那么如何表示混合态呢？ 令$|\\psi[A] \\rangle $为纯MPS态，可以写出对应额密度矩阵为 \\rho [A] = |\\psi[A]\\rangle \\langle \\psi[A]| 因此，自旋R的某个子集上的约化密度矩阵将表示为 \\rho [A]_R = |\\psi[A]\\rangle \\langle\\psi[A]| 其中使用了左右规范形式来引入边界项。 上面的网络就是矩阵乘积算符(matrix product operators(MPOs))的一个例子。最一般的MPOs被表示如下： 除了用于表示密度矩阵，MPOs还可用于表示多体算符，包括小深度量子电路和局部哈密顿函数。 例如，transverse field Ising Hamiltonian表示为 H=-J\\sum X_jX_{j+1}-h\\sum Z_j线上的矩阵为 M=\\begin{pmatrix} 1 & 0 & 0 \\\\ X & 0 & 0 \\\\ -hZ & -JX & 1\\\\ \\end{pmatrix}终端的向量为 v_L = \\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix} ,\\quad v_R = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$N$个节点的整体哈密顿量为 H = v_L M^N v_R对于Heisenberg model H = -J_X \\sum X_jX_{j+1} - J_Y \\sum Y_j Y_{j+1} -J_Z\\sum Z_j Z_{j+1} - h \\sum Z_j可以用同样的方法得到 v_L = \\begin{pmatrix} 0 & 0 & 0 & 0 & 1 \\end{pmatrix} , \\qquad M = \\begin{pmatrix} 1 & 0 & 0 & 0 & 0 \\\\ X & 0 & 0 & 0 & 0 \\\\ Y & 0 & 0 & 0 & 0 \\\\ Z & 0 & 0 & 0 & 0 \\\\ -hZ & -J_X X & -J_Y Y & -J_Z Z & 1 \\\\ \\end{pmatrix} , \\qquad v_R = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}更一般的，MPO可以表示任何不增加Schmidt rank太多的算符。 Problem1.用张量描述MPS给出的状态 其中指标顺序在图中已经给出，指标1和指标2整合到一起。边界条件要求在结束周期性BCs之前插入泡利算符Z。 解答： A_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\quad A_1= \\begin{pmatrix} 1/2 & -1/2 \\\\ 1/2 & -1/2 \\end{pmatrix}进行规范变换，得到 B_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\quad B_1= \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}与W-state一致。 2.描述只有非零分量的MPS给出的状态 其中左右边界的状态为$|0\\rangle$。 解答： 可以看到 A_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} =1, \\quad A_1= \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} = X.那么只有插入偶数个$A_1$的情况下，得到的系数才不为0 | \\psi[A] \\rangle = \\sum |even\\ number \\ of \\ 1s \\rangle 3.描述MPS给出的qudit态 其中$i,j \\in \\mathbb{Z}_d$，$\\oplus$表示模$d$运算，左边界条件为$|0 \\rangle$，右边界为$|q \\rangle$，$q \\in \\mathbb{Z}_d$。 4.设$G$为一群，描述MPO给出的操作 其中左边界为$|1\\rangle$，右边界为$|q\\rangle$，$q \\in G$，$g \\cdot h$为群乘法。 5.假设局部基被粒子数标记。下列操作符的作用是什么(键维度从左到右线性增加)? 其中左向量为$L=|0\\rangle$，右向量为$R = \\sum_{i=0}^N i|i\\rangle $。 6.写出transverse-field-cluster Hamiltonian的MPO H = -J \\sum_j Z_{j-1}X_jZ_{j+1} - h\\sum_j X_j解答： M = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ Z & 0 & 0 & 0 \\\\ 0 & X & 0 & 0 \\\\ -hX & 0 & -JZ & 1 \\\\ \\end{pmatrix} L = \\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ \\end{pmatrix} \\qquad R = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ \\end{pmatrix} ^T 7.利用MPSs和MPOs的思想，证明了对数深度量子电路可以在经典计算机上有效的模拟。","link":"/2020/02/20/Matrix-product-states/"},{"title":"Tensor Network","text":"什么是Tensor Networks?张量网络(Tensor networks)是一种有效表达和操纵关联数据的数据结构。他们将高维数据分解为几个指标张量(index tensor)(每个指标张量只包含比较少的参数)的乘积。 张量网络最初是在量子多体理论的背景下发展起来的。它不仅帮助我们在理论上，尤其是量子纠缠方面理解波函数。而且为许多有效的数值模拟方法奠定了基础。 近年来，张量网络在量子重力和全息、纠错码、经典数据压缩、大数据分析和机器学习等研究领域得到了广泛的应用。 Tensor Networks用来干什么？张量网络是用来表示相关数据的集合的，这些数据的性质取决于所讨论的应用： 研究量子多体系统，张量网络可以编码为状态波函数的系数 研究经典多体系统，张量网络可以编码为微观状态的统计集合 大数据分析，张量网络可以表示来自不同领域的多维数据，比如信号处理、神经科学、生物度量、模式识别等 Why Tensor Networks？张量网络表示有哪些优势： 张量网络提供了大型结构数据集的压缩表示。 张量网络可以更好的描述数据集的结构特征，特别是在数据的关联性上。此外，用于表示网络的图示符号可以在视觉上清楚直观地理解这些结构。 张量网络自然地提供了数据集的分布式表示，因此许多操作可以并行的执行。 张量网络为处理大数据集合提供了一个标准的框架。一些常见的任务，比如统计信息的评估，是通过一个小的张量网络工具集合来完成的，这些张量网络工具的使用不需要任何关于底层数据集或数据代表什么的具体知识。 张量网络通常非常适合处理有噪声或丢失的数据，因为它们所基于的分解通常是健壮的。 如何学习Tensor Networks?一个关于TensorNetwork的网站，上面有详尽的关于TensorNetworks的学习流程和资料。 TensorNetwork","link":"/2020/02/18/TensorNetwork/"},{"title":"Introduction to tensor network notation","text":"​ 张量网络有效的一个主要原因是通常用来描述它们的直接而透明的符号。使用图形语言，结构是明显的。研究对象的许多一般性质，特别是量子态，可以直接从描述它们所需的网络结构中识别出来。 ​ Tensor network notation(TNN)可以看成Einstein summation notation 的推广。接下来的部分，将介绍张量和可以对其进行的操作。 Tensors​ 张量是向量和矩阵的推广。一个$d$维向量可以看成是$\\mathbb{C}^d$的有序集合。一个$n\\times m$维矩阵可以看成是$\\mathbb{C}^{n\\times m}$的有序集合。一个维度为$d_1 \\times \\cdots \\times d_r$的$r$阶(rank-r)张量可以看成是$\\mathbb{C}^{d_1 \\times \\cdots \\times d_r}$的有序集合。标量、向量和矩阵可以分别视为0阶，1阶和2阶张量。 ​ 在张量网络记数法中，一个张量简单地用一个伸出来的几何图形表示，每个张量对应一个指标，类似于爱因斯坦记数法的指标。例如，一个4阶的张量R可以表示为 ​ 在某些情况下，腿的形状和方向可以表示张量或指标的某些性质——但是对于一般的网络来说，两者都没有什么特殊的意义。在表示量子态时，通常可以方便地使用腿的方向来表示对应的向量是存在于Hilbert空间(‘kets’)还是其对偶(‘bras’)中。通过这个约定，可以避免执行一些禁止的缩并(contraction)，例如两个右矢(‘kets’)的缩并。 Tensor operations​ TNN表示的一个主要优点在于一个张量可以表示为一些其它张量的复合。两个主要的操作为张量积(product)和迹(trace)，常用于联合操作(joint operation)的缩并。除了这两个操作，一个张量的秩，即阶数，也可以通过分组或分裂指标来改变(grouping/splitting indices)。 Tensor product​ 张量可以视为向量外积的推广。张量积在给定指标集上的值是每个张量相应指标元素值的乘积。显示地用指标符号表示，二元张量积的形式为： [A \\otimes B]_{i_1,\\ldots,i_r,j_1,\\ldots,j_s }:=A_{i_1,\\ldots,i_r}\\cdot B_{j_1,\\ldots,j_s}从下图可以看到，张量积就是两个紧挨着的张量。因此，一个包含不相交张量的网络的值就是组成值的乘积。 Trace​ 取迹操作((partial) trace)。对于$x$指标和$y$指标维数相同($d_x=d_y$)的张量$A$，着两个维度的部分取迹操作就是这两维上相同指标数据的相加求和。 [Tr_{x,y}A]_{i_1,\\ldots,i_{x-1},i_{x+1},\\ldots,i_{y-1},i_{y+1},\\ldots,i_r}= \\sum_{\\alpha=1}^{d_x}A_{i_1,\\ldots,i_{x-1},\\alpha ,i_{x+1},\\ldots,i_{y-1},\\alpha,i_{y+1},\\ldots,i_r}类似于爱因斯坦符号，这个求和在TNN中是隐式的，由相对应的连接的腿表示。与爱因斯坦表示法相比，它的一个优点是不需要对这些求和指数进行命名，这使得这种表示法对于大型网络来说不那么笨拙。 ​ 从这个符号中我们可以很容易地看出迹的一个性质是它的循环性质。通过简单地滑动其中一个矩阵，这只会改变网络中张量的位置，因此不会改变值，我们可以循环这些矩阵(注意移位)来证明$Tr(AB)=Tr(BA)$。 Contraction​ 最常用的张量运算是缩并(constraction)。一个例子是两个3阶张量的两对指标之间的缩并： 上图中六个指标缩并为两个。 ​ 常见的压缩例子有向量内积、矩阵-向量乘法、矩阵-矩阵乘法和矩阵的迹。 Grouping and splitting​ 在张量网络的研究中，秩是一个相当不稳定的概念。张量空间$\\mathbb{C}^{a_1 \\times \\cdots \\times a_n}$和$\\mathbb{C}^{b_1 \\times \\cdots \\times b_m}$在维数匹配时($\\prod_i a_i =\\prod_i b_i$)可以同构同一个向量空间。利用这一点，我们可以将以前只定义向量和矩阵的概念和技术扩展到所有的张量。为了做到这一点，我们可以对指标进行分组或拆分，从而分别降低或提高给定张量的秩。 ​ 考虑缩并两个任意张量的情况。如果我们把参与和不参与这个收缩的指标放在一起，这个过程就简化为矩阵乘法。 这种简化矩阵乘法正是数值张量包执行压缩的方式，允许它们利用高度优化的矩阵乘法代码包。 ​ 分组和分割的精确细节并不是唯一的，要根据基(basis)的选择所决定。一个特别的约定选择是以张量积为基，即在积空间上定义一组基，改积空间由各基的积给出。张量积基在量子信息中的规范使用允许对上面描述的分组和分裂进行隐式处理。例如$|0\\rangle \\otimes |1\\rangle \\equiv |01\\rangle$的表示忽略了精确的分组：左边的张量积可以视为$2 \\times 2$维的矩阵，右边可以看出4维的向量。量子信息中的张量积实际上常常是kroecker product，即真实的张量积和上述的分组。 ​ 更具体地说，考虑一个$n+m$阶的张量，将其开始的$n$个指标和接着的$m$个指标分组构成一个矩阵。 T_{I,J}:=T_{i_1,\\ldots,i_n;j_1,\\ldots,j_m}其中分组指标定义为 I:=i_1+d_1^{(i)}\\cdot i_2+d_1^{(i)}d_2^{(i)}\\cdot i_3+\\cdots+d_1^{(i)}\\ldots d_{n-1}^{(i)}\\cdot i_n \\\\ J:=j_1+d_1^{(j)}\\cdot j_2+d_1^{(j)}d_2^{(j)}\\cdot j_3+\\cdots+d_1^{(j)}\\ldots d_{n-1}^{(j)}\\cdot j_n$d_x^{(i)}(d_x^{(j)})$是类型$i(j)$第$x$个指标的维数。相当于将张量在两个方向上分组展开，上式为总的指标数。当这样一个分组被给出时，可以将张量视为矩阵，执行标准的矩阵操作。 ​ 一个重要的例子是奇异值分解(singular value decomposition(SVD))。 T_{I,J}=\\sum_{\\alpha}U_{I,\\alpha}S_{\\alpha,\\alpha}\\overline{V}_{J,\\alpha} T_{i_1,\\ldots,i_n;j_1,\\ldots,j_m}=\\sum_{\\alpha}U_{i_1,\\ldots,i_n,\\alpha}S_{\\alpha,\\alpha}\\overline{V}_{j_1,\\ldots,j_m,\\alpha}只要分组的选择是一致的，分组的精确方法就不会对结果产生影响。因此可以保持分组是隐式的，就如上图所示。 ​ 按上面的方法，SVD可以表示为上图，其中$U$和$V$是等容的(isometric)($U^{\\dagger}U=V^\\dagger V=1$)跨越指标划分。这种把指标分成两个不相交集合的方法称为张量的对分(bisection)。 为什么关注SVD？ …. Tensor networks​ 整合上述的操作，可以给出张量网络的一个定义。张量网络是一个图，它告诉我们如何把几个张量组合成一个复合张量。整个张量的秩是由图中不匹配的边的数目给出的。对于给定的外部指标值，由内部组成张量的值的积给出，再进行所有与缩并一致的内部指标求和。一个例子如下图所示： Bubbling​ 张量网络定义为它们的值与组成张量的缩并顺序无关，这影响了计算的复杂性和实用性。张量网络可以从一个张量开始缩并，然后一次一个张量地反复缩并。 ​ 张量引入(introduce)和缩并(constract)的顺序称为冒泡(bubbling)。当冒泡被执行时，网络被吞噬到存储的张量中，直到只剩下结果。不同的收缩途径会带来不同的计算难度，因此网络存在高效的冒泡和低效的冒泡。 上图为低效的冒泡过程，可以看到图中的跟踪张量(红点)最大可以达到$n$阶，即“梯子”的最大长度。这样张量中的元素为$n$的指数级，张量缩并所需要的内存和遍历时间也是指数级的，这在$n$很大的情况下是不可行的。而如果按下图的方式缩并，跟踪张量最多可以达到3阶，只需要固定的内存和线性的时间花销。 ​ 缩并过程中每一步的内存消耗与越过缩并区域边界的每一条腿的维数的积相对应。但是并不是所有的图都有有效的缩并顺序。例如下图的2D格结构，如果张量的数量为$n$，缩并过程中，最小的最大跨越腿数为$\\sqrt{n}$。 这里描述的冒泡每次选取一个张量，然后一个接一个地收缩其他张量，但这通常不是最有效的顺序。通常，多重冒泡方法更快。 Computational complexity​ 一些张量网络由于复杂度理论给出的原因，并不存在有效的缩并过程。可以通过一些优化冒泡算法来加速张量网络缩并的过程，但是这个问题是NP-complete的，并不存在通用的有效方法。即使忽略所使用的特定冒泡，总体缩并过程的复杂性通常也会令人望而却步。 Problem1.考虑下列的张量，每个指标的维度为3维，指标从0开始： 计算下面张量网络的值： answer: 首先，进行全局坐标的分配，给出全局坐标下各张量的表示 结果可以表示为 \\begin{align} T&=\\sum_{\\alpha,\\beta,\\gamma,\\delta,\\epsilon=0}^2 A_{\\alpha,\\beta}B_{\\alpha,\\gamma,\\delta}C_{\\delta,\\epsilon}D_{\\beta,\\gamma,\\epsilon} \\\\ &=\\sum_{\\alpha,\\beta,\\gamma,\\delta,\\epsilon=0}^2(\\beta^2-2\\alpha)(-3^\\alpha\\gamma+\\delta)\\beta\\gamma\\epsilon^2 \\\\ &=1080 \\end{align} 一共$3^5=243$项求和，还是需要计算机来计算的。 2.在这个问题中，我们将考虑展开一个缩并序列，以一种编码收缩时需要的方式。给定一个网络和一个相关的冒泡，我们希望写出一个表来跟踪缩并张量的当前对象的指标，与缩并有关的指标，以及新指标。例如网络 在按字母顺序冒泡的时候，所讨论的表是这样的 那么对于下列的网络 在按字母顺序冒泡时，给出一个对于的上述表格。 这个题目的意义是让读者熟悉张量网络构建的过程，在计算机上执行的算法是怎么样的，数据结构的大概形式如何。current是一个保存着当前的腿的集合，New是新增的要加入current的腿集合，contract则是要减少current的腿的集合。 3. 4.类似于奇异值分解，给定一个指标的对分，我们可以考虑张量的范数。 （a) 算子范数是否依赖于对分，即相同张量的任意两个对分上的算子范数是否一定相等？ ​ 根据算子范式$||M||_\\infty$的定义可以看出，其依赖于张量的对分。 （b) 那么对于Frobenius范数呢？如果不同，画出张量网络图来说明其与对分不相关。 ​ 对于矩阵$M$，Frobenius范数为$Tr(MM’)$。对于三阶张量的F范数，如图所示 ||A||_F =\\sqrt{\\sum_{i_1,\\ldots,i_r}|A_{i_1,\\ldots,i_r}|^2} 可以看到，其值与如何划分指标无关。 Thinking 张量网络缩并的最终结果有什么意义？ 缩并的跟踪张量的变化过程是否包含什么信息？ 缩并的过程是否是可逆的？ 张量网络和神经网络有什么不同之处和相同之处？","link":"/2020/02/18/Introduction-to-tensor-network-notation/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/02/15/hello-world/"},{"title":"近期计划1","text":"量子算法学习 学习绿皮书四五六章 。即量子线路部分，量子傅里叶变换和量子搜索算法部分。仔细思考，包括习题。 学习Andrew M. Childs的量子计算讲义。这部分是在上一步的基础上完成的。","link":"/2020/02/17/%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%921/"},{"title":"本博客的搭建方法","text":"博客搭建过程参考了TRHX的文章 使用 Github Pages 和 Hexo 搭建自己的独立博客 主题选择使用的是ICARUS主题 ICARUS主题展示 在github上clone了ICARUS主题再修改了一些配置项 ICARUS文件 主题的修改过程参考了 搭建自己的技术博客系列（六)","link":"/2020/02/17/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/"},{"title":"tensor network and quantum information","text":"​ 在这一节中，将讨论一些量子信息概念的例子，这些概念可以用张量网络符号更好地理解。 Bell state and the Bell basis​ Bell基(Bell basis)构成了两粒子最大纠缠态的正交集合。Bell基标准的标记如下： |\\Phi^{\\pm}\\rangle :=(|0\\rangle \\otimes |0\\rangle \\pm |1\\rangle \\otimes |1\\rangle)/\\sqrt{2}\\\\ |\\Psi^{\\pm}\\rangle :=(|0\\rangle \\otimes |1\\rangle \\pm |1\\rangle \\otimes |0\\rangle)/\\sqrt{2}\\\\对于第一个基$|\\Phi^{+}\\rangle$，称为Bell态(Bell state)，用$|\\Omega\\rangle$表示。 |\\Omega \\rangle = \\frac{1}{\\sqrt{2} } \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix} \\quad \\mathop{\\rightleftharpoons}_{Vectorise}^{Matricise} \\quad \\frac{1}{\\sqrt{2} } \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} =\\frac{I}{\\sqrt{2} }在张量网络符号中，它被简单地表示为一条连接两条腿的线。 ​ 要注意，这样一个表示包含很深刻的意义，如果将线的末端视为两个比特，对一个比特执行操作相当与对另一个比特执行转置操作，这很容易验证。那么，连线就意味着比特的纠缠。 ​ 定义$|\\Omega(\\Omicron)\\rangle=(\\Omicron\\otimes I)|\\Omega\\rangle$。根据这个定义，我们可以看到Bell基简单的对应着泡利算子的向量化。 |\\Phi^+ \\rangle = |\\Omega(I)\\rangle,\\quad |\\Phi^- \\rangle = |\\Omega(Z)\\rangle, \\quad |\\Psi^+ \\rangle = |\\Omega(X)\\rangle, \\quad |\\Psi^- \\rangle \\propto |\\Omega(Y)\\rangle \\quad​ 因此，可以看到Bell基与Pauli算符密切相关，在Bell基上的欧几里德内积(Euclidean inner product)状态对应于上Pauli算符的希伯特-施密特内积(Hilbert-Schmidt inner product)。 Quantum teleportation​ 给定上面的Bell基标记，我们就可以用TNN来表示和理解量子隐态传输。 |\\phi_B\\rangle = \\mathop{\\overbrace{(p_B)}}^{Correction} \\mathop{\\overbrace{(\\langle\\Omega_{A_1A_2}(p))}}^{Teleportation} \\mathop{\\overbrace{(|\\psi_{A_1}\\rangle \\otimes |\\Omega_{A_2B}\\rangle)}}^{Setup} = |\\psi_B\\rangle/2 ​ 可以看到公式与TNN相对应，公式和TNN都从右往左看。在TNN上用一条竖线往下画，可以截断3条横线，这三条并列的横线与Setup相对应。Teleportation过程相作用了一个左矢，相当于在TNN作用一个开口向右的弧线，将腿的数量减少到1。最后Correction的过程，在B上作用一个$p$。可以看到B最后可以得到$|\\psi\\rangle/2$。然后要验证一下，隐态传输算法中，$p$是否满足如上的关系，确定这TNN表达的合理性。 Gate teleportation |\\phi\\rangle = \\mathop{\\overbrace{(C_p)}}^{Correction} \\mathop{\\overbrace{(\\langle\\Omega_{A_1A_2}(p))}}^{Teleportation} \\mathop{\\overbrace{(|\\psi_{A_1}\\rangle \\otimes |\\Omega_{A_2B}(U^T)\\rangle)}}^{Setup} =C_pUp^{\\dagger}|\\psi\\rangle/2 ​ 如果令$C_p:=UpU^\\dagger$，那么Bob总是可以得到$U|\\psi\\rangle$。如果$U$是Clifford操作(Clifford群是将Paulis映射到Paulis的操作群)，这个修正也是一个泡利，这个传送过程在传送门的使用上并不比标准的传送需要更多的资源。 Purification​ 对于一个混合态$\\rho$，提纯(purification)就是一个将原系统拓展到更大系统(添加的系统称为提纯系统)的纯态(pure state)$|\\psi \\rangle$，以减少原系统$\\rho$的密度。这样的提纯可以给出为$|\\psi\\rangle \\propto (\\sqrt{\\rho} \\otimes I)|\\Omega \\rangle = |\\Omega (\\sqrt{\\rho})\\rangle$。 ​ 通过维度计数，可以看出上述提纯在提纯系统的等轴自由度范围内是唯一的，所以的提纯都是$(\\sqrt{\\rho} \\otimes U)|\\Omega \\rangle$的形式，其中$U^\\dagger U= 1$，即所有的提纯正比于$(\\sqrt{\\rho} \\otimes I)|\\Omega \\rangle$，$|\\Omega\\rangle$可以是其他最大纠缠态。 Stinespring’s Dilation theorem​ Stinespring’s Theorem指出，任意量子通道$\\varepsilon$，即一个完全的正保迹映射(completely positive trace preserving map(CPTP))，可以被表示为一个幺正算符作用在更大的系统上，再取偏迹。 \\varepsilon(\\rho) = Tr_1[V^\\dagger(\\rho \\otimes|0\\rangle\\langle0|)V]在物理上，这意味着，一个动态的开放系统等价于一个更大的封闭系统的子系统。 ​ 任意CPTP映射可以被表示为Kraus操作$K_i$的集合： \\varepsilon(\\rho)=\\sum_i K_i^\\dagger \\rho K_i,\\quad 其中\\sum_i K_iK_i^\\dagger=I.其TNN表示为 接着定义张量$U$为 可以看到$U$满足$U^\\dagger U=I$，可将其视为$V$加上一个附加比特 ​ 通过这样的表示，再对上指标取偏迹，Stinespring Dilation Theorem可以表示为： Problems1.考虑隐态传输的反向。Alice想要将一个经典比特发送给Bob，且她有一个可以传输量子比特的通道。那么单量子比特可以传输多少比特的信息呢？为了简单考虑，只考虑Bob可以执行投影测量的情况。 2.假设Alice和Bob初始共享一个Bell对。这个提前共享的纠缠资源是否可以增加成功传输的经典信息的数量，如果可以的话，增加了多少呢？ superdense coding","link":"/2020/02/19/tensor-network-and-quantum-information/"},{"title":"链接整理","text":"常用谷歌学术镜像 量子计算Andrew M. Childs 量子计算讲义John PreskillQIP’23 蔻享学术视频 TensorNetworkTensorNetworkgoogle/TensorNetwork 计算机dblp: computer science bilbliography","link":"/2020/02/17/%E9%93%BE%E6%8E%A5%E6%95%B4%E7%90%86/"},{"title":"论文修改意见","text":"ABSTRACT 先说了最近提出的一种gate model架构有什么，这个架构有什么作用（写得比较大概）。然后提出架构还应能支持波形补偿和波形标定。因此，文章提出了一种关于电极事件队列的用于超导控制的微架构。它有两个核心：1、电极事件操作单元。2、局部和全局事件的混合电路描述方法。（这里加上这个架构的效果如何，对上面提出问题的解决效果如何）（最后结束的两句话感觉有一些突兀，用FPGA实现可以放到前面，FPGA用缩写就可以） 总的来说，写得有些简略。可以再思考下重点和创新之处如何体现，可以对这些内容多叙述一些。 INTRODUCTION 这一段可以写得更详细一些。运用商用的设备会消耗很多的资源，不具备拓展性。所以现在大家用的都是自定义的专用超导芯片FPGA控制板，这已经部分解决了资源消耗大的问题。付祥的结构应该也是在这之后提出的，所以这个前因要改一下。可以加上目前大家都在用的控制方案，都解决的哪些问题。叙述好整个研究的背景，为后面的要解决的问题做铺垫。 这段以由于量子芯片的硬件限制，架构设计面临新的挑战开头。后面两大块应以硬件限制在哪里，以什么方式去解决的逻辑去说的。第二点，波形补偿段应该改下，这一段看起来就变成了简单的介绍这个方法有什么用，不是从问题提出到解决。可以叙述为串扰有什么影响，然后波形补偿可以如何解决。 it指代什么可以具体化。 可以调整一下叙述顺序，把具体的方法是什么放前面，再说这样的方法有什么效果。参照第一点。 RELATED WORKS distribued和centralized是形容词，可以加个form。开始说主要有两种处理器架构适配不同的语言，段尾又说一次，反复读感觉有些奇怪。 这段介绍了分布式结构，缺少了这样的结构有什么优势和问题。我觉得related works要有目的介绍，介绍的这些要对自己的主题有用，这些架构都有各自的优点，也有各自的缺点，它们又什么做不到的地方，而这些地方是我们架构可以做的，这就让人提起精神。这些虽然会在挑战那部分具体说，前面也需要提，一步步引导。如果只是简单的介绍，让人不太明白这一段跟整个文章又多少联系。 这段是如何与上面相关联的要叙述清楚。前两段分别介绍了分布式和集中式，这一段突然跳到高层抽象的特点，high-level abstration这个词之前没有出现和提到过，用As for得有些奇怪。 全局事件是可行的是本段的论点，可以放前面，更清晰一些。这两段的问题是如何与前面介绍的前人工作联系到一起的，可以说清楚。global event和global event operation用词可以统一一下，统一用一个词。 总的来说，related works结构有些松散，有哪些联系没有说清楚。可以将段间联系加强，变得有连续性。 MICROARCHITECTURAL CHALLENGESLimitations Of The Gate Model 这段介绍了gate model是什么，末尾提到这样的结构不支持波形补偿和波形参数标定。接下来的两部分具体介绍波形补偿和参数标定，讨论gate model为什么不能支持这两种操作。 Waveform compensation 电路模型的波形补偿增加指令数量，减少了电路并行性。可以统一一下说法，改为增加电路深度。因为后两段，说的是gate model在两种情况下考虑补偿所导致的需要描述的操作增加和电路深度的提高。X180这些表示，180放下标或上标可能比较好。另外，高亮这两个公式看不太懂。 Calibration experiment 因为存在噪声等因素，需要进行周期性的标定，这个标定过程不能用门描述完成。 Description Of High Gate Diversity Circuit在高门密度时，付祥的架构会遇到问题。但是一般的控制架构并没有问题，一般的控制架构只是执行测量实验时，波形较长。因此，文章中的gate model说的只是付祥的架构，用gate model来指代付祥的架构是否合适，还应该再考虑一下。如IBM的系统执行时，在qiskit语言编写阶段也是用门操作来描述的，只是后面转化为波形了。 QUANTUM MICROARCHITECTURE 这段介绍结构的大概文件流过程。 这段介绍量子指令集。叙述上，ebQIS包括经典指令和量子指令，经典指令有哪些。这里少了一句话，量子指令有哪些。并在figure 6中表现出来。 Electrode Based Quantum Operation Unit lower-level control具体指代什么。 这一整段看不懂。XYevent_1,XYevent_2在图上代表什么。有XY和Z操作为什么说是单电极事件。这两个例子是怎么和图片对上的。图片注释也需要加上说明上下两幅图都分别代表什么抽象。 Hybrid Event Description Scheme这一部分很长，叙述的结构可以修改一下，不然很难读下去。这部分目前的结构是，第一段说明需要全局事件和部分事件，第二段局域事件是什么和有什么用，第三段全局事件是什么有什么用，这是读者对局域事件和全局事件是什么并没有一个具体的认识。应该把对图10的说明提前，提到局域事件和全局事件的说明中，配合图一起说明，这样读者才容易对这两个概念产生具体的图像。然后再说这样的设定有说明作用，为什么可以用在不同的实验中。 图b左边是如何对应于右边的要说清楚。 XYevent_1、XYevent_2,3、XYevent_4，代表说明图中并没有相应的对应。这和前面的XYevent_1,XYevent_2是不是一个东西。 总的来说，Hybrid Event Description Scheme，这一段太长了，而且很多指代不明，不是按照图来说的，很难看懂。 Multi-level Compilation Scheme 这张图的图b可以改为上下并列的，并用相同的时间刻度，标上哪部分是XY电极执行的，哪部分是Z电极执行的。 这一段太长了，而且没有明显的分点分段突出，读不下去。和前面一样，可以多分段，多分点。 IMPLEMENTATIONfigure 15是不是和figure 5有些重复了。 implementation将微架构各小部件介绍了一遍。很多都是经典计算机中很成熟的东西，不用介绍那么多。我们没实际做过，这部分写起来就像写流水账一样。另外，注意分点。 EVALUATION 按照SG、MG、EB分段，把这些词放在段首，并斜体化。后面也要根据不同的讨论点分点分段。","link":"/2020/02/17/%E8%AE%BA%E6%96%87%E4%BF%AE%E6%94%B9%E6%84%8F%E8%A7%81/"},{"title":"量子线路","text":"计算机是物理的对象，而计算是物理的过程。计算机计算的范围完全由物理定律而不是纯数学决定 ———-David Deutsch 量子线路语言是描述量子算法有效和有力的描述方式，它包含描述计算过程的一组离散元件的集合。这个工具将使我们能够用类似于需要的门的总数或线路深度来量化算法的花销，也带来了一些简化算法设计的丰富技巧，并较容易从概念上形象的认识算法。 单量子比特计算单量子比特表示 |\\psi\\rangle = a|0\\rangle+b|1\\rangle \\qquad其中，复数a,b满足 \\quad{|a|}^2+|b|^2=1一些重要矩阵，Pauli矩阵： X\\equiv\\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix} , Y\\equiv\\begin{bmatrix} 0 & -i \\\\ i & 0 \\end{bmatrix} , Z\\equiv\\begin{bmatrix} 1 & 0 \\\\ 0 & -1 \\end{bmatrix}Hadamard门、Phase gate和$\\pi/8$门： H=\\frac{1}{\\sqrt{2}}\\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix} , S=\\begin{bmatrix} 1 & 0 \\\\ 0 & i \\end{bmatrix} , T=\\begin{bmatrix} 1 & 0 \\\\ 0 & exp(i\\pi/4) \\end{bmatrix}旋转算子定义如下： 练习4.1受控运算本节说明，如何从基本运算基础搭建起来的量子线路实现复杂的受控运算。 CNOT 相当于$|c\\rangle|t\\rangle \\rightarrow |c\\rangle|t\\bigoplus c\\rangle$ controlled-U 相当于$|c\\rangle |t\\rangle \\rightarrow |c\\rangle U^c |t\\rangle$ 测量量子线路测量有两个重要原理值得记住。 _推迟测量原理(principle of deferred measurement)_总可以把测量从量子线路的中间步骤移到线路的末端；如果测量的结果被用于线路的某些阶段，则经典的运算可以被条件量子运算代替。 \\langle !— more —&gt; 隐含测量原理（principle of implicit measurement)不失一般性，量子线路中任何未终结的量子连线（未被测量的量子比特）总可以假设为被测量。 测量的一个普遍特点——为使一个测量是可逆的，它一定不能揭示被测量子状态的任何信息 通用量子门Two-level unitary gates are universal 对于作用在d维Hilbert空间上的酉矩阵U，可以分解非两级酉矩阵的乘积，即只不平凡地作用在向量的一个或两个分量上的酉矩阵， Single qubit and CNOT gates are universal 单量子比特门和受控非门可以实现n量子比特状态空间上的任意两级酉运算。因此，结合前一条结论，单量子比特门和受控非门可以实现n量子比特状态空间上的任意酉运算，于是它们对量子计算是通用的。 A discrete set of universal operations 门的离散集合不可能精确实现任意的酉运算，因为酉运算的集合是连续的。然而，可以用一个离散的集合去近似任意的酉运算。 Hadamard + phase + CNOT + π/8 是一个通用门集合。 但是要注意的是近似任意酉门通常是难的。 量子线路模型的关键要素 经典资源。量子计算机包括两部分，经典计算部分和量子计算部分。在计算中允许部分计算以经典的方式进行，某些任务的完成将容易得多。 适当的状态空间。量子线路在某个数目为n的量子比特组上进行操作，因此状态空间是$2^n$维复Hilbert空间。积形式$|x_1,\\cdots,x_n\\rangle$，其中$x_i = 0,1$的状态称为计算机的计算基态。$|x\\rangle$表示一个计算基态，其中$x$是二进制表示为$x_1 \\cdots x_n$的数。 将状态置于计算基中的能力。假设任何的计算基态$|x_1,\\cdots,x_n\\rangle$可以在至多n步内制备出来。 进行量子门运算的能力。门可以随意应用到量子比特的任意子集，并可以实现一组通用门。例如，在量子计算机上可以把受控非门用到任何一对量子比特上，Hadamard门、相位、受控非门和$\\pi/8$门构成一组可以近似任意酉运算的门，因此是一组通用门，还存在其他的通用类。 在计算基中测量的能力，计算机中可以进行在计算基中一个或多个量子比特的测量。 量子系统的仿真仿真原理用经典计算机模拟量子系统是可能的，但一般而言不是很有效。许多简单量子系统的动态行为服从Schrodinger方程 i\\hbar \\frac{d}{dt} | \\psi\\rangle = H | \\psi\\rangle我们常常将$\\hbar$放入$H$中。对于一个研究空间中实际粒子的物理学家感兴趣的Hamilton量，这个方程可以简化为 i\\frac{\\partial}{\\partial t} \\psi(x) = [-\\frac{1}{2m}\\frac{\\partial^2}{\\partial x^2} + V(x)]\\psi(x)其中使用了称为位置表示的约定$\\langle x|\\psi\\rangle = \\psi (x)$。 仿真Schrodinger方程并不是模拟量子系统中面临的特殊困难。模拟量子系统的关键挑战是，必须求解的微分方程为指数数目。对$n$量子比特的系统，必须求解$2^n$个方程。有时具有洞察力的近似可以减少方程个数，从而使这种量子系统的经典仿真成为可行。然而，有许多物理上有意义的量子系统，人们尚不知道它们的这类近似。 量子仿真算法量子仿真算法的核心是渐近近似定理。 (Trotter公式) 令$A$和$B$是Hermite算子，则对任意实数$t$，有 {\\lim_{n \\to +\\infty}}(e^{iAt/n}e^{iBt/n})^n = e^{i(A+B)t/n}注意，即使对$A$和$B$不对易的情况也是成立的。 算法 量子仿真 输入 （1）作用在N维系统上的Hamilton量$H = \\sum_{k} H_k$，其中每个$H_k$作用在规模独立于N的小的子系统上；（2）系统在$t=0$时刻的初态$| \\psi_0\\rangle$；（3）正的非零精度$\\delta $；（4）获得期望状态的时间$ t_f $。 输出 状态$|\\widetilde{\\psi}(t_f)\\rangle$，使得$|\\langle \\widetilde{\\psi}(t_f)|e^{-iHt_f}|\\psi_0\\rangle|^2 \\geq 1-\\delta$。 运行时间 $O(poly(1/\\delta))$数目的操作。 过程 选择一个表示，使得$n=poly(logN)$量子比特的状态$| \\widetilde{\\psi}\\rangle$能近似系统状态，且算子$e^{-iH_k \\Delta t}$有有效的量子线路近似。选择一个近似方法和$\\Delta$，使得期望误差是可接受的（并且对某个整数$j$，$j\\Delta t = t_f$），为迭代构造一个相应的量子线路$ U_{\\Delta t}$，并且执行： $|\\widetilde{\\psi}_0\\rangle \\leftarrow |\\psi_0\\rangle$；$j=0$ //状态初始化 $\\rightarrow |\\widetilde{ {\\psi} }_{j+1}\\rangle =U_{\\Delta}|\\widetilde{ {\\psi} }_{j}\\rangle$ //迭代更新 $\\rightarrow j=j+1$，转到（2）直到$j\\Delta t \\geq t_f$ //循环 $\\rightarrow |\\widetilde{\\psi}(t_f)\\rangle = |\\widetilde{\\psi}_{j}\\rangle$ //最终结果","link":"/2020/02/17/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF/"},{"title":"Projected entangled pair states","text":"MPS背后的许多思想都是通过投射的纠缠对状态(PEPS)，推广到更高的维度。我们将在两个方面看到这是一个误称，不一定有一个投影仪，也不一定有一对纠缠。 我们首先回顾矩阵积状态的PEPS描述，然后将其推广到二维模型。给出几个例子之后，我们将研究的性质，与MPS的异同。 One dimensional systems: MPS一维结构的PEPS结构如下。令$|\\psi \\rangle \\in \\mathbb{C}^D \\otimes \\mathbb{C}^D$为纠缠对，$P: \\mathbb{C}^D \\otimes \\mathbb{C}^D \\rightarrow \\mathbb{C}^d$为线性映射 正如我们所看到的，在具体的描述上我们有很大的选择。我们可以通过任意(左)可逆矩阵变换纠缠对中每个自旋的局部基 | \\phi \\rangle \\rightarrow (A \\otimes B) | \\phi \\rangle因为我们可以修改P来补偿 P \\rightarrow P(B^{-1} \\otimes A^{-1})$| \\phi \\rangle$不一定是有效的量子态。为了方便，我们通常不把它正规化。 除了这个量规的自由，我们有额外描述选择。我们可以用纠缠三态作为例子 令$|\\psi \\rangle = |000\\rangle +|111\\rangle$，可以选择PEPS为 显然，这并没有提供比使用纠缠对更强的描述能力。假设我们有一些PEPS的投影放Q作用于一对纠缠态，然后我们可以把它扩展到P作用于纠缠三态 P=Q(1 \\otimes (|0\\rangle \\langle 00| + |1 \\rangle \\langle 11|))Extending to higher dimensions从一维系统到高维系统的扩展是直接进行的。我们将讨论超立方晶格的简单情况，但这个框架可以在任何图形上进行。特别地，我们将限制在2维 其中 P: (\\mathbb{C}^D)^{\\otimes 4} \\rightarrow \\mathbb{C}^d是一些从虚空间到物理空间的线性算子。 显然，在这个描述中有大量的规范自由度，就像在一维情况下一样。每一个虚自旋的任何可逆变换都可以用投影仪P的定义来补偿。 在MPS中，人们可能会问，使用不同的缠结结构是否会导致更强的描述能力。很容易看出，一般情况并非如此。假设我们选择在GHZ状态下放置plaquettes，然后在plaquettes之间使用PEPS投影。 我们可以使用一个标准的PEPS来准备这个资源状态，因此任何可以从这个“projected entangled plaquette”结构中准备的状态都可以从一个pep中准备，只需要很少的额外成本。 Some PEPS examples来看几个PEPS的例子。 Product state GHZ state RVB state令为键维度为$D=3$ $\\alpha \\in {1,2}$为唯一非零元素PEPS张量。假设我们将这些张量压平并投射悬空指标到$|2\\rangle$态。结果的物理状态是什么？ 这种状态被称为共振价键态，由晶格中所有完全倾斜的叠加和最大纠缠对组成 Kitaev’s Toric code Toric code ground state2D cluster state and the complexity of PEPS令键维度为$D=2$ 为PEPS中的非零元素。生成的物理状态是2D聚态，是基于测量的量子计算的通用资源。 如果我们能有效地求出PEPS之间的内积。然后，我们可以通过简单地将秩1投影到这些PEPS张量的物理指标上，来清楚地经典地模拟单个比特后选定的测量值。这告诉我们，即使是简单的PEPS状态，我们也无法有效地收缩，除非后选的量子计算可以经典地模拟出来(Post - BQP = BPP)。 Numerical PEPS在许多实际情况下，在有限的和无限的系统大小限制下，都可以实现PEPS网络的近似收缩。 Properties of PEPSMPS和PEPS这两种张量网络状态在性质上是不同的，无论是在物理上，还是在张量网络的计算能力上 Aside(Tensor network for classical partition function) 令$H[s] = \\sum_{\\langle i ,j \\rangle} h [s_i , s_j]$为一个经典的哈密顿量。我们经常计算的是配分函数$Z = \\sum_ e^{-\\beta H[s]}$，系统的温度为$\\beta$。我们可以用一个简单的张量网络来帮忙。 定义两个张量 在每个经典自旋上放一个D张量，在每个相互作用上放一个M张量，下面的张量网络可以用来表示配分函数 通过在网络中插入局部张量，可以计算出热期望值。例如 注意，通过结合D和M张量，配分函数可以用一个张量来描述 令 H = -J \\sum_{\\langle i,j \\rangle} s_is_j其中$s \\in { \\pm 1 }$，为经典Ising模型。张量Q可以简化为 Algebraic decay of correlationsMPS只能捕获具有指数衰减相关性的状态(当然也可以是恒定相关性)。现在我们来看看这是否适用于PEPS。我们可以通过修改上述结构来建立一个与经典配分函数相对应的PEPS状态 或者等价的整合为 定义PEPS态为 注意这是纯态，不是热态。它并没有被归一化，$\\langle \\psi | \\psi \\rangle = Z$。用这种状态计算的相关函数与用经典统计物理计算的相关函数相等。假设我们考虑一个具有热相变的经典模型(如上面的伊辛模型)。在临界温度下，该模型的相关系数会出现代数衰减，这意味着对应的PEPS也会出现代数衰减。因此，我们可以看到，与MPS不同，PEPS所描述的状态可以显示出相关的代数衰减。 Gauge freedomPEPS张量的规范自由度是MPS自由度的简单概括。和以前一样，我们可以一起阻塞张量而不改变全局状态。此外，我们可以执行以下转换(在平移不变的PEPS上)： 其中$N$和$M$为可逆矩阵。 回想一下，在MPS的情况下，我们可以利用这种自由把张量变成正则形式。这在PEPS的情况下是不可能完全实现的，尽管有一些数值方法可以将PEPS转换成近似的规范形式。 Problem1.要在顶点上有自旋的蜂窝晶格上建立GHZ状态，需要什么样的PEPS张量？ 2.通过沿着水平缩并下列张量指标可以得到什么量子操作门？","link":"/2020/02/28/Projected-entangled-pair-states/"},{"title":"Tensor network learning framework","text":"根据张量网络学习网站tensornetwork列出的张量网络学习框架。 Fundamentals [x] Tensor Diagram Notation Types of Tensor Network [x] Matrix Product State / Tensor Train [x] Matrix Product Operator [ ] Tree Tensor Network [ ] PEPS [ ] MERA Tensor Network AlgorithmsMPS/TT and MPO AlgorithmsElementary MPS/TT Algoithms [ ] Retrieving a Single MPS/TT Component [ ] Inner Product of Two MPS/TT [ ] Compression of MPS/TT Solving Linear Equations (DMRG, etc) [x] DMRG(Density Matrix Renormalization Group) Summing MPS/TT Networks [ ] Density Matrix Algorithm [ ] Direct Algorithm Multiplying an MPS/TT by an MPO [ ] Density Matrix Algorithm [ ] Fitting Algorithm [ ] Zip-Up Algorithm Times Evolution Algorithms [x] Trotter Gate Time Evolution (TEBD) [ ] MPO Time Evolution MPS-local methods [ ] Time-Step Targeting Method (Local Krylov) [ ] Time-Dependent Variational Principle (TDVP) [ ] Krylov Time Evolution (Global Krlyov) TRG AlgorithmComputing with Tensor Networks [x] Tensor Software [ ] Software Benchmarks Applications of Tensor Networks [ ] Quantum Physics","link":"/2020/02/28/Tensor-network-learning-framework/"}],"tags":[{"name":"Tensor Netwowrk","slug":"Tensor-Netwowrk","link":"/tags/Tensor-Netwowrk/"},{"name":"计划","slug":"计划","link":"/tags/%E8%AE%A1%E5%88%92/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"链接","slug":"链接","link":"/tags/%E9%93%BE%E6%8E%A5/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"量子线路","slug":"量子线路","link":"/tags/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF/"}],"categories":[{"name":"Tensor Netwowrk","slug":"Tensor-Netwowrk","link":"/categories/Tensor-Netwowrk/"}]}