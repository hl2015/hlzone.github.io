{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"Classical Mechanics","text":"经典力学复习总结 经典力学基础Newton质点和质点系力学运动的描述方式 经典力学的理论框架 时空性质：空间和时间是与物质及其运动无关的独立存在 Galileo相对性原理：描述经典运动的基本定律如果在一个参考系中成立，在相对该参考系做匀速运动的参考系中也成立。 参考系。可以分为惯性系和非惯性系两类。 质点。当问题与物体的形状大小无关时，将物体视为一个几何点。 坐标系。直角坐标系、球坐标系、极坐标系、自然坐标系等。 一些基础的概念 运动学方程。 位移和路程。 速度和速率。 加速度。 平动参考系和转动参考系。 Newton质点动力学 Newton三定律。 惯性定律 $F = ma$ 相互作用 质点运动微分方程 F(r,\\dot{r},t)=\\frac{d}{dt}(mv)=m\\dot{v}=m\\ddot{r} 质点力学中的守恒定律 动量守恒。$p_k=mv_k= const$ 角动量守恒。$J=r\\times p =const$ 机械能守恒。$T+V=const$ 质点系动力学引入质心的概念 r_c = \\frac{\\sum_k m_kr_k}{m}\\\\ m=\\sum_k m_kNewton-Euler刚体力学刚体 刚体的概念。讨论自由度。 刚体的简单运动。 平动 定轴转动 平面平行运动。瞬心：速度为零的点。 刚体定点运动3个自由度。 Euler运动学方程。 Lagrange力学虚功原理和d‘Alembert原理约束及其分类一些概念 约束：限制质点系或连续体系运动的各类条件。 位形：各质点或连续体系中各小“单元”的“位置”或“位移”的集合。位形空间是数学空间。 虚(virtual)位移和实(real)位移：虚位移系指假设的位移，在若干条虚位移中只有一条真实的位移。如果实位移用$dx_k$表示，虚位移表示为$\\delta x_k$。 约束反力和主动力：由约束产生的反作用力。约束反力之外的力称为主动力。 虚功和实功：在虚位移上所作的功被称为虚功。 约束的分类 理想约束和非理想约束：理想约束系指在任何虚位移上，约束反力的元功之和恒为零的约束。 稳定约束和不稳定约束：稳定约束系指约束方程中不显含时间。 可解约束和不可解约束：可解约束只限制体系在某一方向的位移，而在其它方向可以脱离的那种约束。$f(x_k,t)\\leq C$为可解约束。$f(x_k,t)=C$为不可解约束。 完整约束（几何约束）、微商约束（运动约束）和非完整约束。 被动约束和主动约束。 等时变分和全变分变分$\\delta$与微分$d$可对易，$\\delta(dx_k)=d(\\delta x_k)$。 全变分：变分$\\Delta$与导数$\\frac{d}{dt}$之间不可对易的变分 \\Delta(\\frac{dx_k}{dt})=\\frac{d}{dt}(\\Delta x_k)-\\frac{dx_k}{dt}\\frac{d}{dt}(\\Delta t) \\qquad (\\Delta t \\neq 0)等时变分：变分$\\delta$与导数$\\frac{d}{dt}$之间是有条件可对易的变分 \\delta (\\frac{dx_k}{dt}) = \\frac{d}{dt}(\\delta x_k) \\qquad (\\delta t=0)虚功原理虚功原理的表述：具有理想约束的质点系，其达到平衡的充分必要条件是，在任何虚位移上，主动力的元功之和为零。 \\delta W = F_k \\delta x_k =0虚功原理的缺点： 不能求解约束反力。 只能处理静力学问题，方程中缺少惯性力。 d‘Alembert原理在虚功原理中加入了惯性力 (F_k - \\frac{dp_k}{dt})\\delta x_k = 0广义量自由度：约束条件$f_{\\beta}(x_i)=0$的数目为$s$时$(i=1,\\cdots,3n;\\beta=1,\\cdots,s)$，位形的总数被规定为$m=(3n-s)$，这样定义的位形为Lagrange位形，即自由度数。 广义坐标：用$q_k(k=1,\\cdots,m)$表示，$m=3n-s$ $3n$个d’Alembert位形$x_i(i=1,\\cdots,3n)$与$m$个Lagrange位形$q_k(k=1,\\cdots,m)$之间有如下关系： x_i=x_i(q_k) \\qquad (i=1,\\cdots,3n;k=1,\\cdots,m)广义坐标的微分： dx_i=\\frac{\\partial x_i}{\\partial q_k}dq_k \\\\ \\dot{x}_i= \\frac{\\partial x_i}{\\partial q_k} \\dot{q}_k \\\\ \\frac{\\partial \\dot{x}_i}{\\partial \\dot{q}_k} = \\frac{\\partial x_i}{\\partial q_k}$\\dot{q}_k$为广义速度，$\\ddot{q}_k$为广义加速度 广义质量： 系统的动能 T=\\frac{1}{2}m_i(\\dot{x}_i)^2=\\frac{1}{2}m_i \\frac{\\partial x_i}{\\partial q_k}\\frac{\\partial x_i}{\\partial q_l}\\dot{q}_k \\dot{q}_l广义质量 M_{kl}=m_i \\frac{\\partial x_i}{\\partial q_k}\\frac{\\partial x_i}{q_l}Euler定理： \\dot{q}_k \\frac{\\partial T}{\\partial \\dot{q}_k} = 2T广义动量： p_k = \\frac{\\partial T}{\\partial \\dot{q}_k}又有 p_k = \\frac{\\partial T}{\\partial \\dot{q}_k} =m_i \\dot{x}_i \\frac{\\partial \\dot{x}_i}{\\partial \\dot{q}_k} =m_i \\dot{x}_i \\frac{\\partial x_i}{\\partial q_k}\\\\ p_i = m_i \\dot{x}_i\\\\ p_k = p_i \\frac{\\partial x_i}{\\partial q_k}$p_i$为d’Alembert动量 广义力： dW = F_i dx_i = F_i \\frac{\\partial x_i}{\\partial q_k} dq_k \\\\ Q_k = F_i \\frac{\\partial x_i}{\\partial q_k}虚功原理： \\delta W = Q_k \\delta q_k = 0不稳定情况： x_i = x_i(q_k,t)Lagrange未定乘数法可以解决约束反力和具有多余约束的问题 设质点系由$n$个质点组成，该系统受到$s$个完整的约束 f_\\beta (x_i)=0 \\qquad (i=1,\\cdots,3n;\\beta = 1,\\cdots,s)d’Alembert位形坐标系中 f_{\\beta}(x_i+\\delta x_i)=0Taylor展开 f_\\beta (x_i+\\delta x_i)=f_\\beta(x_i)+\\frac{\\partial f_\\beta}{\\partial x_i}\\delta x_i+\\cdots=0略去高阶小量 \\frac{\\partial f_\\beta}{\\partial x_i}\\delta x_i =0再加上虚功原理部分可得 F_i + \\lambda_\\beta \\frac{\\partial f_\\beta}{\\partial x_i} = 0 \\qquad (i=1,\\cdots,3n;\\beta = 1,\\cdots,s)未知量数目$(3n+s)$大于方程数目$(3n)$，需要和约束方程一起求解。 广义坐标系中类似的 Q_k + \\lambda_\\beta \\frac{\\partial f_\\beta}{\\partial q_k} = 0 \\qquad (k=1,\\cdots,m;\\beta = 1,\\cdots,s)$\\lambda_\\beta$的物理意义：约束反力 Lagrange方程由Newton第二定律推导Langrange方程时间的全导数$\\frac{d}{dt}$与广义坐标的偏导数$\\frac{\\partial}{\\partial q_k}$之间可对易 \\frac{\\partial }{\\partial q_k}(\\frac{d}{dt}) =\\frac{d}{dt}(\\frac{\\partial}{\\partial q_k}) \\frac{dp_i}{dt}=F_i \\\\ \\frac{dp_i}{dt} \\frac{\\partial x_i}{\\partial q_k}=F_i \\frac{\\partial x_i}{\\partial q_k}\\\\ \\frac{d}{dt}(p_i\\frac{\\partial x_i}{\\partial q_k})-p_i\\frac{d}{dt}(\\frac{\\partial x_i}{\\partial q_k}) = Q_k \\\\ \\frac{d}{dt}(m_i\\dot{x}_i\\frac{\\partial \\dot{x}_i}{\\partial \\dot{q}_k}) - m_i \\dot{x}_i \\frac{\\partial \\dot{x}_i}{\\partial q_k}=Q_k又 T=\\frac{1}{2} m_i \\dot{x}_i^2得 \\frac{d}{dt}\\frac{\\partial T}{\\partial \\dot{q}_k}-\\frac{\\partial T}{\\partial q_k}=Q_k这就是Lagrange方程 由d’Alembert原理推导 \\delta x_i = \\frac{\\partial x_i}{\\partial q_k}\\delta q_k \\\\ Q_k = F_i \\frac{\\partial x_i}{\\partial q_k}\\\\ \\frac{\\partial \\dot{x}_i}{\\partial q_k}= \\frac{d}{dt}(\\frac{\\partial x_i}{\\partial q_k})代入d’Alembert原理 (-\\frac{dp_i}{dt}+F_i)\\delta x_i = 0可以得到 (-\\frac{dp_i}{dt}\\frac{\\partial x_i}{\\partial q_k}+Q_k)\\delta q_k =0经过同样的演绎 -(\\frac{d}{dt}\\frac{\\partial T}{\\partial \\dot{q}_k}-\\frac{\\partial T}{\\partial q_k}-Q_k)\\delta q_k=0主动力为保守有势力时的Lagrange方程 Q_k = -\\frac{\\partial V}{\\partial q_k} \\frac{d}{dt}\\frac{\\partial T}{\\partial \\dot{q}_k}-\\frac{\\partial T}{\\partial q_k} = -\\frac{\\partial V}{\\partial q_k}定义Lagrangian为 L=T-V考虑到，通常情况下势能$V(q_k)$仅仅是位形$q_k$的函数 \\frac{\\partial V(q_k)}{\\partial \\dot{q}_k}=0Lagrange方程写为 \\frac{d}{dt}\\frac{\\partial L}{\\partial \\dot{q}_k}-\\frac{\\partial L}{\\partial q_k} = 0 \\\\ L=L(q_k,\\dot{q}_k,t)广义动量的定义式可以被写为 p_k = \\frac{\\partial L}{\\partial \\dot{q}_k}主动力中含有非保守力 \\frac{d}{dt}\\frac{\\partial L}{\\partial \\dot{q}_k}-\\frac{\\partial L}{\\partial q_k} = Q_k广义力$Q_k$中只包含非保守力，保守力已进入Lagrangian中 Lagrange方程的首次积分和守恒定律运动积分的概念 L=L(q_k,\\dot{q}_k,t)方程的解表示为 q_k = q_k(t,c_1,\\cdots,c_{2m}) \\\\ \\dot{q}_k = \\dot{q}_k(t,c_1,\\cdots,c_{2m})消去$t$,可以得到$(2m-1)$个方程 c_\\alpha = c_\\alpha(q_k,\\dot{q}_k)它们相互独立，都是Lagrange方程的运动积分。 广义动量积分L中不出现$q_k$，则$\\frac{\\partial L}{\\partial q_k}=0$ \\frac{d}{dt}\\frac{\\partial L}{\\partial \\dot{q}_k}=\\frac{d p_k}{dt}=0 p_k = const广义能量积分Hamiltion积分 当L不显含时间$t$，则$\\frac{\\partial L}{\\partial t}=0$ \\begin{align} \\frac{dL}{dt} & =\\frac{\\partial L}{\\partial t} + \\dot{q}_k \\frac{\\partial L}{\\partial q_k} + \\ddot{q}_k \\frac{\\partial L}{\\dot{q}_k} \\\\ & = 0+ \\dot{q}_k(\\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{q}_k})+\\ddot{q}_k \\frac{\\partial L}{\\partial \\dot{q}_k} = \\frac{d}{dt} (\\dot{q}_k \\frac{\\partial L}{\\partial \\dot{q}_k}) \\end{align} \\frac{d}{dt}(\\dot{q}_k \\frac{\\partial L}{\\partial \\dot{q}_k}-L) = 0记 H(q_k,\\dot{q}_k,t)=\\dot{q}_k \\frac{\\partial L}{\\partial \\dot{q}_k}-L广义能量为 H(q_k,\\dot{q}_k)=const广义动量定理 p_i(\\Delta t) - p_i(0)=\\int_0^{\\Delta t}F_i dt=G_i \\\\ p_k(\\Delta t) - p_k(0)=\\int_0^{\\Delta t}Q_k dt=G_k带电粒子在电磁场中的Lagrangian L=T-U= \\frac{1}{2}mv^2-e(\\phi - \\frac{1}{c}v_k A_k)rlc电路中的Lagrange方程 l \\frac{d^2 e}{dt} + r \\frac{de}{dt} + \\frac{e}{c}=\\varepsilon(t)变分问题的Euler方程 J = \\int_A^B f(y,\\dot{y},x)dx = min当 \\frac{d}{dx} \\frac{\\partial f}{\\partial \\dot{y}} - \\frac{\\partial f}{\\partial y}=0有$\\delta J = 0$ Hamilton原理 \\begin{align} \\int_0^{\\tau} (\\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{q}_k} - \\frac{\\partial L}{\\partial q_k}) \\delta q_k dt &= \\int_0^\\tau [\\frac{d}{dt}(\\frac{\\partial L}{\\partial \\dot{q}_k} \\delta q_k)-(\\frac{\\partial L}{\\partial q_k} \\delta q_k + \\frac{\\partial L}{\\partial \\dot{q}_k \\delta \\dot{q}_k})]dt \\\\ & = \\frac{\\partial L}{\\partial \\dot{q}_k} \\delta q_k \\Big{|}_0^\\tau - \\delta \\int_0^\\tau Ldt =0 \\end{align}由于有共同的端点 \\delta q_k \\Big{|}_0^\\tau = 0可以省略第一项，Lagrange方程相当于 \\delta \\int_0^\\tau Ldt = 0记Hamilton主函数为 S=\\int_0^\\tau LdtLagrange方程相当于 \\delta S=0这就是Hamilton原理 Hamilton力学Legendre变换Lagrangian $L(q_k,\\dot{q}_k,t)$是广义坐标$q_k$，广义速度$\\dot{q}_k$和时间$t$的函数。如果要将广义速度变换为广义动量$p_k$作为新的自变量，而保留广义坐标和时间不变。 df(x,y)=udx+vdy \\\\其中 u = \\frac{\\partial f}{\\partial x} \\\\ v= \\frac{\\partial f}{\\partial y}设 g(u,y) = xu-f这就是Legendre变换 \\begin{align} dg(u,v)&=xdu+udx-df = xdu+udx-udx-vdy \\\\ & = xdu-vdy \\end{align} x = \\frac{\\partial g}{\\partial u} \\\\ v = - \\frac{\\partial g}{\\partial y}Hamilton正则方程Hamiltonian，正则函数 H(q_k,p_k,t) = \\dot{q}_k p_k - L(q_k,\\dot{q}_k,t)Hamilton正则方程 \\left\\{ \\begin{aligned} \\dot{q}_k & = \\frac{\\partial H}{\\partial p_k} \\\\ \\dot{p}_k &= -\\frac{\\partial H}{\\partial q_k} \\end{aligned} \\right.Hamilton正则方程与Lagrange方程没有本质上的区别 它们都用能量来表示 它们均不含约束反力 它们都是用来解决系统的动力学问题 Hamilton正则方程由$2m$个一阶方程组成微分方程组，而Lagrange方程由$m$个二阶微分方程组成。 正则方程的循环积分 \\dot{p}_k = - \\frac{\\partial H}{\\partial q_k}=0 \\\\ p_k = const正则方程的广义能量积分若H不显含时间 \\frac{\\partial H}{\\partial t}=0广义能量积分为 H = const = EPoisson括号 \\frac{df}{dt} = \\frac{\\partial f}{\\partial t} + \\frac{\\partial H}{\\partial p_k} \\frac{\\partial f}{\\partial q_k} - \\frac{\\partial H}{\\partial q_k} \\frac{\\partial f}{\\partial p_k}记poission括号为 [H,f] = \\frac{\\partial H}{\\partial p_k} \\frac{\\partial f}{\\partial q_k} - \\frac{\\partial H}{\\partial q_k} \\frac{\\partial f}{\\partial p_k}正则方程的Poission括号表示 \\left\\{ \\begin{aligned} \\dot{q}_k & = [H,q_k] \\\\ \\dot{p}_k &= [H,p_k] \\end{aligned} \\right.","link":"/2020/03/17/Classical-Mechanics/"},{"title":"Introduction to tensor network notation","text":"​ 张量网络有效的一个主要原因是通常用来描述它们的直接而透明的符号。使用图形语言，结构是明显的。研究对象的许多一般性质，特别是量子态，可以直接从描述它们所需的网络结构中识别出来。 ​ Tensor network notation(TNN)可以看成Einstein summation notation 的推广。接下来的部分，将介绍张量和可以对其进行的操作。 Tensors​ 张量是向量和矩阵的推广。一个$d$维向量可以看成是$\\mathbb{C}^d$的有序集合。一个$n\\times m$维矩阵可以看成是$\\mathbb{C}^{n\\times m}$的有序集合。一个维度为$d_1 \\times \\cdots \\times d_r$的$r$阶(rank-r)张量可以看成是$\\mathbb{C}^{d_1 \\times \\cdots \\times d_r}$的有序集合。标量、向量和矩阵可以分别视为0阶，1阶和2阶张量。 ​ 在张量网络记数法中，一个张量简单地用一个伸出来的几何图形表示，每个张量对应一个指标，类似于爱因斯坦记数法的指标。例如，一个4阶的张量R可以表示为 ​ 在某些情况下，腿的形状和方向可以表示张量或指标的某些性质——但是对于一般的网络来说，两者都没有什么特殊的意义。在表示量子态时，通常可以方便地使用腿的方向来表示对应的向量是存在于Hilbert空间(‘kets’)还是其对偶(‘bras’)中。通过这个约定，可以避免执行一些禁止的缩并(contraction)，例如两个右矢(‘kets’)的缩并。 Tensor operations​ TNN表示的一个主要优点在于一个张量可以表示为一些其它张量的复合。两个主要的操作为张量积(product)和迹(trace)，常用于联合操作(joint operation)的缩并。除了这两个操作，一个张量的秩，即阶数，也可以通过分组或分裂指标来改变(grouping/splitting indices)。 Tensor product​ 张量可以视为向量外积的推广。张量积在给定指标集上的值是每个张量相应指标元素值的乘积。显示地用指标符号表示，二元张量积的形式为： [A \\otimes B]_{i_1,\\ldots,i_r,j_1,\\ldots,j_s }:=A_{i_1,\\ldots,i_r}\\cdot B_{j_1,\\ldots,j_s}从下图可以看到，张量积就是两个紧挨着的张量。因此，一个包含不相交张量的网络的值就是组成值的乘积。 Trace​ 取迹操作((partial) trace)。对于$x$指标和$y$指标维数相同($d_x=d_y$)的张量$A$，着两个维度的部分取迹操作就是这两维上相同指标数据的相加求和。 [Tr_{x,y}A]_{i_1,\\ldots,i_{x-1},i_{x+1},\\ldots,i_{y-1},i_{y+1},\\ldots,i_r}= \\sum_{\\alpha=1}^{d_x}A_{i_1,\\ldots,i_{x-1},\\alpha ,i_{x+1},\\ldots,i_{y-1},\\alpha,i_{y+1},\\ldots,i_r}类似于爱因斯坦符号，这个求和在TNN中是隐式的，由相对应的连接的腿表示。与爱因斯坦表示法相比，它的一个优点是不需要对这些求和指数进行命名，这使得这种表示法对于大型网络来说不那么笨拙。 ​ 从这个符号中我们可以很容易地看出迹的一个性质是它的循环性质。通过简单地滑动其中一个矩阵，这只会改变网络中张量的位置，因此不会改变值，我们可以循环这些矩阵(注意移位)来证明$Tr(AB)=Tr(BA)$。 Contraction​ 最常用的张量运算是缩并(constraction)。一个例子是两个3阶张量的两对指标之间的缩并： 上图中六个指标缩并为两个。 ​ 常见的压缩例子有向量内积、矩阵-向量乘法、矩阵-矩阵乘法和矩阵的迹。 Grouping and splitting​ 在张量网络的研究中，秩是一个相当不稳定的概念。张量空间$\\mathbb{C}^{a_1 \\times \\cdots \\times a_n}$和$\\mathbb{C}^{b_1 \\times \\cdots \\times b_m}$在维数匹配时($\\prod_i a_i =\\prod_i b_i$)可以同构同一个向量空间。利用这一点，我们可以将以前只定义向量和矩阵的概念和技术扩展到所有的张量。为了做到这一点，我们可以对指标进行分组或拆分，从而分别降低或提高给定张量的秩。 ​ 考虑缩并两个任意张量的情况。如果我们把参与和不参与这个收缩的指标放在一起，这个过程就简化为矩阵乘法。 这种简化矩阵乘法正是数值张量包执行压缩的方式，允许它们利用高度优化的矩阵乘法代码包。 ​ 分组和分割的精确细节并不是唯一的，要根据基(basis)的选择所决定。一个特别的约定选择是以张量积为基，即在积空间上定义一组基，改积空间由各基的积给出。张量积基在量子信息中的规范使用允许对上面描述的分组和分裂进行隐式处理。例如$|0\\rangle \\otimes |1\\rangle \\equiv |01\\rangle$的表示忽略了精确的分组：左边的张量积可以视为$2 \\times 2$维的矩阵，右边可以看出4维的向量。量子信息中的张量积实际上常常是kroecker product，即真实的张量积和上述的分组。 ​ 更具体地说，考虑一个$n+m$阶的张量，将其开始的$n$个指标和接着的$m$个指标分组构成一个矩阵。 T_{I,J}:=T_{i_1,\\ldots,i_n;j_1,\\ldots,j_m}其中分组指标定义为 I:=i_1+d_1^{(i)}\\cdot i_2+d_1^{(i)}d_2^{(i)}\\cdot i_3+\\cdots+d_1^{(i)}\\ldots d_{n-1}^{(i)}\\cdot i_n \\\\ J:=j_1+d_1^{(j)}\\cdot j_2+d_1^{(j)}d_2^{(j)}\\cdot j_3+\\cdots+d_1^{(j)}\\ldots d_{n-1}^{(j)}\\cdot j_n$d_x^{(i)}(d_x^{(j)})$是类型$i(j)$第$x$个指标的维数。相当于将张量在两个方向上分组展开，上式为总的指标数。当这样一个分组被给出时，可以将张量视为矩阵，执行标准的矩阵操作。 ​ 一个重要的例子是奇异值分解(singular value decomposition(SVD))。 T_{I,J}=\\sum_{\\alpha}U_{I,\\alpha}S_{\\alpha,\\alpha}\\overline{V}_{J,\\alpha} T_{i_1,\\ldots,i_n;j_1,\\ldots,j_m}=\\sum_{\\alpha}U_{i_1,\\ldots,i_n,\\alpha}S_{\\alpha,\\alpha}\\overline{V}_{j_1,\\ldots,j_m,\\alpha}只要分组的选择是一致的，分组的精确方法就不会对结果产生影响。因此可以保持分组是隐式的，就如上图所示。 ​ 按上面的方法，SVD可以表示为上图，其中$U$和$V$是等容的(isometric)($U^{\\dagger}U=V^\\dagger V=1$)跨越指标划分。这种把指标分成两个不相交集合的方法称为张量的对分(bisection)。 为什么关注SVD？ …. Tensor networks​ 整合上述的操作，可以给出张量网络的一个定义。张量网络是一个图，它告诉我们如何把几个张量组合成一个复合张量。整个张量的秩是由图中不匹配的边的数目给出的。对于给定的外部指标值，由内部组成张量的值的积给出，再进行所有与缩并一致的内部指标求和。一个例子如下图所示： Bubbling​ 张量网络定义为它们的值与组成张量的缩并顺序无关，这影响了计算的复杂性和实用性。张量网络可以从一个张量开始缩并，然后一次一个张量地反复缩并。 ​ 张量引入(introduce)和缩并(constract)的顺序称为冒泡(bubbling)。当冒泡被执行时，网络被吞噬到存储的张量中，直到只剩下结果。不同的收缩途径会带来不同的计算难度，因此网络存在高效的冒泡和低效的冒泡。 上图为低效的冒泡过程，可以看到图中的跟踪张量(红点)最大可以达到$n$阶，即“梯子”的最大长度。这样张量中的元素为$n$的指数级，张量缩并所需要的内存和遍历时间也是指数级的，这在$n$很大的情况下是不可行的。而如果按下图的方式缩并，跟踪张量最多可以达到3阶，只需要固定的内存和线性的时间花销。 ​ 缩并过程中每一步的内存消耗与越过缩并区域边界的每一条腿的维数的积相对应。但是并不是所有的图都有有效的缩并顺序。例如下图的2D格结构，如果张量的数量为$n$，缩并过程中，最小的最大跨越腿数为$\\sqrt{n}$。 这里描述的冒泡每次选取一个张量，然后一个接一个地收缩其他张量，但这通常不是最有效的顺序。通常，多重冒泡方法更快。 Computational complexity​ 一些张量网络由于复杂度理论给出的原因，并不存在有效的缩并过程。可以通过一些优化冒泡算法来加速张量网络缩并的过程，但是这个问题是NP-complete的，并不存在通用的有效方法。即使忽略所使用的特定冒泡，总体缩并过程的复杂性通常也会令人望而却步。 Problem1.考虑下列的张量，每个指标的维度为3维，指标从0开始： 计算下面张量网络的值： answer: 首先，进行全局坐标的分配，给出全局坐标下各张量的表示 结果可以表示为 \\begin{align} T&=\\sum_{\\alpha,\\beta,\\gamma,\\delta,\\epsilon=0}^2 A_{\\alpha,\\beta}B_{\\alpha,\\gamma,\\delta}C_{\\delta,\\epsilon}D_{\\beta,\\gamma,\\epsilon} \\\\ &=\\sum_{\\alpha,\\beta,\\gamma,\\delta,\\epsilon=0}^2(\\beta^2-2\\alpha)(-3^\\alpha\\gamma+\\delta)\\beta\\gamma\\epsilon^2 \\\\ &=1080 \\end{align} 一共$3^5=243$项求和，还是需要计算机来计算的。 2.在这个问题中，我们将考虑展开一个缩并序列，以一种编码收缩时需要的方式。给定一个网络和一个相关的冒泡，我们希望写出一个表来跟踪缩并张量的当前对象的指标，与缩并有关的指标，以及新指标。例如网络 在按字母顺序冒泡的时候，所讨论的表是这样的 那么对于下列的网络 在按字母顺序冒泡时，给出一个对于的上述表格。 这个题目的意义是让读者熟悉张量网络构建的过程，在计算机上执行的算法是怎么样的，数据结构的大概形式如何。current是一个保存着当前的腿的集合，New是新增的要加入current的腿集合，contract则是要减少current的腿的集合。 3. 4.类似于奇异值分解，给定一个指标的对分，我们可以考虑张量的范数。 （a) 算子范数是否依赖于对分，即相同张量的任意两个对分上的算子范数是否一定相等？ ​ 根据算子范式$||M||_\\infty$的定义可以看出，其依赖于张量的对分。 （b) 那么对于Frobenius范数呢？如果不同，画出张量网络图来说明其与对分不相关。 ​ 对于矩阵$M$，Frobenius范数为$Tr(MM’)$。对于三阶张量的F范数，如图所示 ||A||_F =\\sqrt{\\sum_{i_1,\\ldots,i_r}|A_{i_1,\\ldots,i_r}|^2} 可以看到，其值与如何划分指标无关。 Thinking 张量网络缩并的最终结果有什么意义？ 缩并的跟踪张量的变化过程是否包含什么信息？ 缩并的过程是否是可逆的？ 张量网络和神经网络有什么不同之处和相同之处？","link":"/2020/02/18/Introduction-to-tensor-network-notation/"},{"title":"Honeywell","text":"Demonstration of the QCCD trapped-ion quantum computer architecture arXiv:2003.01293v1 文章展示了QCCD(quantum charge-coupled device)离子阱量子计算系统的组成结构，并分别在组成级别和整体级别对系统进行了评估。 概述系统采用$\\sideset{^{171}}{}{\\mathrm{Yb}}^+$离子来构建比特，$\\sideset{^{138}}{}{\\mathrm{Ba}}^+$离子来交互冷却，构建在Honeywell低温表面阱中，允许任意的重排和跨区域的并行门操作。采用两个并行的部分分离接触的区域来完成任意的四比特线路，作为一个小系统的展示。至于系统的评估，分别在组成级别和整体级别通过了不同的方式进行了benchmark。组成级别的benchmark就是对单比特操作和两比特操作进行randoemized benchmarking。整体测试包括平行随机基准测试，表明不同门区之间的串扰可以忽略不计，利用中间电路测量的远端CNOT门，还有就是测量系统的quantum volume。 为了解决离子阱系统的拓展性，大家在往两个方向努力，一个是拓展离子晶体的数量，一个是晶体间的量子通信。晶体间通信有分为两种方法，一个是光子链接，一个是直接物理的运输离子，这篇文章采用的就是后一种方法。 系统的优势 使用$\\sideset{^{171}}{}{\\mathrm{Yb}}^+$作为比特离子，$\\sideset{^{138}}{}{\\mathrm{Ba}}^+$作为冷却离子，在$750 \\mu m$的相邻门区域进行并行的操作和通信 通过在离子阱中加入四种离子，展示了高保真度的门操作可以并行的在两个四离子混合晶体中执行 快速的运输操作使比特可以被重新配置，减少了逻辑交换门的开销 randomized benchmarking显示系统的串扰影响很小 通过执行传输CNOT门，展示线路中的测量不会破坏线路中其它比特的状态 测量系统quantum-volume为$2^4 =16$。 在这个系统上展示了这些技术的整合，为离子阱量子计算系统的拓展铺平了道路。 系统硬件控制基本操作捕获和运输量子操作系统评估Componet benchmarkingMid-circuit measurementQuantum Volume","link":"/2020/03/06/Honeywell/"},{"title":"Linear algebra","text":"线性代数复习总结 向量空间向量空间向量空间就是带有加法和标量乘法的集合$V$，满足如下性质： 交换性。 u+v=v+u \\quad u,v \\in V 结合性。 (u+v)+w = u + (v+w),(ab)v=a(bv) 加法单位元。 v+0=v 加法逆元。 对任意v \\in V，都存在w \\in V，使得v+w=0 乘法单位元 1v=v 分配性质。 a(u+v)=au+av,(a+b)v=av+bv $R^n$为实向量空间，$C^n$为复向量空间。 子空间 如果$V$的子集$U$（采用与$V$相同的加法和标量乘法）也是向量空间，则称$U$是$V$的子空间。 子空间的条件： 加法单位元。 0 \\in U 加法封闭性。 对u,w\\in U有u+w \\in U 标量乘法封闭性。 a \\in F ,u \\in U ,有 au\\in U子空间的和：子空间的和是包含这些子空间的最小子空间。 直和：$U_1 \\oplus \\cdots \\oplus U_m$ 线性组合$V$中的一组向量$v_1,\\ldots,v_m$的线性组合是指形如 a_1v_1+\\cdots+a_mv_m的向量，其中$a_1,\\dots,a_m \\in F$ $F$表示$R$或$C$，$V$表示$F$上的向量空间 这些线性组合所构成的集合称为张成空间，张成空间是包含这组向量的最小子空间。 如果一个向量空间可以由该空间的某个向量张成，则称这个空间是有限维的，否则则是无限维的。 线性无关线性无关 $V$中一组向量$v_1,\\dots,v_m$称为线性无关，如果使得$a_1v_1+\\cdots+a_mv_m$等于$0$的$a_1,\\ldots,a_m \\in F$只有$a_1 = \\cdots = a_m =0$。 规定空组$()$是线性无关的。 基 若$V$中的一个向量组既线性无关又张成$V$,则称为$V$的基。 $V$中的向量组$v_1,\\ldots,v_n$是$V$的基当且仅当每个$v \\in V$都能唯一地写成以下形式 v=a_1v_1+\\cdots+a_nv_n, \\qquad a_1,\\dots,a_n \\in F有限维向量空间的任意基的长度称为这个向量空间的维数，记为$\\dim V$。 线性映射线性映射从$V$到$W$的线性映射为$T:V \\rightarrow W$，所有映射的集合记为$\\mathcal{L}(V,W)$。 设$v_1,\\ldots,v_n$是$V$的基，$w_1,\\ldots,w_n \\in W$，则存在唯一一个线性映射$T:V \\rightarrow W$使得对任意$j=1,\\dots,n$都有 T v_j = w_j$\\mathcal{L}(V,W)$是一个向量空间。 线性映射将$0$映射为$0$。 线性映射的乘积 若$T \\in \\mathcal{L}(U,V) $，$S \\in \\mathcal{L}(V,W)$，则定义乘积$ST \\in \\mathcal{L}(U,W)$如下： (ST)(u) = S(Tu)线性映射的乘法不是交换的。 矩阵 A = \\begin{pmatrix} A_{1,1} & \\cdots & A_{1,n} \\\\ \\vdots & & \\vdots \\\\ A_{m,1} & \\cdots & A_{m,n} \\end{pmatrix}$A_{j,k}$表示位于$A$的第$j$行第$k$列处的元素。 线性映射的矩阵 \\mathcal{M}(T,(v_1,\\ldots,v_n),(w_1,\\ldots,w_m)) \\\\ Tv_k = A_{1,k}w_1+\\cdots+A_{m,k}w_m = \\sum_{j=1}^m A_{j,k}w_j这样的写法看起来有些奇怪，好像与真实的矩阵乘法不符，其实这是对的，因为这是基变换。 举一个变换的例子 T(x,y) = (x+3y,2x+5y,7x+9y) \\mathcal{M}(T) = \\begin{pmatrix} 1 & 3 \\\\ 2 & 5 \\\\ 7 & 9 \\end{pmatrix} \\begin{pmatrix} x+y \\\\ 2x+5y \\\\ 7x+9y \\end{pmatrix} = \\begin{pmatrix} 1 & 3 \\\\ 2 & 5 \\\\ 7 & 9 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix}按照上面的定义式 \\begin{aligned} T(xv_1 +yv_2) & = x \\sum_{j=1}^3 A_{j,1}w_j+ y\\sum_{j=1}^3 A_{j,2}w_j \\\\ & = x(w_1+2w_2+7w_3)+y(3w_1+5w_2+9w_3) \\\\ & = (x+3y)w_1 + (2x+5y)w_2 + (7x+9y)w_3 \\end{aligned}矩阵的加法 (A+C)_{j,k} = A_{j,k} + C_{j,k}线性映射的和的矩阵 \\mathcal{M}(S+T) = \\mathcal{M}(S) + \\mathcal{M}(T)矩阵的标量乘法 (\\lambda A)_{j,k} = \\lambda A_{j,k}标量乘以线性映射的矩阵 \\mathcal{M}(\\lambda T) = \\lambda \\mathcal{M}(T)矩阵的维度 \\dim \\mathrm{F}^{m,n} = mn矩阵乘法 (AC)_{j,k} = \\sum_{r=1}^n A_{j,r}C_{r,k}线性映射乘积的矩阵 \\mathcal{M}(ST) = \\mathcal{M}(S)\\mathcal{M}(T)线性映射的作用类似于矩阵乘 \\mathcal{M} (Tv)=\\mathcal{M}(T)\\mathcal{M}(v)可逆性可逆 线性映射$T \\in \\mathcal{L}(V,W)$称为可逆的，如果存在线性映射$S \\in \\mathcal{L}(W,V)$使得$ST=I$（这里的$I$是$V$上的恒等映射），且$TS=I$（这里的$I$是$W$上的恒等映射），这个$S$称为$T$的逆。 逆是唯一的，可以用记号$T^{-1}$表示，$T^{-1}T=I,TT^{-1}=I$。 可逆性等价于单且满。 在有限维的情况下，单性等价于满性 同构 同构就是可逆的线性映射。 若两个向量空间之间存在一个同构，则称这两个向量空间是同构的。 $\\mathrm{F}$上两个有限维向量空间同构当且仅当其维数相同。 算子 向量空间到其自身的线性映射称为算子，$\\mathcal{L}(V)=\\mathcal{L}(V,V)$ 向量空间的积向量空间的积 V_1 \\times \\cdots \\times V_m = \\{(v_1,\\dots,v_m):v_1 \\in V_1,\\ldots,v_m \\in V_m\\}向量空间的积是向量空间。 积的维数等于维数的和 \\dim (V_1 \\times \\cdots \\times V_m) = \\dim V_1 + \\cdots + \\dim V_m对偶线性泛函 $V$上的线性泛函是$V$到$\\mathrm{F}$的线性映射，线性泛函是$\\mathcal{L}(V,\\mathrm{F})$中的元素。 对偶空间 $V$上的所有线性泛函构成的向量空间称为$V$的对偶空间，记为$V’$，$V’=\\mathcal{L}(V,\\mathrm{F})$。 \\dim V' = \\dim V对偶映射的矩阵 转置 (A^t)_{k,j} = A_{j,k}矩阵乘积的转置 (AC)^t = C^t A^t本征值、本征向量、不变子空间不变子空间不变子空间 $T \\in \\mathcal{L}(V)$。称$V$的子空间$U$在$T$下不变，如果对每个$u \\in U$都有$T u \\in U$。 本征值与本征向量本征值 设$T \\in \\mathcal{L}(V)$。称数$\\lambda \\in \\mathrm{F}$为$T$的本征值，若存在$v \\in V$使得$v \\neq 0$且$Tv=\\lambda v$。 本征向量 与本征值对应的向量$v$称为本征向量。 线性无关的本征向量 不同本征值对应的本征向量线性无关。 本征值的个数 设$V$是有限维的，则$V$上的每个算子最多有$\\dim V$个互不相同的本征值。 本征空间与对角矩阵对角矩阵是对角线以外元素全是$0$的方阵。 本征空间 $T$相应于$\\lambda$的本征空间定义为 E(\\lambda,T) = null (T-\\lambda I)也就是说，$E(\\lambda,T)$是$T$相应于$\\lambda$的全体本征向量加上$0$向量构成的集合。 可对角化的等价条件 设$V$是有限维的，$T \\in \\mathcal{L}(V)$。用$\\lambda,\\ldots,\\lambda_m$表示$T$的所有互异的本征值。则下列条件等价： $T$可对角化 $V$有由$T$的本征向量构成的基 $V$有在$T$下不变的一维子空间$U_1,\\ldots,U_n$使得$V = U_1 \\oplus \\cdots \\oplus U_n$ $V = E(\\lambda_1,T) \\oplus \\cdots \\oplus E(\\lambda_m,T)$ $\\dim V = \\dim E(\\lambda_1,T)+ \\cdots+\\dim E(\\lambda_m,T)$ 本征值足够多则可对角化 若$T \\in \\mathcal{L}(V)$有$\\dim V$个互异的本征值，则$T$可对角化。 内积空间内积点积** x \\cdot y = x_1y_1+ \\cdots +x_ny_n内积 $V$上的内积就是一个函数，它把$V$中的元素的每个有序对$(u,v)$都映成一个数$\\langle u,v \\rangle \\in \\mathrm{F}$，并且具有下列性质： 正性 \\langle v,v \\rangle \\geq 0 定性 \\langle v,v \\rangle =0 ,当且仅当v=0 加性 \\langle u+v,w \\rangle = \\langle u,w \\rangle + \\langle v,w \\rangle \\\\ \\langle u,v+w \\rangle = \\langle u,v \\rangle + \\langle u,w \\rangle 齐性 \\langle \\lambda u,v \\rangle = \\lambda \\langle u,v \\rangle \\\\ \\langle u,\\lambda v \\rangle = \\overline{\\lambda} \\langle u,v \\rangle 共轭对称性 \\langle u,v \\rangle = \\overline{\\langle v,u \\rangle} 欧几里得内积定义为 \\langle (w_1,\\dots,w_n),(z_1,\\ldots,z_n) \\rangle = w_1\\overline{z_1} + \\cdots w_n\\overline{z_n}范数 ||v|| = \\sqrt{\\langle v,v \\rangle}正交 \\langle u,v \\rangle =0规范正交基$V$上的向量组$e_1,\\ldots,e_n$是规范正交的，如果 \\langle e_j,e_k \\rangle = \\left\\{ \\begin{aligned} 1, & \\quad若j=k,\\\\ 0 ,& \\quad 若 j \\neq k \\end{aligned} \\right.规范正交组是线性无关的 将向量写成规范正交基的线性组合 v= \\langle v,e_1 \\rangle e_1 + \\cdots + \\langle v,e_n \\rangle e_n \\\\ || v ||^2 = | \\langle v,e_1 \\rangle|^2 + \\cdots + | \\langle v,e_n \\rangle |^2施密特正交化 设$v_1,\\ldots,v_m$是$V$中的线性无关向量组 设$e_1 = v_1/||v_1||$ e_j = \\frac{v_j - \\langle v_j,e_1 \\rangle e_1 - \\cdots - \\langle v_j,e_{j-1 } \\rangle e_{j-1}} {|| v_j - \\langle v_j,e_1 \\rangle e_1 - \\cdots - \\langle v_j,e_{j-1 } \\rangle e_{j-1} ||}内积空间上的算子伴随算子伴随 设$T \\in \\mathcal{L}(V,W)$。$T$的伴随是满足如下条件的函数$T^* : W \\rightarrow V$ \\langle Tv,w \\rangle = \\langle v,T^*w \\rangle伴随的性质 (S+T)^* = S^* + T^* \\\\ (\\lambda T)^* = \\overline{\\lambda}T^* \\\\ (T^*)^* = T \\\\ I^* = I (ST)^* = T^*S^*线性映射的伴随与基的选取无关。 对于矩阵相当于共轭转置。 自伴 T = T^* \\\\ \\langle Tv,w \\rangle = \\langle v,Tw \\rangle自伴算子得本征值是实的。 正规算子 内积空间上的算子称为正规的，如果它和它的伴随是交换的。 TT^* = T^*T若$T$正规，$T$与$T^*$有相同的本征向量。 正规算子对应于不同本征值的本征向量是正交的。 奇异值奇异值 设$T \\in \\mathcal{L}(V)$。则$T$的奇异值就是$\\sqrt{T^T}$的本征值，而且每个本征值$\\lambda$都要重复$\\dim E(\\lambda,\\sqrt{T^T})$次 奇异值分解 设$T \\in \\mathcal{L}(V)$有奇异值$s_1,\\ldots,s_n$。则$V$有两个规范正交基$e_1,\\ldots,e_n$和$f_1,\\ldots,f_n$，对$v \\in T$均有 Tv = s_1 \\langle v,e_1 \\rangle f_1 + \\cdots + s_n \\langle v,e_n \\rangle f_n迹与行列式迹算子的迹 $T$的迹等于$T$的按重数重复的全体本征值之和，记为$trace T$ trace T = \\lambda_1 + \\cdots \\lambda_n矩阵的迹 方阵$A$的迹为其对角线元素之和，记为$trace A$。 性质 trace(AB)=trace(BA)算子的矩阵的迹不依赖于基。 算子的迹等于其矩阵的迹。 迹是可加的 trace(S+T) = traceS + traceT行列式算子的行列式 $T$的行列式是$T$的按重数重复的全体本征值之积。 \\det T = \\lambda_1 \\cdots \\lambda_n可逆等价于行列式非零 矩阵的行列式 \\det A = \\sum_{(m_1,\\ldots,m_n) \\in perm \\ n } (sign (m_1,\\ldots,m_n))A_{m_1,1} \\cdots A_{m_n,n}行列式是可乘的 \\det (AB) = \\det (BA) = (\\det A)(\\det B)算子的矩阵的行列式不依赖于基 算子的行列式等于它的矩阵的行列式","link":"/2020/03/20/Linear-algebra/"},{"title":"Lecture Notes on Quantum Algorithms","text":"Andrew M. Childs 的量子算法教程 PreliminariesI Quantum circuits2 Efficient universality of quantum circuits3 Quantum circuit synthesis over Clifford+TII Quantum algorithms for algebraic problems4 The abelian quantum Fourier transform and phase estimation5 Discrete log and the hidden subgroup abelian groups6 The abelian HSP and decomposing abelian groups7 Quantum attacks on elliptic curve cryptography8 Quantum algorithms for number fields9 Period finding from Z to R10 Quantum query complexity of the HSP11 Fourier analysis in nonabelian groups12 Fourier sampling13 Kuperberg’s algorithm for the dihedral HSP14 The HSP in the Heisenberg group15 Approximating the Jones polynomialIII Quantum walk16 Continuous-time quantum walk17 Discrete-time quantum walk18 Unstructured search19 Quantum walk searchIV Quantum query complexity20 Query complexity and the polynomial method21 The collision problem22 The quantum adversary method23 Span programs and formula evaluation24 Learning graphsV Quantum simulation25 Simulating Hamiltonian dynamics26 Fast quantum simulation algorithmsVI Adiabatic quantum computing27 The quantum adiabatic theorem28 Adiabatic optimization29 An example of the success of adiabatic optimization30 Universality of adiabatic quantum computation","link":"/2020/03/18/Lecture-Notes-on-Quantum-Algorithms/"},{"title":"Classifying gapped phases in 1D","text":"矩阵积态在解析和数值应用中都非常有用。张量网络分析领域最有力的结果之一是在一维中对间隙相进行了完整的分类。 先介绍量子相位，然后，将讨论在缺乏对称约束的情况下，所有MPS处于同一阶段。最后，将展示对称性是如何改变这种分类的。这些材料本身就很有趣，同时也展示了TNN的分析能力。 Quantum phases经典的相位定义，特别是相变，通常与自由能密度的某些非解析性质有关 f(\\beta,v) = -\\frac{log \\ tr \\ e^{-\\beta H(v)}}{\\beta}其中$v$为模型参数(压力、质量、耦合强度等)的某个向量，$H$为系统的哈密顿量。显然当我们采取量子限制(β→∞)时，自由能就是基态能量。因此，量子相变就与基态联系起来了。 在经典相变时，相关系数变化范围较长 \\langle O_0 O_x \\rangle - \\langle O_0 \\rangle \\langle O_x \\rangle \\sim |x|^{-v}取一些热分布的平均值。因此，我们说，热(经典)相变是由热波动驱动的，其中的方差衡量了这些波动的范围越来越长。量子相变也有发散的相关长度，但是没有热平均——统计在起源上是纯量子的。 经典相位对应于$H$和$\\beta$一系列的变化，不会引起自由能$f$的非分析性。同样地，当基态能量成为某些哈密顿参数(不是温度)的函数时(在热力学极限下)，量子相变就发生了。假设我们有一个连续的一族量子哈密顿量$H(\\lambda)$。最低能级通常以下列方式之一起作用 在左边，没有相变，而在右边，当基态和第一激发态的角色交叉时发生相变。 因此，相变将与频谱中的相交点相联系。如果有连续的一族哈密顿量$H(\\lambda)$使$|\\psi_0 \\rangle$处于基态$H(0)$，且$| \\psi_1 \\rangle$处于基态$H(1)$，且对$\\lambda \\in [0,1]$存在相交点，可以说两态处于同相。 一个等价的概念是局部哈密顿下的有限时间演化。如果两种状态可以通过有限时间内的时间演化相互转换，则它们处于同相。这与一种状态自然演变成另一种状态的可能性有关。 可以演变为被深度常数的局部量子电路的等价表达。如果施加了对称性，相位会如何变换呢？如果使哈密顿量$H(\\lambda)$与一些对称群$U_g(\\lambda)$对易。在电路图中，这相当于把栅极限制在只有与这种对称交换的栅极上。 Injective MPS在这一讲中，我们将只讨论单射MPS的情况。如果我们假设MPS是左正则形式 那么单射MPS是那些单位是唯一特征值的传递矩阵的左特征向量。此外，这意味着存在一个唯一的全秩密度矩阵ρ是1右特征向量 这些MPS对应于局部哈密顿的唯一间隙基态。","link":"/2020/02/24/Classifying-gapped-phases-in-1D/"},{"title":"什么是量子体积？","text":"最近“口罩生产商”霍尼韦尔（Honeywell）发布重磅消息称已经在量子计算领域取得突破，将在未来三个月内把量子体积（Quantum Volume）为64的量子计算机推向市场，这将是全球量子体积最大的量子计算机。 此前在国际消费电子展（CES 2020）上，国际商用机器公司（IBM）也用量子体积评估了它们的28量子比特的量子计算机Raleh，量子体积达到了32。 量子两个字都够头疼了的，那量子体积又是什么东西呢？ 量子体积简单的来说，就是IBM公司提倡的一个用于全面评估量子计算机性能的通用指标。 对于量子计算机的性能，我们该关注什么？ 对于研究量子计算机的科研人员来说，评估量子计算机的性能指标会有很多： 量子比特数目 量子操作门的错误率 量子比特的相干时间 量子芯片的连通性 量子比特间的串扰如何 ………. 太多了记不住啊，而且那么多指标该怎么比较呢？ 有的公司研发超导量子计算机，就说自己的量子比特数最多，是当前最强大的量子计算机。 有的公司就不同意了，说你只是比特数多一些，比特相干时间不行，看我这个离子阱量子计算机，长相干时间，可运行时间长得多。 这就没法比较了，各量子计算机体系都有自己的优势，怎么评价哪个量子计算机比较好呢？ 部分性能相加可以代表整体性能吗？ 当一个机器的每个部件性能都很好，那么这个机器的性能就会很好吗? 这个回答在量子计算机上是否定的。 在量子计算机上可以发生这样的情况，单独测试每个量子比特的性能时都很好，但是当量子计算机整体运行时，没能达到预期的效果。 因为量子比特间会相互干扰，引入一些不期望的影响和错误，有一点组织内耗的意思。导致了量子计算机的错误率会比用部分测试得到的性能预测的差一些。 这样上面提到的部分指标也不能全面反映量子计算机的性能。 量子体积（Quantum Volume)为了解决上面的两个问题 性能指标太多，不好比较 性能指标有局域性，不能代表整体性能 IBM公司站了出来，大家别吵了，我来提个标准吧，大家都按这个标准来。 就像手机的跑分图，虽然细节指标太多了，不管大家并不用关注细节，就看个总分就可以了。 但是量子体积并不是上述指标的简单加权相加，因为有个部分相加不能反映整体的原因。 干脆就直接将量子计算机整体运行，是骡子是马直接拉出来溜溜。 计算量子体积的过程就是在量子计算机上运行随机模型线路，比较实验执行的结果与理想结果的差距，判定这样的线路是否成功执行。 量子体积同等地位的看待量子比特数量和执行时间内的可执行操作数，因此它与量子计算机可执行的最大等宽深随机模型线路相关。如果可以执行的等宽深线路深度为$n$，量子体积$V_Q = 2^n$。使用指数形式也反映了量子计算描述空间的指数级增长。 量子体积与系统的整体性能相关联，即与系统的整体错误率，潜在的比特关联，门操作并行度，甚至还与转化线路的工具链相联系，评估了系统的整体性能。 量子体积只是一个简单的数字。它不会给出系统的局部性能信息，从这一个数字也看不出系统哪里出现了问题，需要去改进，但它给出一个系统间比较的最一般的量化方式。 量子体积的增长趋势可以遇见到随着量子计算的不断发展，量子体积肯定会不断的增加。 还是IBM，仿照摩尔定律（集成电路上可容纳的晶体管数目，每隔两年便会增加一倍）提出了量子摩尔定律，量子体积每年翻番。与量子体积的概念相辅相成。 下面列举了一些IBM量子计算机的量子体积 $Tenerife$ $Tokyo$ $Johannesburg$ $Raleh$ $V_Q$ $2^2=4$ $2^3 = 8$ $2^4 = 16$ $2^5=32$ 可以看到，好像有量子摩尔定律这样的趋势。 那么这样的定律是否可以维持呢？量子计算机可以这样高速发展吗？ 我们就拭目以待吧！ 参考文献： [1]：Arute F, Arya K, Babbush R, et al. Quantum supremacy using a programmable superconducting processor[J]. Nature, 2019, 574(7779): 505-510. [2]：Pino J M, Dreiling J M, Figgatt C, et al. Demonstration of the QCCD trapped-ion quantum computer architecture[J]. arXiv preprint arXiv:2003.01293, 2020. [3]：Cross A W, Bishop L S, Sheldon S, et al. Validating quantum computers using randomized model circuits[J]. Physical Review A, 2019, 100(3): 032328.","link":"/2020/03/09/Quantum-Volume-simplication/"},{"title":"FFT with TensorNetwork","text":"一个使用TensorNetwork计算FFT的程序。 FFT的计算方法可以参考博客 十分简明易懂的F十分简明易懂的FFT(快速傅里叶变换) FFT with TensorNetwork主程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152\"\"\"Utility methods for producing interesting tensor networks.\"\"\"from typing import Listimport numpy as npimport tensornetwork as tndef add_fft( inputs: List[tn.Edge],) -&gt; List[tn.Edge]: \"\"\"Creates output node axes corresponding to the Fourier transform of inputs. Uses Cooley-Tukey's FFT algorithm. All axes are expected to have length 2. The input axes must be (and output axes will be) binary. Args: inputs: The node axes to act upon. Returns: A list of `Edges` containing the result. \"\"\" if not all(e.is_dangling() for e in inputs): raise ValueError(\"Inputs must be dangling edges.\") hadamard = np.array([[1, 1], [1, -1]], dtype=np.complex128) / np.sqrt(2) def cz(p: int) -&gt; np.ndarray: result = np.eye(4, dtype=np.complex128) result[3, 3] = np.exp(-1j * np.pi / 2**p) return result.reshape((2,) * 4) def inline_stitch(targets: List[int], tensor: np.ndarray, name: str): \"\"\"Applies an operation to the targeted axis indices.\"\"\" op_node = tn.Node(tensor, name) for k, t in enumerate(targets): incoming_state = state[t] receiving_port = op_node[k] output_port = op_node[k + len(targets)] incoming_state ^ receiving_port state[t] = output_port state = list(inputs) # Mix \"n twiddle. n = len(state) for i in range(n): for j in range(1, i + 1): inline_stitch([i - j, i], cz(j), \"TWIDDLE_{}_{}\".format(j, i)) inline_stitch([i], hadamard, \"MIX_{}\".format(i)) # FFT reverses bit order. return state[::-1] 测试程序1234567891011121314151617181920\"\"\"Tests for fft.\"\"\"import numpy as npfrom examples.fft import fftimport tensornetwork as tndef test_fft(): n = 3 initial_state = [complex(0)] * (1 &lt;&lt; n) initial_state[1] = 1j initial_state[5] = -1 initial_node = tn.Node(np.array(initial_state).reshape((2,) * n)) fft_out = fft.add_fft([initial_node[k] for k in range(n)]) result = tn.contractors.greedy(tn.reachable(fft_out[0].node1), fft_out) tn.flatten_edges(fft_out) actual = result.tensor expected = np.fft.fft(initial_state, norm=\"ortho\") np.testing.assert_allclose(expected, actual) 解析程序执行由几步构成 建立要计算的FFT序列(这一步是输入序列，与一般的程序相同)。 由序列构建一个张量网络节点，n=3，则构建的节点有三条边，节点的每条边维度为2。 对节点执行add_fft 将节点的每条边作为变量输入 inline_stitch用于将操作节点CZ，H按想要的方式连接到输入节点的边上(CZ相当与W函数，H相当于MIX，这个过程到底是怎么样的我还不是很清楚)。 两个for循环生成计算FFT的一个张量网络，这个网络到底是怎么样，我还没有画出来，要是有一个可以将网络可视化的代码包就好了。 最后将张量网络缩并，缩并的写法为什么是这样的，缩并之后为什么可以得到结果，这个我还要再思考。 总的来说，张量网络使用如何不熟悉的话还是很抽象的，应该先写出数学表达式，再画出图像，最后再写程序。我现在是一个反推的过程，通过程序来反推图像和计算的过程，就变得很难了。","link":"/2020/03/04/FFT-with-TensorNetwork/"},{"title":"Matrix product states","text":"矩阵积态(Matrix product states(MPS))是模拟实际物理系统一维量子低能态的一种很自然的选择。这节将以从两个定义MPS的方式开始，给出一些分析MPS的例子，展示这个简单网络的复杂度。介绍MPS的一些性质之后，后续将直接对网络进行操作而不再是操作量子态。 令$|\\psi\\rangle = \\sum_{j_1 j_2\\ldots j_N=0}^{d-1}C_{j_1 j_2\\ldots j_N=0} |j_1\\rangle \\otimes |j_2\\rangle \\otimes \\cdots \\otimes |j_N\\rangle$为$N$比特的量子态表示，这个量子态可以完全的由$N$阶张量$C$确定。 将第一个指标分离出来，再执行奇异值分解(SVD)，可以得到施密特分解(Schmidt decomposition) |\\psi\\rangle = \\sum_i \\lambda_i|L_i\\rangle \\otimes |R_i\\rangle其中$\\lambda_i$为施密特权值，${|L_i\\rangle}$和${|R_i \\rangle}$为正交的向量集合。 图像化表示如下 $\\lambda$是包含施密特权值的对角矩阵。 $\\alpha$-Renyi entropy为 S_\\alpha(\\rho)=\\frac{1}{1-\\alpha}\\log Tr\\rho^\\alpha其中$\\rho$是密度矩阵。 执行连续的SVD依次分割 将奇异值张量$\\lambda^{(i)}$并入局部张量$M^{(i)}$，可以得到更一般的形式 这就是矩阵积态(matrix product state)。这个结构是通用且精确的，可以添加更多的系数来讨论更复杂的形式。 考虑链上任意对分纠缠有界的量子态，假设施密特权值中只有$D$非零。因此可以使用这个性质来截断$\\lambda$矩阵，进而优化MPS的表示。特别的，任意满足strong area law，即对任意对分满足$S_0 \\leq \\log c$($c$为常数)，的量子态可以表示为仅需要$\\Omicron(dNc^2)$个系数的MPS。在许多相关状态下，冯诺依曼熵的面积定律($S_1=\\Omicron(1) $)足以保证在MPS只有$poly(N)$的结合维度的情况下也有任意的良好近似。 在TNN中，矩阵积态是一种误称，因为大多数参与的张量为3阶。未参与缩并的指标为物理(physical)指标，而另外的两个指标为虚(virtual)指标，键(bond)指标或矩阵(matrix)指标。为了方便，也为了最有效地捕获周期状态，MPS ansatz通常表示为 |\\psi[A^{(1)},A^{(2)},\\ldots,A^{(N)}]\\rangle = \\sum_{i_1,i_2,\\ldots,i_N}Tr[A_{i_1}^{(1)}A_{i_2}^{(2)}\\ldots A_{i_N}^{(N)}] |i_1 i_2 \\ldots i_N \\rangle或者在平移不变的情况下表示为 |\\psi[A]\\rangle = \\sum_{i_1,i_2,\\ldots,i_N}Tr[A_{i_1}A_{i_2}\\ldots A_{i_N}] |i_1 i_2 \\ldots i_N \\rangle注意，在这种形式中，矩阵索引被忽略，矩阵乘法是隐含的。该MPS的图形形式为 1D projected entangled pair states除了上述的结构，MPS可以视为投影纠缠对态(projected entangled pair states(PEPS))结构的特殊结构。这个过程为将纠缠对态$|\\phi \\rangle$布局在晶格上，然后对每对纠缠态施加映射$P$。 这样的结构等价于使用$|\\phi \\rangle = \\sum_{j=0}^{d-1}|dd \\rangle$构建张量网络。将线性映射$P$写为 P=\\sum_{i,\\alpha,\\beta}A_{i;\\alpha,\\beta}|i\\rangle\\langle\\alpha\\beta|.其中张量$A$实际上是上面介绍的MPS张量。纠缠对的选择保证了，作用在Bell态上的PEPS“投影”对应的张量$A$就是对应的张量$A$的缩并： \\begin{align} P^{(1)} \\otimes P^{(2)} |\\phi\\rangle_{2,3}&= \\sum_{i_1,i_2;\\alpha_1,\\beta,\\alpha_2,\\beta_2,j}A_{i_1;\\alpha_1,\\beta_1}^{(1)} A_{i_2;\\alpha_2,\\beta_2}^{(2)}|i_1i_2\\rangle \\langle \\alpha_1 \\beta_1 \\alpha_2 \\beta_2 |(1 \\otimes |jj\\rangle \\otimes 1) \\\\ &=\\sum_{i_1,i_2;\\alpha_1,\\beta_1,\\beta_2} A_{i_1;\\alpha_1,\\beta_1}^{(1)} A_{i_2;\\beta_1,\\beta_2}^{(2)}|i_1i_2\\rangle \\langle \\alpha_1 \\beta_2 | \\end{align}因此，我们看到这两种描述是等价的，通过将局部单元应用于A的虚指数，或者等价地改变PEPS中最大纠缠对都可以进行交换。 应注意到，这一般不应被视为一种实际的准备程序。一般来说，PEPS张量会将状态映射到一个非平凡的子空间，而这种物理实现需要后选择的测量。如果其中一个失败了，我们需要从头开始构建，这意味着这个过程通常是不可伸缩的。 Some MPS statesProduct state令 A_0 = \\begin{pmatrix} 1 \\end{pmatrix}, \\quad A_1 = \\begin{pmatrix} 0 \\end{pmatrix}.对于态$|00 \\ldots 0\\rangle$，表示为 A_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}, \\quad A_1 = \\begin{pmatrix} 0 & 0 \\\\ 0 & 0 \\end{pmatrix}.W state下列的矩阵对应什么态 A_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}, \\quad A_1 = \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}.选择MPS的边界条件为 有$A_0 A_0 = A_0,A_0 A_1 =A_1,A_1^2=0$和$Tr[A_1 X]=1$，所以有 |W\\rangle = \\sum_{j=1}^N |000\\ldots01_j 000\\ldots0 \\rangle这就是W态。 GHZ state如果选择$|\\phi\\rangle = |00\\rangle +|11\\rangle ,P=|0\\rangle\\langle00| +|1\\rangle\\langle 11|$，或者等价的MPS张量 A_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}, \\quad A_1 = \\begin{pmatrix} 0 & 0 \\\\ 0 & 1 \\end{pmatrix}.可以得到Greenberger-Horne-Zeilinger(GHZ)态 |GHZ\\rangle = |00\\ldots 0\\rangle + |11\\ldots 1\\rangle .AKLT state假设要构建一个$SO(3)$对称自旋单态(spin-1 state)。令$|\\phi\\rangle = |01\\rangle - |10\\rangle$为$SO(3)$的不变单重态，$P:\\mathbb{C}^{2 \\times 2} \\rightarrow \\mathbb{C}^3$为作用到自旋单态子空间上的投影算符。 P = |\\tilde 1 \\rangle \\langle 00 | + |\\tilde0 \\rangle \\frac{\\langle 01 | + \\langle 10|}{\\sqrt2} + |- \\tilde1 \\rangle \\langle 11|这样做的好处是，对应系统上的自旋算符通过$P$，意味着它与旋转交换。令$(S_x,S_y,S_z)$为自旋单粒子的自旋向量，$(X_i,Y_i,Z_i)/2$为第$i$的比特上的自旋向量，这意味着： \\begin{align} S_ZP &= (|\\tilde1\\rangle \\langle \\tilde1|-|-\\tilde1\\rangle\\langle - \\tilde1|)(|\\tilde 1 \\rangle \\langle 00 | + |\\tilde0 \\rangle \\frac{\\langle 01 | + \\langle 10|}{\\sqrt2} + |- \\tilde1 \\rangle \\langle 11|) \\\\ &=|\\tilde1\\rangle\\langle00|-|-\\tilde1\\rangle\\langle11| \\\\ &=P\\frac{Z_1+Z_2}{2} \\end{align} \\begin{align} S_XP &= \\frac{|\\tilde0 \\rangle (\\langle\\tilde1|+\\langle-\\tilde1|)+(|\\tilde1\\rangle+|-\\tilde1\\rangle)\\langle \\tilde0|}{\\sqrt2} (|\\tilde1 \\rangle \\langle00| + |\\tilde0\\rangle \\frac{\\langle01|+\\langle10|}{\\sqrt2}+|-\\tilde1\\rangle\\langle11|) \\\\ & = (\\frac{|\\tilde0 \\rangle(\\langle00|+\\langle11|)}{\\sqrt2}+\\frac{(|\\tilde1\\rangle+|-\\tilde1\\rangle)(\\langle01|+\\langle10|)}{2}) \\\\ &= P \\frac{X_1 + X_2}{2} \\end{align}对$S_Y$也有相似的结果。因此，在这个投影之后得到的状态是完全$SO(3)$对称的，但是有一个非平凡的纠缠结构(例如，如果在每个位置上的状态仅仅是一个单线态，就不会得到)。 这个态有许多有趣的性质。可以为这样的基态写出2-local Hamiltonian。令$\\Pi_2$为自旋1粒子对的自旋2s子空间上的投影。这个算符的特征值为${0,1}$。$\\Pi_2$淹没相邻的自旋1粒子，因为它们是由两个自旋1/2s和一个自旋0构成的，所以它们与自旋2的子空间没有重叠。在周期边界条件下，很容易检查出$H=\\sum \\Pi_2$的基态是唯一的。 如果研究绕自旋1的三个轴旋转的作用，可以看到 R_{\\hat n}(\\theta)P=PR_{\\hat n}(\\theta) \\otimes R_{\\hat n}(\\theta).特别的，$R_{\\hat x}(\\pi) \\rightarrow -XX , R_{\\hat y}(\\pi) \\rightarrow -YY, R_{\\hat z}(\\pi) \\rightarrow -ZZ$。后面将看到，这告诉我们AKLT状态处于非平凡对称保护拓扑(SPT)相位。 Cluster state在物理位置包含一对自旋的状态下，可以方便地写出键维度为2的MPS。令 A_{00} = \\begin{pmatrix} 1 & 0 \\\\ 1 & 0 \\end{pmatrix}, \\quad A_{01} = \\begin{pmatrix} 0 & 1 \\\\ 0 & 1 \\end{pmatrix}. \\quad A_{10} = \\begin{pmatrix} 1 & 0 \\\\ -1 & 0 \\end{pmatrix}, \\quad A_{11} = \\begin{pmatrix} 0 & -1 \\\\ 0 & 1 \\end{pmatrix}.或者等效于从虚粒子到物理自旋1/2粒子的映射 P=\\begin{pmatrix} 1 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 1\\\\ 1 & 0 & -1 & 0\\\\ 0 & -1 & 0 & 1\\\\ \\end{pmatrix}其中纠缠对处于Bell态$|\\psi\\rangle = |00\\rangle + |11\\rangle$。映射$P$对应于电路 注意到在这种情况下，PEPS张量$P$简单的对应于统一的电路。因此，这是可以将PEPS描述视为可伸缩准备过程的例外情况之一。 给出了这种状态的显式MPS描述，我们现在可以推导出它是基态的哈密顿量，从而允许我们推断出某些性质。 初始状态由纠缠对$\\Pi |\\phi \\rangle_{2j,2j+1}$构成，而且是唯一的基态对于哈密顿量 H = -\\sum_j (X_{2j}X_{2j+1} + Z_{2j}Z_{2j+1})应用这个电路(在第一个比特为奇，第二个比特为偶的Bell对间)，我们看到这个变换为 \\begin{align} H' &= -\\sum_j (Z_{2j-1}X_{2j}Z_{2j+1}+Z_{2j}X_{2j+1}Z_{2j+2}) \\\\ &= -\\sum_k Z_{k-1}X_k Z_{k+1} \\end{align}这就是聚态(cluster state)哈密顿量。这个物理模型的对称性为$\\mathbb{Z}_2 \\times \\mathbb{Z}_2$，其中$S_1 = \\Pi_j X_{2j-1}$，$S_2 = \\Pi_j X_{2j}$。把这个电路回推，可以看到它相当于将$S_1 = \\Pi_j Z_{2j} Z_{2j+1}$和$S_1 = \\Pi_j Z_{2j} Z_{2j+1}$作用于虚自旋。 这个行为告诉我们，与AKLT状态一样，聚态也具有SPT顺序。 MPS propertiesMPS构成了整个希尔伯特空间中一个极小的角落，因此我们不能指望用它们来近似任意的状态。如果物理相关的状态对应于那些可以被MPS很好地近似的状态，并且MPS表现出与这些物理状态相同的非通用属性，那么MPS就是研究这些系统的一个非常有用的工具。 Decay of correlations我们可以看到MPS只表现有限的纠缠度，接下来将研究可以表示的相关性的类型。令$O$为计算两点关联性的算子 \\langle \\psi [A]| O_0 O_{j+1} | \\psi[A] \\rangle下标表示操作符O作用的位置。这个期望值用图形表示为: $\\mathbb{E}_o$为$O$的转移矩阵。通常将$\\mathbb{E_1}$视为转移矩阵，简单的表达为$\\mathbb{E}$。 相关因子(在热力学极限下)可以写成 \\langle \\psi [A]| O_0 O_{j+1} | \\psi[A] \\rangle =Tr(\\mathbb{E}^{\\infty} \\mathbb{E}_{O_0} \\mathbb{E}^j \\mathbb{E}_{O_{j+1}} \\mathbb{E}^\\infty) \\qquad \\propto V_L^\\dagger \\mathbb{E}^j V_R其中$V_L$和$V_R$分别是$\\mathbb{E}$的左右主特征值。在计算较长距离相关器时，唯一需要做的改变是在方程中插入$\\mathbb{E}$的较高次幂。$\\mathbb{E}$的特征值可以控制相关因子的衰减。我们可以将$A$归一化，使得$E$的主特征值为1，其余的在单位圆内。因此任意相关因子要么随距离呈指数衰减，要么保持恒定。因此我们看到MPS只能捕获指数衰减相关的状态 Gauge freedom不是所以的MPS都表达不同的物理状态。保持物理状态不变的描述的转换集称为规范变换(gauge transformations)。在MPS的情况下，这些对应于虚拟层上的基变换: 其中$B_j = M A_j M^{-1}$。注意，M只需要有一个左逆，所以可以是矩形和放大键的维度。在更大的物理范围上，可以将几个MPS张量$A_{i_1},A_{i_2},\\ldots,A_{i_j}$整合为单个有效张量$B_k$。 存在一些规范的形式，其中部分为规范修正MPS描述。最常见的一种是左等距或左正则形式(与右等距或右正则类似地定义)。在这情况下MPS张量遵循 \\sum_{j=0}^{d-1}A_j^\\dagger A_j = 1_{D \\times D}, 这是最有用的开放边界系统，存在一个简单的算法来将任何MPS转换为这样的形式。它常常被用于数值应用，特别是使用变分最小化优化一个基态(DMRG)的MPS描述时，混合的左/右等距形式将被使用。 将MPS转换成这样的形式是部分规范的固定(gauge fixing)。剩下的自由度是单元在虚拟层上的自由度，而不是一般的可逆矩阵。该技术作为一种提高数值稳定性的方法，在张量网络算法中得到了广泛的应用。 Renormalising matrix product states当重整一个系统时，我们通常考虑尝试在一个更长的长度范围内(捕获原始模型的低能量部分)写出一个有效的模型。这可以通过将节点连接到一起，然后忽略自由度来实现，确保描述仍然是有用的。在MPS中，连接通过简单的将张量缩并到一起来实现。如何只忽略掉高能的自由度是一个挑战性的问题。但MPS允许我们不需要考虑这个问题。 因为只关心算符的期望值，所以可以完全在转移矩阵图中操作。把不同的位点连接在一起，简单地说就是取转移矩阵的乘积 \\tilde{\\mathbb{E}} = \\mathbb{E}\\mathbb{E}\\mathbb{E}\\mathbb{E}\\mathbb{E}\\ldots\\mathbb{E}同时中间操作$\\mathbb{E}_O$也被重整。注意到$\\tilde{\\mathbb{E} }$的维度始终保持为$D^4$，所以不需要担心忽略了一些自由度。我们也可以使用不同MPS构成的转移矩阵来得到非对角项的形式$\\langle \\psi | O | \\phi \\rangle$。 Mixed states and many body operators就像上面所描述的，MPS可被用于表示纯态。那么如何表示混合态呢？ 令$|\\psi[A] \\rangle $为纯MPS态，可以写出对应额密度矩阵为 \\rho [A] = |\\psi[A]\\rangle \\langle \\psi[A]| 因此，自旋R的某个子集上的约化密度矩阵将表示为 \\rho [A]_R = |\\psi[A]\\rangle \\langle\\psi[A]| 其中使用了左右规范形式来引入边界项。 上面的网络就是矩阵乘积算符(matrix product operators(MPOs))的一个例子。最一般的MPOs被表示如下： 除了用于表示密度矩阵，MPOs还可用于表示多体算符，包括小深度量子电路和局部哈密顿函数。 例如，transverse field Ising Hamiltonian表示为 H=-J\\sum X_jX_{j+1}-h\\sum Z_j线上的矩阵为 M=\\begin{pmatrix} 1 & 0 & 0 \\\\ X & 0 & 0 \\\\ -hZ & -JX & 1\\\\ \\end{pmatrix}终端的向量为 v_L = \\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix} ,\\quad v_R = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$N$个节点的整体哈密顿量为 H = v_L M^N v_R对于Heisenberg model H = -J_X \\sum X_jX_{j+1} - J_Y \\sum Y_j Y_{j+1} -J_Z\\sum Z_j Z_{j+1} - h \\sum Z_j可以用同样的方法得到 v_L = \\begin{pmatrix} 0 & 0 & 0 & 0 & 1 \\end{pmatrix} , \\qquad M = \\begin{pmatrix} 1 & 0 & 0 & 0 & 0 \\\\ X & 0 & 0 & 0 & 0 \\\\ Y & 0 & 0 & 0 & 0 \\\\ Z & 0 & 0 & 0 & 0 \\\\ -hZ & -J_X X & -J_Y Y & -J_Z Z & 1 \\\\ \\end{pmatrix} , \\qquad v_R = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}更一般的，MPO可以表示任何不增加Schmidt rank太多的算符。 Problem1.用张量描述MPS给出的状态 其中指标顺序在图中已经给出，指标1和指标2整合到一起。边界条件要求在结束周期性BCs之前插入泡利算符Z。 解答： A_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\quad A_1= \\begin{pmatrix} 1/2 & -1/2 \\\\ 1/2 & -1/2 \\end{pmatrix}进行规范变换，得到 B_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\quad B_1= \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}与W-state一致。 2.描述只有非零分量的MPS给出的状态 其中左右边界的状态为$|0\\rangle$。 解答： 可以看到 A_0 = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} =1, \\quad A_1= \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} = X.那么只有插入偶数个$A_1$的情况下，得到的系数才不为0 | \\psi[A] \\rangle = \\sum |even\\ number \\ of \\ 1s \\rangle 3.描述MPS给出的qudit态 其中$i,j \\in \\mathbb{Z}_d$，$\\oplus$表示模$d$运算，左边界条件为$|0 \\rangle$，右边界为$|q \\rangle$，$q \\in \\mathbb{Z}_d$。 4.设$G$为一群，描述MPO给出的操作 其中左边界为$|1\\rangle$，右边界为$|q\\rangle$，$q \\in G$，$g \\cdot h$为群乘法。 5.假设局部基被粒子数标记。下列操作符的作用是什么(键维度从左到右线性增加)? 其中左向量为$L=|0\\rangle$，右向量为$R = \\sum_{i=0}^N i|i\\rangle $。 6.写出transverse-field-cluster Hamiltonian的MPO H = -J \\sum_j Z_{j-1}X_jZ_{j+1} - h\\sum_j X_j解答： M = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ Z & 0 & 0 & 0 \\\\ 0 & X & 0 & 0 \\\\ -hX & 0 & -JZ & 1 \\\\ \\end{pmatrix} L = \\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ \\end{pmatrix} \\qquad R = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ \\end{pmatrix} ^T 7.利用MPSs和MPOs的思想，证明了对数深度量子电路可以在经典计算机上有效的模拟。","link":"/2020/02/20/Matrix-product-states/"},{"title":"Multiscale entanglement renormalisation ansatz","text":"MPS对于理解一维量子模型的低能态非常有用。但是对于某些重要的态，它却无能无力。例如，它无法重现无间隙基态的相关性。回想一下，MPS总是具有指数衰减的相关性，而无间隙基态通常支持与幂律衰减的相关性。同样地，MPS也有一个关于纠缠熵的严格的面积定律，其中无间隙状态允许对数发散。多尺度纠缠重整化ansatz(MERA)是一个旨在克服这些问题的张量网络。 尽管MPS并不自然地支持关键模型中所期望的那种相关性，但它们已成功地应用于此类系统的研究。为此目的使用MPS需要增加键维度的MPS族来检查相关性如何表现。但是MERA则不同，正如我们将要讨论的，一个单一的MERA态可以自然地捕获无间隙基态的物理特性。 在这里，我们将张量网络作为ansatz来表示，并认为它很适合表示一维中无间隙哈密顿的基态。 假设态可以被写为 我们将看到，这些张量上的约束对物理和计算都有影响。注意，$u$张量和$w$张量不一定是相同的，尽管如果我们期望平移和尺度不变的状态，通常会局限于这种情况。这类状态被称为多尺度纠缠重正化拟态(MERA)。 MERA可以直接概括为更高维度的系统。与PEPS不同的是，该网络可以在更高维度上进行有效优化，尽管其可伸缩性使数值计算非常具有挑战性。 Properties of MERALogarithmic violation of the area law一个在MERA中可以实现但是在MPS中无法实现的关键性质为纠缠熵的定标。回想一下，如果必须打破$n$个键才能将一个区域与网络的其余部分分开，可以支持的最大纠缠熵为$n\\log D$，其中$D$为键维度。在MPS中，相邻区域上的任何还原态都可以通过切断$n = 2$个键来移除。 很容易看出，从网络的其余部分删除一个包含N个物理指标的块，需要切除$O(\\log N)$个键。这显示了最大熵的尺度为$\\log N \\log D$。 Power law decay of correlations利用张量的约束，我们可以简化两点相关因子在MERA态下的计算。 注意，相关因子的长度尺度行为完全由超算符的应用决定 其中$w$张量可以被看作是一组Kraus算子 可通过对指示的指标进行分组得到。 因此，$S$为正定，unital的映射，所有的特征值$\\lambda$满足$|\\lambda| \\leq 1$。我们可以通过应用$S \\backsim log N$次将被$N$个节点分隔的操作符连接到一起。考虑S超算子的本征算子，相关因子的作用为 \\langle A_j B_k \\rangle \\backsim \\frac{\\langle A_0 B_1 \\rangle}{|j-k|^{\\Delta_A +\\Delta_B}}其中$\\Delta_{\\phi} = -\\log_3 \\lambda_{\\phi} , \\Delta_{\\phi}\\geq 0 $被称为缩放维度，$\\lambda_\\phi$为$S$对应的特征值。因此，MERA状态可以支持相关关系的代数衰减。 Efficient manipulation一个好的张量网络ansatz应该满足两个性质。首先，它应该是有效存储的。到目前为止，我们讨论的所有网络都有这个特性，因为只需要少量的系数来表示这些状态。第二个特性更微妙,即应该能够有效地提取物理数据。虽然这对一维MPS网络有效，但对二维PEPS状态无效;计算局部算子期望值所需的缩并是非常困难的。 事实证明，MERA具有这两种属性。我们可以有效地存储状态数据，并且由于公式(8.2)中的约束，我们可以有效地计算局部期望值和相关因子。我们已经看到了它是如何工作的。等距约束确保网络的物理级别上的局域操作符映射到更高级别上的局域操作符。因此，计算期望值只需要操作算子的因果锥中的少量张量。 其中阴影区域表示五个节点操作在物理层面上的因果锥。注意，每个后续级别上的张量数量不会增加。实际上，经过单层张量之后，算符就变成了三个位置的算符，而且范围永远不会增长。因此，我们可以看到MERA的各个层将局部操作符映射到局部操作符。 Renormalisation group transformation上面的大部分讨论都是关于作为Kraus算子的MERA层的解释，即在局部算子上定义一个unital CP映射。期望值的计算可以看作是许多超算子的应用，然后是较少数量节点的内积 \\langle \\psi_0 | O | \\psi_0 \\rangle = \\langle \\psi_{k+1} | A_k \\circ \\cdots \\circ A_1 \\circ A_0(O) | \\psi_{k+1} \\rangle其中$A_j$为自旋$3^{N-j}$到自旋$3^{N-j}/3$的映射。这可以被看作是一个重整化的群或规模的转变。$| \\psi_j \\rangle$由$3^{N-j}$自旋支持，只包含必要的物理数据来理解那个长度范围内的物理。如果$O$为局域算符，$A(O)$是很容易计算的。这使我们能够把有效算符理解为长度标度的函数。 热力学的或宏观的可观测的可以被看作是把形式上无限的MERA层应用于高能或微观的可观测的算符。因此，宏观物理或相结构是由映射$A$的不动点决定的。一些特别有趣的状态是尺度不变状态。如果在某一层之后所有的MERA张量都是相同的，则状态是尺度不变的。对于这些状态，我们不期望物理会改变成长度或能量的函数。这些状态的不动点可观测值特别容易理解，不同的尺度不变状态描述了不同的相位。 由于不存在由谱隙或相关长度设置的特征长度尺度，所以无间隙基态被期望为是尺度不变的。因此，MERA使我们能够非常有效地理解这些状态的长程物理。另一种实现尺度不变状态的方法是使相关长度为零——这些状态表示有间隙的相位。 Some simple MERA statesProduct state 如果我们用这些张量构建$\\log_3 N$层，我们会得到$N$个节点的态。这个网络仍然在顶部有一个自由指标，所以我们需要定义一个单指标的顶部$T$来获得最终的状态。令$T= |+\\rangle$，得到的态为$|+\\rangle^{\\otimes N}$。 GHZ state 令顶部张量为$T= |+\\rangle$，得到的态为$\\frac{|0\\rangle^{\\otimes N}+|1\\rangle^{\\otimes N}}{\\sqrt2}$。 Cluster state 其中两点一横线为CZ门。如果选择顶部张量为$T=|++\\rangle$，可以周期边界条件下的簇态。 Problem","link":"/2020/03/02/Multiscale-entanglement-renormalisation-ansatz/"},{"title":"Projected entangled pair states","text":"MPS背后的许多思想都是通过投射的纠缠对状态(PEPS)，推广到更高的维度。我们将在两个方面看到这是一个误称，不一定有一个投影仪，也不一定有一对纠缠。 我们首先回顾矩阵积状态的PEPS描述，然后将其推广到二维模型。给出几个例子之后，我们将研究的性质，与MPS的异同。 One dimensional systems: MPS一维结构的PEPS结构如下。令$|\\psi \\rangle \\in \\mathbb{C}^D \\otimes \\mathbb{C}^D$为纠缠对，$P: \\mathbb{C}^D \\otimes \\mathbb{C}^D \\rightarrow \\mathbb{C}^d$为线性映射 正如我们所看到的，在具体的描述上我们有很大的选择。我们可以通过任意(左)可逆矩阵变换纠缠对中每个自旋的局部基 | \\phi \\rangle \\rightarrow (A \\otimes B) | \\phi \\rangle因为我们可以修改P来补偿 P \\rightarrow P(B^{-1} \\otimes A^{-1})$| \\phi \\rangle$不一定是有效的量子态。为了方便，我们通常不把它正规化。 除了这个量规的自由，我们有额外描述选择。我们可以用纠缠三态作为例子 令$|\\psi \\rangle = |000\\rangle +|111\\rangle$，可以选择PEPS为 显然，这并没有提供比使用纠缠对更强的描述能力。假设我们有一些PEPS的投影放Q作用于一对纠缠态，然后我们可以把它扩展到P作用于纠缠三态 P=Q(1 \\otimes (|0\\rangle \\langle 00| + |1 \\rangle \\langle 11|))Extending to higher dimensions从一维系统到高维系统的扩展是直接进行的。我们将讨论超立方晶格的简单情况，但这个框架可以在任何图形上进行。特别地，我们将限制在2维 其中 P: (\\mathbb{C}^D)^{\\otimes 4} \\rightarrow \\mathbb{C}^d是一些从虚空间到物理空间的线性算子。 显然，在这个描述中有大量的规范自由度，就像在一维情况下一样。每一个虚自旋的任何可逆变换都可以用投影仪P的定义来补偿。 在MPS中，人们可能会问，使用不同的缠结结构是否会导致更强的描述能力。很容易看出，一般情况并非如此。假设我们选择在GHZ状态下放置plaquettes，然后在plaquettes之间使用PEPS投影。 我们可以使用一个标准的PEPS来准备这个资源状态，因此任何可以从这个“projected entangled plaquette”结构中准备的状态都可以从一个pep中准备，只需要很少的额外成本。 Some PEPS examples来看几个PEPS的例子。 Product state GHZ state RVB state令为键维度为$D=3$ $\\alpha \\in {1,2}$为唯一非零元素PEPS张量。假设我们将这些张量压平并投射悬空指标到$|2\\rangle$态。结果的物理状态是什么？ 这种状态被称为共振价键态，由晶格中所有完全倾斜的叠加和最大纠缠对组成 Kitaev’s Toric code Toric code ground state2D cluster state and the complexity of PEPS令键维度为$D=2$ 为PEPS中的非零元素。生成的物理状态是2D聚态，是基于测量的量子计算的通用资源。 如果我们能有效地求出PEPS之间的内积。然后，我们可以通过简单地将秩1投影到这些PEPS张量的物理指标上，来清楚地经典地模拟单个比特后选定的测量值。这告诉我们，即使是简单的PEPS状态，我们也无法有效地收缩，除非后选的量子计算可以经典地模拟出来(Post - BQP = BPP)。 Numerical PEPS在许多实际情况下，在有限的和无限的系统大小限制下，都可以实现PEPS网络的近似收缩。 Properties of PEPSMPS和PEPS这两种张量网络状态在性质上是不同的，无论是在物理上，还是在张量网络的计算能力上 Aside(Tensor network for classical partition function) 令$H[s] = \\sum_{\\langle i ,j \\rangle} h [s_i , s_j]$为一个经典的哈密顿量。我们经常计算的是配分函数$Z = \\sum_ e^{-\\beta H[s]}$，系统的温度为$\\beta$。我们可以用一个简单的张量网络来帮忙。 定义两个张量 在每个经典自旋上放一个D张量，在每个相互作用上放一个M张量，下面的张量网络可以用来表示配分函数 通过在网络中插入局部张量，可以计算出热期望值。例如 注意，通过结合D和M张量，配分函数可以用一个张量来描述 令 H = -J \\sum_{\\langle i,j \\rangle} s_is_j其中$s \\in { \\pm 1 }$，为经典Ising模型。张量Q可以简化为 Algebraic decay of correlationsMPS只能捕获具有指数衰减相关性的状态(当然也可以是恒定相关性)。现在我们来看看这是否适用于PEPS。我们可以通过修改上述结构来建立一个与经典配分函数相对应的PEPS状态 或者等价的整合为 定义PEPS态为 注意这是纯态，不是热态。它并没有被归一化，$\\langle \\psi | \\psi \\rangle = Z$。用这种状态计算的相关函数与用经典统计物理计算的相关函数相等。假设我们考虑一个具有热相变的经典模型(如上面的伊辛模型)。在临界温度下，该模型的相关系数会出现代数衰减，这意味着对应的PEPS也会出现代数衰减。因此，我们可以看到，与MPS不同，PEPS所描述的状态可以显示出相关的代数衰减。 Gauge freedomPEPS张量的规范自由度是MPS自由度的简单概括。和以前一样，我们可以一起阻塞张量而不改变全局状态。此外，我们可以执行以下转换(在平移不变的PEPS上)： 其中$N$和$M$为可逆矩阵。 回想一下，在MPS的情况下，我们可以利用这种自由把张量变成正则形式。这在PEPS的情况下是不可能完全实现的，尽管有一些数值方法可以将PEPS转换成近似的规范形式。 Problem1.要在顶点上有自旋的蜂窝晶格上建立GHZ状态，需要什么样的PEPS张量？ 2.通过沿着水平缩并下列张量指标可以得到什么量子操作门？","link":"/2020/02/28/Projected-entangled-pair-states/"},{"title":"SAT Problem with TensorNetwork","text":"这篇文章为使用TensorNetwork来解决SAT问题的一个示例，参考的是TensorNetwork中的SATTutorial.ipynb文档，作者为Volha Okrut。 Boolean Logic布尔逻辑，用AND(与)、OR(或)、NOT(非)，和二元值(True,False)来表示逻辑的一种数学表示方法。 下面为一组布尔逻辑表示 (True AND False) OR (NOT True AND True) 简化为 False OR False 用记号来替代会使逻辑更直观 $AND \\sim \\lor$，$OR \\sim \\land$，$NOT \\sim \\neg$。 替换后的一组表示为 $(X1 \\lor X2)\\land(\\neg X1 \\lor X3)$ 可以看到，如果将$X1$替换为True，$X2$替换为False，$X3$替换为Ture，则与最初的结果相同。替换为其它值则得到不同的结果。 SAT Problem and real-life exampleSAT问题可以大概表述为，对于一组布尔逻辑表示，对于里面的可变的二元值，有多少排列组合可以使整体的结果为真。 先来看一个具体的例子。 假设您需要去杂货店购物，需要访问三家商店:Costco、Home Depot和Walmart。好市多(Costco)早晚开门，家得宝(Home Depot)只在晚上开门，沃尔玛(Walmart)只在早上开门。你一次只能去一个地方，在一家特定的商店购物占据了你整个上午或晚上的时间。你能在一天内逛完三家店吗? 对于人类来说，答案是否定的。因为家得宝和沃尔玛只给我们提供一个时间选择(分别是晚上和早上)，所以我们必须在那个时间去那里。然而，这就没有时间去逛好市多了，所以很明显，这个“谜”没有答案。现在假设不是三家店，而是3000家(每家都有自己的时间表)，而不是两家，而是每天所有的时间?此时，这个问题对人类来说就变得棘手了。不过，幸运的是，计算机擅长的是摆弄数字和分析数千种不同的选择。 那么，我们如何以计算机可以理解的方式来编码上面的问题呢? 一个解决方案是重新编写涉及布尔变量的问题，布尔变量可以是真，也可以是假。例如，使用三个商店和两次的例子，让我们定义六个变量: Ce：晚上是否去Costco Cm：早上是否去Costco He：晚上是否去Home Depot Hm：早上是否去Home Depot We：晚上是否去Walmart Wm：早上是否去Walmart 如果变量为真(1)，就完成这个行为。接下来，我们对这些变量形成一些约束，并将它们以统一的形式表示出来，我们可以将它们输入到计算机中。 首先，在同一个时间点只能出现在一个物理地点。假设早上去了Costco(Cm=1)，那么就不能出现在Home Depot和Walmart，因此(Hm=Wm=0)。使用符号标记可以表示为： Cm \\lor \\neg Hm \\lor \\neg Wm当然，在早上不一定去Costco，还可以去Home Depot和Walmart，所有Cm不一定为1。限制应该为在早上只能去其中一个地方。 (Ce \\ \\land \\neg He \\ \\land \\neg We) \\ \\lor \\ (\\neg Ce \\ \\land He \\ \\land \\neg We) \\ \\lor \\ (\\neg Ce \\ \\land \\neg He \\ \\land We)相似的，晚上也有这样的限制 (Cm \\ \\land \\neg Hm \\ \\land \\neg Wm) \\ \\lor \\ (\\neg Cm \\ \\land Hm \\ \\land \\neg Wm) \\ \\lor \\ (\\neg Cm \\ \\land \\neg Hm \\ \\land Wm)接下来，还需要一些限制条件，例如，上午去Costco或者下去去，$Cm \\lor Ce$。上午下午都可以，但是要去了。对其它两个超市也是这样的。 (Cm \\lor Ce) \\land (Hm \\lor He) \\land (Wm \\lor We)因此，将上述限制条件相与，则可以得到总得限制条件 (Cm \\lor Ce) \\land (Hm \\lor He) \\land (Wm \\lor We) \\ \\lor \\ (Ce \\ \\land \\neg He \\ \\land \\neg We) \\ \\lor \\ (\\neg Ce \\ \\land He \\ \\land \\neg We) \\ \\lor \\ (\\neg Ce \\ \\land \\neg He \\ \\land We) \\ \\lor \\ (Cm \\ \\land \\neg Hm \\ \\land \\neg Wm) \\ \\lor \\ (\\neg Cm \\ \\land Hm \\ \\land \\neg Wm) \\ \\lor \\ (\\neg Cm \\ \\land \\neg Hm \\ \\land Wm)为了确定我们是否可以完成我们的购物之旅，我们必须为所有布尔变量找到一组真值或假值，以满足约束条件。这种类型的问题称为布尔可满足性问题，通常缩写为“SAT”。找到这些问题解决方案的程序被称为SAT求解程序。 SAT ProblemSAT问题已经从许多不同的角度被研究过，在本教程中，我们将学习如何使用张量和张量网络库来解决这个问题。 假设我们有四个变量:$X1$, $X2$, $X3$, $X4$。我们想找到所有四个$Xi$的真值，使CNF表达式为真: (\\neg X1 \\lor \\neg X3 \\lor \\neg X4) \\land (X2 \\lor X3 \\lor \\neg X4) \\land (X1 \\lor \\neg X2 \\lor X4) \\land (X1 \\lor X3 \\lor X4) \\land (\\neg X1 \\lor X2 \\lor \\neg X3)首先，我们需要定义如何编码我们想要满足的输入CNF表达式: 每个逻辑字面值都表示为正整数或负整数，其中$i$和$-i$分别对应于逻辑字面值$Xi$和$\\neg Xi$。 表达式中的每个子句表示为上面编码的元组，例如$(-1,-3,-4)$可以表示$(\\neg X1 \\lor \\neg X3 \\lor \\neg X4)$。 整个连接表达式是这样的元组列表，例如，上面的表达式将进行编码为$(-1,-3,-4),(2,3,-4),(1,-2,4),(1,3,4),(-1,2,3)$ 值得说的是，我们可以在这里解决两个问题: 求出给定SAT问题所有可能解的确切数目，如果这些解存在的话。 找出给定SAT问题的所有可能的解，如果这些解存在的话。 SAT solver using tensors and TensorNetworkFinding all possible solution to the given SAT 定义一个函数，用于解决给定的3SAT问题 12def sat_tn(clauses: List[Tuple[int, int, int]] ) -&gt; List[tn.Edge]: 计算逻辑变量的数量 123456789for clause in clauses: if 0 in clause: raise ValueError(\"0's are not allowed in the clauses.\")var_set = set()for clause in clauses: var_set |= {abs(x) for x in clause}num_vars = max(var_set)var_nodes = []var_edges = [] 准备变量节点，即Q节点 12345# Prepare the variable nodes.for _ in range(num_vars): new_node = tn.Node(np.ones(2, dtype=np.int32)) var_nodes.append(new_node) var_edges.append(new_node[0]) 为每个子句创建节点，这是创建上图的C节点 1234567# Create the nodes for each clausefor clause in clauses: a, b, c, = clause clause_tensor = np.ones((2, 2, 2), dtype=np.int32) clause_tensor[(-np.sign(a) + 1) // 2, (-np.sign(b) + 1) // 2, (-np.sign(c) + 1) // 2] = 0 clause_node = tn.Node(clause_tensor) 通过复制张量把变量和子句连接起来，将C节点各边连接到相应的Q节点上。最后，在var_edges中，我们将存储这个张量相乘的系统的所有非连通边。 123456# Connect the variable to the clause through a copy tensor.for i, var in enumerate(clause): copy_tensor_node = tn.CopyNode(3, 2) clause_node[i] ^ copy_tensor_node[0] var_edges[abs(var) - 1] ^ copy_tensor_node[1] var_edges[abs(var) - 1] = copy_tensor_node[2] 返回变量边值 1return var_edges 这样，得到得解的信息就存储在节点中，当相应指标的解存在时，相应的节点元素为1，不存在则为0。 Find the exact number of all possible solutions to the given SAT1234567891011121314151617181920def sat_count_tn( clauses: List[Tuple[int, int, int]]) -&gt; Set[tn.BaseNode]: \"\"\"Create a 3SAT Count TensorNetwork. After full contraction, the final node will be the count of all possible solutions to the given 3SAT problem. Args: clauses: A list of 3 int tuples. Each element in the tuple corresponds to a variable in the clause. If that int is negative, that variable is negated in the clause. Returns: nodes: The set of nodes \"\"\" var_edges1 = sat_tn(clauses) var_edges2 = sat_tn(clauses) for edge1, edge2 in zip(var_edges1, var_edges2): edge1 ^ edge2 return tn.reachable(var_edges1[0].node1) 对返回的变量边值自己连接到自己，返回连接了迹边的张量网络节点。 接下来，执行程序 12345678import numpy as npfrom typing import List, Tuple, Setimport tensornetwork as tnmy_clause = [(-1, -3, -4), (2, 3, -4), (1, -2, 4), (1, 3, 4), (-1, 2, -3)]nodes = sat_count_tn(my_clause)count = tn.contractors.greedy(nodes).tensorprint(\"Number of solutions = \", count) 对求迹之后的张量网络节点进行缩并，可以得到张量网络中所有的非零值，这就是解的个数。 1Number of solutions = 7.0","link":"/2020/03/03/SAT-Problem-with-TensorNetwork/"},{"title":"Tensor network algorithms","text":"张量网络在凝聚态系统的低温模拟方面取得了非凡的实际成功。一个比较容易理解的玩具模型是寻找一维旋转系统的基态。即使是在假设的局域哈密顿函数，这个看起来很窄的问题也保留了QMA -completeness，粉碎了通用模拟方法的希望，即使是在量子计算机上。虽然这乍一看似乎是一个重大的问题，但许多“物理现实”系统并没有表现出这种令人望而却步的复杂性。张量网络可以用来开发，并在一定程度上理解这种结构。 就像前面讨论的，低纠缠态可以很好的用MPS来表达。如果考虑局部间隙哈密顿量，研究表明相关基态不可能高度纠缠。这种限制性纠缠意味着这些的态允许有效的MPS近似，表明缺口(gap)的存在导致复杂性从QMA-complete一路下降到P，消除了模拟的复杂性障碍。我们注意到，尽管在将MPS应用于无gapless模型时存在复杂性理论和物理上的挑战，但也有一些成功的例子的。 更详细的是，在限制域$D$中用最小化哈密顿量$H$的Rayleigh quotient方法来近似基态$| \\Gamma \\rangle$ | \\Gamma \\rangle : = \\mathop{arg \\ min}_{| \\psi \\rangle \\in D} \\frac{\\langle \\psi | H | \\psi \\rangle}{\\langle \\psi | \\psi \\rangle}我们知道MPS很好地逼近了精确解，限制在有界键维的MPS的定义域$D$上。DMRG和TEBD是在一些MPS状态下开始，然后沿着这个区域变化移动，在移动过程中最小化能量。两种方法的区别在于执行这个变化步骤的方式，DMRG和TEBD分别采用了更多的计算的方法和物理的方法。 虽然我们在这里讨论的算法是为寻找MPS基态而设计的，但是它们可以被用来模拟时间演化，找到Gibbs states，或者优化其他操作符。 DMRG(the computer scientist’s approach)DMRG是目前该领域研究最多、最成功的算法。为了清楚起见，我们限制在有限的DMRG上，尽管确实存在热力学变量。DMRG是一个包含多个类似算法的概括性术语，在这里讨论的算法是一个简化但仍然有效的示例。由于该算法的提出要早于TNN，它的描述在历史上一直是以一种更有物理动机和技术上更复杂的方式呈现的。由于在解释上的相应转变，最初的缩略语现在与DMRG的现代张量网络解释几乎没有关联，因此为了清楚起见，我们有意省略了精确地将DMRG的扩展定义为缩略语。 用MPO表示哈密顿函数，在MPS上优化Rayleigh quotient的过程如下: 困难在于我们需要这些MPS张量的压缩;整体目标函数是高度非线性的，但它确实只是二次地依赖于每个张量。DMRG背后的关键启发是利用这些局部问题的简单性，通过迭代单变量(单张量)优化逼近多元(多张量)优化。 需要注意的是，虽然DMRG算法只计算基态，但相关的归纳可以用来模拟激发态、动力学等。 One-site对上述DMRG简图的最简单解释是DMRG1(或单点DMRG)。对于一个固定的点$i$，依次对这个点以为的MPS张量进行优化 A_i \\leftarrow \\mathop{arg \\ min}_{A_i} \\frac{\\langle \\psi(A_i) | H | \\psi(A_i) \\rangle}{\\langle \\psi (A_i) | \\psi(A_i) \\rangle}在TNN中，这样的步骤表现为 接着，定义环境张量 它对应于取封闭的张量网络，分别取$H$和$I$的期望值，然后去掉目标张量。在这样的环境下，6.4图变为 向量化这个方程会得到结果 A_i \\leftarrow \\mathop{arg \\ min}_{A_i} \\frac{\\langle A_i | H_i | A_i \\rangle}{\\langle A_i | L_i | A_i \\rangle}最后，我们可以简化这个目标函数的分母，适当地将MPS确定为标准形式。通过将站点左侧的MPS部分以左正则形式显示，将右侧的MPS部分以右正则形式显示，我们可以得到$L_i$简化为恒等式： 考虑到这种规范化，问题就简化为 A_i \\leftarrow \\mathop{arg \\ min}_{A_i} \\frac{\\langle A_i | H_i | A_i \\rangle}{\\langle A_i | A_i \\rangle}因为$H_i$是厄米的，这个优化有一个由$H_i$的最小特征向量给出的闭合解。通过沿着链来回扫描，解决这个局部特征向量问题，然后根据需要沿着规范化移动，我们完成了对算法的描述。 DMRG1的主要优点是状态保持在MPS流形内，键长不增加，这意味着算法是贪婪的。然而，这种对键的严格限制可能是一把双刃剑;这意味着在算法运行时，没有特别方便的方法来缓慢增长键的尺寸，关于键的尺寸选择的适当性，没有得到任何信息。这两个问题都通过改进来解决，尽管稍微复杂一些，导出DMRG2算法。 Two-siteDMRG2的想法是将两个节点合并在一起，在DMRG1表示中执行优化，然后将两个位置分开。这种分裂过程赋予了DMRG2其能力，允许动态控制键的维度，并提供有关修剪所导致的误差量的信息，这有助于键维度的选择。 首先进行优化 可以再次通过取一个环境张量关于两个位置的最小特征向量来求解，$H_{i,i+1}$，同样是混合正则形式。在这之后，通过执行SVD和键切将两节点张量分解: 这种裁剪的SVD有两个关键特性。首先，我们修剪的键的尺寸可以比我们最初开始时的尺寸大，这样我们就可以慢慢地扩展到更高的键尺寸MPS的空间。其次，我们可以使用截断的奇异值来量化与此投影相关的误差，使其回归到更低的键维空间，从而更好地告知我们对键维的选择。 TEBD (the physicist’s approach)时间演化合并抽取(time-evolving block decimation(TEBD))是一个张量网络算法，允许模拟一维自旋系统的动力学。通过模拟虚时间演化(imaginary-time-evolution)，还可以计算出基态等低温特征。 为了模拟虚拟时间演化，我们需要近似虚时间演化算子$U(\\tau) = \\exp(-\\tau H)$。这里的问题是，虽然我们可能有一个$H$的有效表示，但它的任何指数不一定有一个简洁的表示。以相应的虚时间演化的二体哈密顿函数为例 U(\\tau)=e^{-\\tau \\sum_i h_i} \\qquad H=\\sum_i h_i$h_i$是一个作用于自旋$i$和$i + 1$的相互作用项。同时$H$有恒定的Schmidt阶，可以有效的用MPO表示，$U(\\tau)$一般对于所有的$\\tau$都有指数的键维度。 让$H_o(H_e)$分别表示奇(偶)指标$i$的$h_i$的和。因为所有的$H_o(H_e)$中的所有项都为对易的，$e^{-\\tau H_o}(e^{-\\tau itH_e})$可以被有效的计算和表达。近似$U(\\tau)$的问题转变为当$e^{-\\tau A}$和$e^{-\\tau B}$都可计算时近似$e^{-t(A+B)}$的问题。 TEBD的核心数学工具是指数积近似。这些近似的第一阶是Suzuki-Trotter公式，它通过简单地演化每个子系统来近似总的演化: e^{-\\tau (A+B)} = e^{-\\tau A}e^{- \\tau B} +O(\\tau^2)结果是存在这样的近似的整个家族，尽管我们的目的只是为了说明Suzuki-Trotter的过程。 TEBD算法的工作原理是通过上述指数积公式近似虚时间演化算子，将其应用于给定的MPS，并调整键维以投射回MPS空间。我们对虚时间演化算符的近似是由只包含最近邻的两个位置算符的层的乘积给出的，这意味着我们只需要将这些算符压缩到我们的MPS中。假设我们想对$i$和$i + 1$处的自旋应用算子U。其思想是应用算符，把所有的量都压缩成一个张量，然后再一次使用SVD裁剪来截断键的维数。 dmrg2的优点也体现在TEBD中，即控制键尺寸的增长和对修剪误差的量化。由于上面的过程是完全局域化的，TEBD也允许大量的并行处理，这是DMRG通常不支持的。 Problem1.考虑临界横场Ising模型 H = - \\sum_{i=1}^{n-1} X_i X_{i+1} - \\sum_{i=1}^{n}Z_i对于开放边界条件，我们知道基态能量作为$n$的函数具有这种形式 E(n) = 1-csc(\\frac{\\pi}{\\alpha n + \\beta})对于一些整数$\\alpha$和$\\beta$。使用DMRG和TEBD，对几个链长度估计基态能量和计算$\\alpha$和$\\beta$。 2.已知一维间隙哈密顿函数的局部哈密顿量问题存在于P中。DMRG和TEBD是对这类系统基态进行数值计算的最常用技术。对于一个有间隙的一维哈密顿函数，证明它对于DMRG或TEBD收敛。","link":"/2020/02/25/Tensor-network-algorithms/"},{"title":"Tensor network learning framework","text":"根据张量网络学习网站tensornetwork列出的张量网络学习框架。 Fundamentals [x] Tensor Diagram Notation Types of Tensor Network [x] Matrix Product State / Tensor Train [x] Matrix Product Operator [ ] Tree Tensor Network [ ] PEPS [ ] MERA Tensor Network AlgorithmsMPS/TT and MPO AlgorithmsElementary MPS/TT Algoithms [ ] Retrieving a Single MPS/TT Component [ ] Inner Product of Two MPS/TT [ ] Compression of MPS/TT Solving Linear Equations (DMRG, etc) [x] DMRG(Density Matrix Renormalization Group) Summing MPS/TT Networks [ ] Density Matrix Algorithm [ ] Direct Algorithm Multiplying an MPS/TT by an MPO [ ] Density Matrix Algorithm [ ] Fitting Algorithm [ ] Zip-Up Algorithm Times Evolution Algorithms [x] Trotter Gate Time Evolution (TEBD) [ ] MPO Time Evolution MPS-local methods [ ] Time-Step Targeting Method (Local Krylov) [ ] Time-Dependent Variational Principle (TDVP) [ ] Krylov Time Evolution (Global Krlyov) TRG AlgorithmComputing with Tensor Networks [x] Tensor Software [ ] Software Benchmarks Applications of Tensor Networks [ ] Quantum Physics","link":"/2020/02/28/Tensor-network-learning-framework/"},{"title":"Tensor Network Contractions","text":"Tensor Network Contractions: Methods and Applications to Quantum Many-Body Systems 翻阅一下本书的目录，看看自己学了哪些内容，本书还有哪些内容值得学习，还没有细看。 这本书把张量网络各类模型和算法应用大概的描述了一遍，理清张量网络的发展历程，描绘了张量网络领域的轮廓，是不错的综述教程。 但是因为是综述，很多内容都是一笔带过，需要自己去看相应的文献。 第2章，第3章的基础内容表示我在另一个基础的教程中大概学过了。 张量网络的符号表示，introduction to tensor network notation 一些常用张量网络模型，MPS，PEPS，MERA 两个算法，DMRG和TEBD 张量网络和量子信息，tensor network and quantum information 另外之前还学习了google开源的张量网络库TensorNetwork的使用 TensorNetwork入门，TensorNetwork TensorNetwork文档学习，TensorNetwork documentation 两个使用例子，SAT Problem with TensorNetwork，FFT with TensorNetwork 但是对于张量网络的理解和使用还是有些糊涂，不够清楚。教程或者程序的例子很多都是直接画出图像，或者直接写出程序，没有相应的表达。这样缩并的过程就不是很清晰，不知道为什么这样的缩并过程就可以得到结果，这个过程还要再思考一下。 接着我可以再看看这篇综述，看看自己有哪些理解缺陷和不对的地方，更进一步的学习后面的内容，包括之前老师提到的虚时演化，和一些量子纠缠模拟的内容。 同时加强实践，不动手是不能深入理解的，不能让学习的东西都成为空中楼阁。 1 Introduction1.1 Numeric Renormalization Group in One Dimension数值重整化群（NRG）是寻找自旋系统的基态的一个方法。作者从这开始讲述张量网络的发展历史。 后面发展出了密度矩阵重整化群（DMRG），一个最有效和精确的一维模型算法。 接着张量网络以最简单的形式矩阵乘积态（MPS）引入，介绍了一些MPS可以解决的问题。 一些经常看到但还没清楚的概念，area law , ansatz 1.2 Tensor Network States in Two Dimensions引入PEPS，一个二维的张量网络模型。和树状模型MERA。 1.3 Tensor Renormalization Group and Tensor Network Algorithms因为很多张量网络不能精确的缩并，需要更有效的算法。 引入了张量重整化群（TRG）方法，还有TEBD方法。 1.4 Organization of Lecture Notes2 Tensor Network: Basic Definitions and properties2.1 Scalar, Vector, Matrix, and Tensor介绍张量和张量网络/算子的基本概念和定义，以及它们的图形表示。 2.2 Tensor Network and Tensor Network States介绍了几种常用的张量网络结构，MPS，树状结构和PEPS。 2.2.1 A Simple Example of Two Spins and Schmidt Decomposition2.2.2 Matrix Product State2.2.3 Affleck-Kennedy-Lieb-Tasaki State2.2.4 Tree Tensor Network State(TTNS) and Projected Entangled Pair State(PEPS)2.2.5 PEPS Can Represent Non-trivial Many-Body States: Examples2.2.6 Tensor Network Operators2.2.7 Tensor Network for Quantum Circuits2.3 Tensor Networks that Can Be Contracted Exactly举例说明三种可以精确缩并的特殊类型的TNs。 2.3.1 Definition of Exactly Contractible Tensor Network States2.3.2 MPS Wave-Function2.3.3 Tree Tensor Network Wave-Function2.3.4 MERA Wave-Functions2.3.5 Sequentially Generated PEPS Wave-Functions2.3.6 Exactly Contractible Tensor Networks2.4 Some Discussions讨论TN的一般形式、规范自由度以及与量子纠缠的关系。 2.4.1 General Form of Tensor Network2.4.2 Gauge Degrees of Freedom2.4.3 Tensor Network and Quantum Entanglement3 Two-Dimensional Tensor Networks and Contraction Algorithms介绍了两位的张量网络及其缩并算法。 3.1 From Physical Problems to Two-Dimensional Tensor Networks介绍了几个可以转化为2D 张量缩并的物理问题，包括经典模型的统计、TN状态的观察和一维量子模型的基态/有限温度模拟。 3.1.1 Classical Partition Functions3.1.2 Quantum Observables3.1.3 Ground-State and Finite-Temperature Simulations3.2 Tensor Renormalization GroupTRG算法。 3.3 Corner Transfer Matrix Renormalization GroupCTMRG算法。 3.4 Time-Evolving Block Decimation: Linearized Contraction and Boundary-State MethodsTEBD算法。 3.5 Transverse Contraction and Folding Trick3.6 Relations to Exactly Contractible Tensor Networks and Entanglement Renormalization4 Tensor Network Approaches for Higher-Dimensional Quantum Lattice Models重点讨论用于模拟二维量子晶格模型基态的PEPS算法。 4.1 Variational Approaches of Projected-Entangled Pair StatePEPS的变分算法。 4.2 Imaginary-Time Evolution Methods虚时演化方法。 4.3 Full, Simple, and Cluster Update Schemes根据更新张量的环境选择，解释简单的、集群的和完整的更新算法。 4.4 Summary of the Tensor Network Algorithms in Higher-Dimensions5 Tensor Network Contraction and Multi-Linear Algebra讨论张量网络于多元线性代数的潜在关系。 5.1 A Simple Example of Solving Tensor Network Contraction by Eigenvalue Decomposition一些通过特征值分解解决张量网络缩并问题的一些例子。从一个维度中MPS的规范化开始。 5.1.1 Canonicalization of Matrix Product State5.1.2 Canonical Form and Globally Optimal Truncation of MPS5.1.3 Canonicalization Algorithm and Some Related Topics5.2 Super-Orthogonalization and Tucker Decomposition高维中PEPS超正交化。 5.2.1 Super-Orthogonalization5.2.2 Super-Orthogonalization Algorithm5.2.3 Super-Orthogonalization and Dimension Reduction by Tucker Decomposition5.3 Zero-Loop Approximation on Regular Lattices and Rank-1 Decomposition正则晶格上PEPS的“零环”近似。 5.3.1 Super-Orthogonalization Works Well for Truncating the PEPS on Regular Lattice: Some Intuitive Discussions5.3.2 Rank-1 Decomposition and Algorithm5.3.3 Rank-1 Decomposition, Super-Orthogonalization, and Zero-Loop Approximation5.3.4 Error of Zero-Loop Approximation and Tree-Expansion Theory Based on Rank-Decomposition5.4 iDMRG, iTEBD, and CTMRG Revisited by Tensor Ring Decomposition由张量环分解图像表示无限DMRG（iDMRG），无限TEBD（iTEBD），无限CTMRG。 5.4.1 Revisiting iDMRG, iTEBD, and CTMRG: A Unified Description with Tensor Ring Decomposition5.4.2 Extracting the Information of Tensor Networks From Eigenvalue Equations: Two Examples6 Quantum Entanglement Simulation Inspired by Tensor NetworkQES是一种利用经典计算机或人工量子平台模拟多体模型来研究无限大多体系统的有效方法。这章就讨论张量网络启发的量子纠缠模拟。 6.1 Motivation and General Ideas6.2 Simulating One-Dimensional Quantum Lattice Models6.3 Simulating Higher-Dimensional Quantum Systems6.4 Quantum Entanglement Simulation by Tensor Network: Summary","link":"/2020/03/21/Tensor-Network-Contractions/"},{"title":"Quantum Volume","text":"概述Quantum Volume是一个用于评估近期量子计算系统($n \\lesssim 50$)性能的协议。它表示可以在系统上执行的最大等宽度深度的随机线路。量子计算系统的操作保真度越高，关联性越高，有越大的校准过的门操作集合和越多的重写工具链会有越高的QV(Quantum Volume)。QV与系统的整体性能相关联，即与系统的整体错误率，潜在的比特关联和门操作并行度相联系。总的来说，QV是一个用于近期整体评估量子计算系统的一个实用方法，QV值越高，系统整体错误率就越低，性能就越好。 为什么要使用QV？常用方法无法得到系统的整体信息 对于NISQ阶段的量子计算系统，孤立的门错误率没法预测系统的整体行为。常用的方法，例如randomized benchmarking，state and process tomography，和gateset tomography可以给出少量比特的性能(常见的单独给出单比特操作和两比特操作的性能)，但是这些方法给出的错误率是孤立的，当组成一个系统时，用这些错误率并不能估计和预测系统的整体性能和行为，因为系统中存在一些潜在的比特间的相互关联。即系统性能与很多因素，例如比特关联性和门操作并行度也有关系，而不是仅仅由门错误率决定的。也许一个系统的门错误率很低，但是整体执行时存在一定强度的串扰，或者因为比特关联性的原因，算法线路转化需要很多额外的消耗，也会导致整个系统的性能达不到预期。因此需要一个更全面的评估方法，来整体的评估系统的性能。 系统全面的量化方法 IBM提出了一个叫Quantum Volume的协议。它可以对不同的体系进行评估，只需要系统可以执行一组通用的量子门集合。QV与系统的整体性能相关联，即与系统的整体错误率，潜在的比特关联，门操作并行度，甚至还与转化线路的工具链相联系，因为它评估的是系统的整体性能。协议最后只给出一个简单的数字用于评估比较。它不会给出系统的局部性能信息，从这一个数字也看不出系统哪里出现了问题，需要去改进，但它给出一个系统间比较的最一般的量化方式。 什么是QV？QV协议简单来说就是对系统使用量子线路模型执行随机的线路操作，尽可能地将比特纠缠在一起，然后再将实验得到的结果与模拟的结果进行比较。如果实验结果与模拟结果误差在可接受的范围内，那么就判定这样的的随机线路可以执行，如果系统可执行的最大等宽度深度的量子随机线路的宽度和深度为$n$，则系统的$QV= 2^n$。 QV随机模型线路图 QV随机模型线路图如上 对深度为$d$，宽度为$m$的随机线路，可以表示为序列$U = U^{(d)} \\ldots U^{(2)} U^{(1)}$，其中每一层$U$为 U^{(t)} = U^{(t)}_{\\pi_t (m' -1),\\pi_t (m')} \\otimes \\cdots \\otimes U^{(t)}_{\\pi_t (1),\\pi_t (2)}作用在$m’ = 2 \\lfloor n/2 \\rfloor$个比特上。即先对$m$比特指标进行均匀的随机排列$\\pi_t \\in S_m$，再对每组随机排列好的比特$a,b$从$SU(4)$中随机选择操作执行$U_{a,b}^{(t)}$ 。 经过这样的一系列操作，将比特尽量随机全局的纠缠到了一起，接下来介绍如何评估随机模型线路的输出结果。什么样的输出结果代表随机模型线路是成功执行的。 模型线路的输出结果评估重输出生成问题QV协议使用了重输出(heavy output)生成问题模型来评估线路输出结果。 对于模型线路$U$，理想的输出分布为 p_U (x) = |\\langle x|U|0\\rangle|^2其中$x \\in {0,1}^m$为可观测到的比特串。考虑以升序排列$p_U (x)$的输出概率集合为$p_0 \\leq p_1 \\cdots \\leq p_{2^m -1}$。概率集合的中位数为$p_{med} = (p_{2^{(m-1)}}+p_{2^{(m-1)}-1})/2$，那么重输出为 H_U = \\{x \\in {0,1}^m 使得\\ p_U(x) > p_{med} 被满足\\}重输出生成问题，就是生成一组字符串集合，其中$2/3$的字符串满足上面的条件。对理想设备，重输出概率会渐进到$(1+\\ln2)/2 \\sim 0.85$，如果系统是完全的去极化的它将会减少到$\\sim 0.5$。即只要满足重输出条件，就代表模型线路是可以成功执行的。希望在最理想和最糟糕中取一个值，来定义相应的重输出条件，在这里定义的是$2/3$，下面会细说。 近似操作矩阵的转换的误差为了评估大量的输出，QV使用目标系统提供的门集来实现模型电路。例如，模型电路可能需要重新配置，不仅要使用系统的门集，还要考虑可用交互的集，这可能需要额外的操作，比如交换门。 对$m$比特的理想操作矩阵$U$，如果执行近似的矩阵$U’$，平均的门保真度为 F_{avg}(U,U') = \\frac{|Tr(U^{\\dagger}U')|^2/2^m+1}{2^m+1}其中需要满足$1- F_{avg}(U,U’) \\leq \\epsilon \\ll 1$。这给出了门操作转换时引入的误差。 评估输出结果下面将定义重输出条件。 重输出的采样输出概率为 h_U = \\sum_{x \\in H_U} q_U(x)为了确定输出是否是重的，采用直接从$U$计算出$H_U$的方法，这个方法的复杂度会随$m$指数增长。一个随机选择的深度$d$模型电路，观察到一个大输出的概率为$h_d = \\int_U h_U dU$。理想情况下，我们可以使用一个大型设备的所有量子比特来估计这个量，但是NISQ设备的错误率非常高，所以从小型电路模型开始，然后向大型电路模型发展。 我们感兴趣的是对于给定电路模型宽度$m \\in [n]$可实现的最大模型电路深度$d(m)$，$d(m)$定义为满足条件$h_d &gt; 2/3$的最大深度$d$，即 h_1,h_2,\\ldots,h_{d(m)} > 2/3 \\ and \\ h_{d(m)+1} \\leq 2/3问题转换为找到满足重输出条件$h_d &gt; 2/3$的最大深度$d$。 具体算法检测是否为重输出，即评估是否满足$h_d &gt; 2/3$的算法如下 \\begin{aligned} &\\mathrm{function} \\ IsHeavy(m,d;n_c >= 100,n_s)\\\\ & \\qquad n_h \\leftarrow 0 \\\\ & \\qquad \\mathrm{for} \\quad n_c \\quad 重复执行 \\\\ & \\qquad \\quad U \\leftarrow 宽度为m,深度为d的随机模型线路 \\\\ & \\qquad \\quad H_U \\leftarrow 经典模拟得到的重集合U \\\\ & \\qquad \\quad U' \\leftarrow 为特定硬件编译U得到的近似操作矩阵 \\\\ & \\qquad \\quad \\mathrm{for}\\quad n_s \\quad 重复执行 \\\\ & \\qquad \\qquad x \\leftarrow 执行U'得到的结果 \\\\ & \\qquad \\qquad 如果 x \\in H_U \\quad 则 \\quad n_h = n_h + 1 \\\\ & \\qquad \\mathrm{return} \\quad \\frac{n_h-2\\sqrt{n_h(n_s -n_h/n_c)} }{n_cn_s} >2/3 \\end{aligned}QV的定义我们需要一个单一实数的度量，因为这样可以直接进行比较。数据${d(m)}$可以遍历$m$和$d$来获取。有了${d(m)}$后，可以选择任意与${d(m)}$相关的函数来评估设备的性能。QV同等重要地对待一个模型电路的宽度和深度，即描述可以执行的最大等宽深线路。 因此QV的定义$V_Q$为 \\log_2 V_Q = \\mathop{argmax}_m \\min (m,d(m))考虑到模拟量子线路的一些复杂度问题，进一步定义$V_Q$为 V_Q = 2^{min(d,m)}QV的评估具体设备上的执行在IBM Q的四个设备上执行了QV。 5-qubit $Tenerife$ 16-qubit $Melbourne$ 20-qubit $Tokyo$ 20-qubit $Johannesburg$ 对$d=m$，取$m$为$2,3,4$，每个测试生成200个线路，来确定$V_Q$。数据如图表所示 如果$h_d &gt; 0.68$，表示结果为重输出，表示随机模型线路是可以成功执行的，那么$V_Q = 2^{\\min(d,m)}$。$\\ast$代表结果与$0.68$很接近，进行了更多次的实验，保证结果处于一定的置信区间内。 可以从上表中看出四个设备的$V_Q$分别为 Tenerife Melbourne Tokyo Johannesburg $V_Q$ $2^2=4$ - $2^3 = 8$ $2^4 = 16$ 设备$Tokyo$和$Johannesburg$具体的测试图如下: 不同编译方式的影响论文还比较了在$Tokyo$上使用不同的优化编译方式的影响 上图显示的是$m=d=4$时的$\\hat{h}_d$。近似分解采用$\\mathrm{CX}$门的错误率作为参数，表示将线路分解为$\\mathrm{SU}(4)$的基本单元时可接受的错误率。发现$\\hat{h}_d$会随着$\\mathrm{CX}$门数量的减少而略微增加。当使用$1\\%$错误率的$\\mathrm{CX}$近似时可以得到最好的结果$\\hat{h}_d = 0.649(0.005)$。 连通性的影响那么在一个连通性有限的系统中，QV是如何随着门错误率增加而变化的呢？ 文章近似的通过假定错误都是独立且随机的来模拟深度为$\\widetilde{d}(m)$的随机模型线路，所以线路体积满足下式时计算失败的概率很高： m \\hat{d} (m) \\approx \\frac{1}{\\epsilon_{eff}(m)}将两比特门的平均有效误差估计代入上式，可计算出相应的线路体积。 方格点模型的误差为$\\epsilon_{eff}(m) =(a\\sqrt m + b)\\epsilon$ 循环点模型的误差为$\\epsilon_{eff,loop}(m) = (a’m+b’)\\epsilon$ 给定了门错误率$\\epsilon$，就可以使用上述的表达式来计算相应的结构的QV。 下图为各结构达到一定QV所接受的最大门错误率。评估使用了去极化噪声模型来模拟，两比特错误率为$\\epsilon$，单比特错误率为$\\epsilon/10$，假定了良好的测量。 这是数值模拟的结果，可以看到全连接模型所容忍的门操作错误率更高一些。 上图给出了模型结果和数值模拟结果的比较。这些模拟为QV在不同的量子计算体系结构上执行的表现给出了一定参考。例如，对于离子阱体系结构，将收益于其良好的全联通性，有较高的QV。根据上表，如果其两比特门错误率和测量错误率小于$0.01$，将会有大约$\\log_2 V_Q =6$的$V_Q$，当然这是对如图所示的12比特全联通结构来说的。对于离子阱体系，因为离子间的关联，多比特的测量错误率会大于孤立测量到的两比特门错误率，因此QV为多比特系统给出了一个更可靠的评估。 同样的，连通性更高的超导系统也有更高的QV，但这是建立在增加连通性不会增加太多门错误率的前提下。 动手运行QV程序本节参考的是Qiskit教程 Qiskit Textbook—Measuring Quantum Volume qiskit.ignis中包含了quantum_volume函数，可以直接调用，执行QV程序 预备Import Qiskit 类和qv函数 1234567891011%matplotlib inline%config InlineBackend.figure_format = 'svg' # Makes the images look niceimport matplotlib.pyplot as plt#Import Qiskit classesimport qiskitfrom qiskit.providers.aer.noise import NoiseModelfrom qiskit.providers.aer.noise.errors.standard_errors import depolarizing_error, thermal_relaxation_error#Import the qv functionimport qiskit.ignis.verification.quantum_volume as qv 第一步：生成QV随机模型线路以6个比特$Q0,Q1,Q3,Q5,Q7,Q10$的执行为例 生成一系列的子序列，ntrials为为每个子序列生成的随机模型线路数量 1234# qubit_lists: list of list of qubit subsets to generate QV circuitsqubit_lists = [[0,1,3],[0,1,3,5],[0,1,3,5,7],[0,1,3,5,7,10]]# ntrials: Number of random circuits to create for each subsetntrials = 50 生成随机模型线路可以直接调用qv函数 1qv_circs, qv_circs_nomeas = qv.qv_circuits(qubit_lists, ntrials) 可以输出看看第一组序列的第一个随机模型线路是什么样的 1234#pass the first trial of the nomeas through the transpiler to illustrate the circuitqv_circs_nomeas[0] = qiskit.compiler.transpile(qv_circs_nomeas[0], basis_gates=['u1','u2','u3','cx'])print(qv_circs_nomeas[0][0]) 执行结果如下，可以看到生成了这样的一个线路图，这只是第一组线路的第一个随机线路图。因为生成的是等宽等深线路，第一组比特数量为3，线路深度也为3，这里的线路深度3指的是3组$U^{(t)}_{\\pi_t (m’ -1),\\pi_t (m’)}$。 上图已经执行了qiskit.compiler.transpile分解到具体的basis_gates上显示 未转化前线路如下图 可以看到有3个Unitary 第二步：模拟理想QV线路QV方法需要知道线路的理想输出结果，因此使用了qiskit.Aer中的模拟器来模拟 123456#The Unitary is an identity (with a global phase)backend = qiskit.Aer.get_backend('statevector_simulator')ideal_results = []for trial in range(ntrials): print('Simulating trial %d'%trial) ideal_results.append(qiskit.execute(qv_circs_nomeas[trial], backend=backend).result()) 理想输出结果存储在ideal_results(list)中 12qv_fitter = qv.QVFitter(qubit_lists=qubit_lists)qv_fitter.add_statevectors(ideal_results) 再输入到qv_fitter中计算相应的qv各项参数 第三步：计算理想重输出以trial 0为例，直接调用qv_fitter._heavy_outputs计算重输出 123for qubit_list in qubit_lists: l = len(qubit_list) print ('qv_depth_'+str(l)+'_trial_0:', qv_fitter._heavy_outputs['qv_depth_'+str(l)+'_trial_0']) 再计算理想重输出相应的概率，接近于$0.85$ 123for qubit_list in qubit_lists: l = len(qubit_list) print ('qv_depth_'+str(l)+'_trial_0:', qv_fitter._heavy_output_prob_ideal['qv_depth_'+str(l)+'_trial_0']) 第四步：定义噪声模型这部分为含噪声模拟定义噪声模型。为了模拟衰减，为CNOT和U门添加去极化噪声概率。 1234567noise_model = NoiseModel()p1Q = 0.002p2Q = 0.02noise_model.add_all_qubit_quantum_error(depolarizing_error(p1Q, 1), 'u2')noise_model.add_all_qubit_quantum_error(depolarizing_error(2*p1Q, 1), 'u3')noise_model.add_all_qubit_quantum_error(depolarizing_error(p2Q, 2), 'cx')#noise_model = None 用噪声模型计算相应的线路输出结果 1234567backend = qiskit.Aer.get_backend('qasm_simulator')basis_gates = ['u1','u2','u3','cx'] # use U,CX for nowshots = 1024exp_results = []for trial in range(ntrials): print('Running trial %d'%trial) exp_results.append(qiskit.execute(qv_circs[trial], basis_gates=basis_gates, backend=backend, noise_model=noise_model, backend_options={'max_parallel_experiments': 0}).result()) 将结果输入到qv_fitter可计算含噪声模型的重输出计数 12345qv_fitter.add_data(exp_results)for qubit_list in qubit_lists: l = len(qubit_list) #print (qv_fitter._heavy_output_counts) print ('qv_depth_'+str(l)+'_trial_0:', qv_fitter._heavy_output_counts['qv_depth_'+str(l)+'_trial_0']) 第五步：计算可运行线路的深度12345678910plt.figure(figsize=(10, 6))ax = plt.gca()# Plot the essence by calling plot_rb_dataqv_fitter.plot_qv_data(ax=ax, show_plt=False)# Add title and labelax.set_title('Quantum Volume for up to %d Qubits \\n and %d Trials'%(len(qubit_lists[-1]), ntrials), fontsize=18)plt.show() 上图分别为3，4，5，6比特的重输出结果，结果可以看到理想情况下重输出结果解决$0.85$，在噪声模型下3，4，5比特结果都大于$0.68$，代表随机线路模型是可执行的。6比特的结果显著的小于$0.68$，代表不可执行。 第六步：计算Quantum Volume我们列出每个深度的统计数据。对于每个深度，我们列出深度是否成功，以及它的置信区间。对于成功执行的深度，置信区间必须满足$&gt; 97.5 \\%$ 12345678910111213141516qv_success_list = qv_fitter.qv_success()qv_list = qv_fitter.ydataQV = 1for qidx, qubit_list in enumerate(qubit_lists): if qv_list[0][qidx]&gt;2/3: if qv_success_list[qidx][0]: print(\"Width/depth %d greater than 2/3 (%f) with confidence %f (successful). Quantum volume %d\"% (len(qubit_list),qv_list[0][qidx],qv_success_list[qidx][1],qv_fitter.quantum_volume()[qidx])) QV = qv_fitter.quantum_volume()[qidx] else: print(\"Width/depth %d greater than 2/3 (%f) with confidence %f (unsuccessful).\"% (len(qubit_list),qv_list[0][qidx],qv_success_list[qidx][1])) else: print(\"Width/depth %d less than 2/3 (unsuccessful).\"%len(qubit_list)) print (\"The Quantum Volume is:\", QV) 运行结果如下 恭喜你！成功的计算出了线路的$QV=8$。 不过这只是模拟线路的结果，要得到真实实验的数据，可以将qiskit.Aer.get_backend后端’qasm_simulator’换为真实的IBM Q设备，就可以得到IBM Q设备的QV数据了。 参考资料Qiskit Textbook—Measuring Quantum Volume Validating quantum computers using randomized model circuits, Phys. Rev. A 100, 032328 (2019)","link":"/2020/03/05/Quantum-Volume/"},{"title":"Tensor Network","text":"什么是Tensor Networks?张量网络(Tensor networks)是一种有效表达和操纵关联数据的数据结构。他们将高维数据分解为几个指标张量(index tensor)(每个指标张量只包含比较少的参数)的乘积。 张量网络最初是在量子多体理论的背景下发展起来的。它不仅帮助我们在理论上，尤其是量子纠缠方面理解波函数。而且为许多有效的数值模拟方法奠定了基础。 近年来，张量网络在量子重力和全息、纠错码、经典数据压缩、大数据分析和机器学习等研究领域得到了广泛的应用。 Tensor Networks用来干什么？张量网络是用来表示相关数据的集合的，这些数据的性质取决于所讨论的应用： 研究量子多体系统，张量网络可以编码为状态波函数的系数 研究经典多体系统，张量网络可以编码为微观状态的统计集合 大数据分析，张量网络可以表示来自不同领域的多维数据，比如信号处理、神经科学、生物度量、模式识别等 Why Tensor Networks？张量网络表示有哪些优势： 张量网络提供了大型结构数据集的压缩表示。 张量网络可以更好的描述数据集的结构特征，特别是在数据的关联性上。此外，用于表示网络的图示符号可以在视觉上清楚直观地理解这些结构。 张量网络自然地提供了数据集的分布式表示，因此许多操作可以并行的执行。 张量网络为处理大数据集合提供了一个标准的框架。一些常见的任务，比如统计信息的评估，是通过一个小的张量网络工具集合来完成的，这些张量网络工具的使用不需要任何关于底层数据集或数据代表什么的具体知识。 张量网络通常非常适合处理有噪声或丢失的数据，因为它们所基于的分解通常是健壮的。 如何学习Tensor Networks?一个关于TensorNetwork的网站，上面有详尽的关于TensorNetworks的学习流程和资料。 TensorNetwork","link":"/2020/02/18/TensorNetwork/"},{"title":"TensorFlow Quantum","text":"TensorFlow Quantum(TFQ)是一个用于快速生成量子经典混合ML模型的量子机器学习库。 可以利用这个框架进行量子算法和应用的研究。 TensorFlow Quantum专注于量子数据(quantum data)和构建量子-经典混合模型(hybrid quantum-classical models)。它在Cirq(一个Python库，用于编写、操作和优化量子电路，并在量子计算机和模拟器上运行它们)中设计的量子计算算法和逻辑，并提供与现有TensorFlow api兼容的量子计算原语，以及高性能的量子电路模拟器。 Google将TensorFlow与其量子计算语言库Cirq整合到一起形成了TensorFlow Quantum。 Quantum machine learning concepts量子机器学习(Quantum machine learning)由两个概念组成：量子数据和量子-经典混合模型。 Quantum data量子数据是在自然或人工量子系统中产生的任何数据源，可以由量子计算机生成。量子数据显示出叠加和纠缠，导致联合概率分布，可能需要指数数量的经典计算资源来表示或存储。 由NISQ处理器产生的量子数据是有噪声的，而且通常在测量之前就会发生纠缠。启发式机器学习技术可以创建模型，最大限度地从嘈杂的纠缠数据中提取有用的经典信息。TensorFlow Quantum (TFQ)库提供了用于开发模型的基本元素，这些模型可以在量子数据中分离和泛化相关性，这为改进现有的量子算法或发现新的量子算法提供了机会。 以下是可以在量子设备上生成或模拟的量子数据示例： 化学模拟(Chemical simulation)—提取有关化学结构和动力学的信息，可能应用于材料科学、计算化学、计算生物学和药物发现。 量子物态模拟(Quantum matter simulation)—模拟和设计具有多体量子效应的物质的高温超导性或其它奇异态。 量子控制(Quantum control)—混合量子经典模型可以通过变量训练来执行最优的开环或闭环控制、校准和误差降低。这包括量子器件和量子处理器的错误检测和校正策略。 量子通信网络(Quantum communication networks)—利用机器学习来区分非正交量子态，应用于结构化量子中继器、量子接收器和纯化单元的设计和构建。 量子计量(Quantum metrology)—量子增强的高精度测量，如量子传感和量子成像，本质上是在小型量子器件的探头上进行的，可以通过变分量子模型来设计或改进。 Hybrid quantum-classical models量子模型可以表示和概括具有量子力学起源的数据。由于近期的量子处理器规模还很小且是嘈杂的，量子模型不能仅仅使用量子处理器来概括量子数据。NISQ处理器必须与经典的协处理器协同工作才能有效。由于TensorFlow已经支持跨cpu、gpu和TPUs的异构计算，因此它被用作实验量子经典算法的基础平台。 量子神经网络(quantum neural network (QNN))用来描述一个参数化的量子计算模型，最好是在量子计算机上执行。这一术语常与参数量子电路(parameterized quantum circuit (PQC))互换。 Research在NISQ阶段，在量子计算机上执行Shor算法和Grover算法还不现实。 TensorFlow Quantum的目标是帮助发现NISQ阶段的算法，特别是以下方面: 使用经典的机器学习来增强NISQ算法。希望来自经典机器学习的技术可以增强我们对量子计算的理解。将经典递归神经网络用于量子神经网络的元学习中，利用递归神经网络(RNN)发现QAOA和VQE等算法的控制参数优化比简单的现成优化器更有效。机器学习优化量子控制，使用强化学习来帮助减少错误并产生更高质量的量子门。 用量子电路模拟量子数据。量子卷积神经网络展示了一种量子电路，其结构类似于卷积神经网络(CNN)，用于检测物质的不同拓扑相位。量子计算机保存数据和模型。经典的处理器只看到来自模型输出的测量样本，而从不看到数据本身。在噪声量子计算机的鲁棒纠缠重正化过程中，利用DMERA模型对量子多体系统的信息进行压缩。 TensorFlow Quantum designCirqCirq是谷歌的一个量子编程框架。它提供了在量子计算机或模拟量子计算机上创建、修改和调用量子电路的所有基本操作，如量子比特、门操作、电路和测量。TensorFlow Quantum使用这些Cirq原语将TensorFlow扩展到批量计算、模型构建和梯度计算。TensorFlow Quantum上的描述需要支持Cirq。 TensorFlow Quantum primitivesTensorFlow Quantum实现了将TensorFlow与量子计算硬件集成所需的组件。为此，TFQ引入了两种数据类型原语: 量子线路(Quantum circuit)：Cirq使用TensorFlow定义了cirq.Circuit。可以创造各种规模的线路。 泡利和(Pauli sum)：表示在Cirq中定义的泡利算子的张量积的线性组合cirq.PauliSum，可以创造不同大小的操作符。 Fundamental ops使用物理量子计算机创建具有相同功能签名的Ops。在模拟的和物理的量子计算机之间进行切换就像改变一行代码一样简单。这些操作在circuit_execution_ops.py中。 LayersTensorFlow Quantum使用tf.keras.layers.Layer向开发人员公布采样、期望和状态计算。 可以方便地为经典控制参数或读出操作创建电路层。此外，您可以创建一个高度复杂的层来支持批处理电路、批处理控制参数值和执行批处理读出操作。 Differentiatorstfq.diiferentiators提供了几种标准的梯度计算算法。 Datasetstfq.datasets包含一些量子数据集，希望更多人加入社区一起完善。 总结有了这个库会让量子机器学习的研究变得更简单一些。 可以使用在机器学习领域很成熟的TensorFlow后端进行计算，同时使用Cirq进行线路的描述。后面也许还可以像在IBM Q平台上连接真实的量子计算机进行研究。 链接TFQ主页 TFQ Github TFQ-arxiv","link":"/2020/03/11/TensorFlow-Quantum/"},{"title":"TensorNetwork--a open source library","text":"TensotNetwork是Google开源的以tensorflow为后端用来执行张量网络算法的Python库。 IntroductionTensor networks最初是被设计用来模拟量子多体物理的稀疏数据结构，但现在也被用于很多其它领域。 近年来，张量网络在机器学习中的应用取得了很大的进展。Stoudenmire和Schwab使用矩阵乘积状态(MPS)对MNIST数据集进行分类。Levine等人证明了deep convolutional algorithm circuit (ConvAC)等价于tree tensor network，并对张量网络与convolutional network architecture之间更一般的关系提供了经验支持。Liu等人在MNIST和CIFAR-10上使用二维分层树张量网络进行图像识别。 Google创建TensorNetwork库的主要目标之一就是加速这项研究。 The TensorNetwork API在本节中，将介绍TensorNetwork API的主要组成部分。API的功能被设计成紧密地模拟对张量网络的图形表示的操作。也就是说，基本对象是表示张量网络的图的节点和边，API的基本功能是允许用户定义这些对象，并在网络中将它们合并在一起。 三种常用的张量网络。彩色图形表示张量，连接它们的边表示缩并。 Basic ObjectsTensorNetworksTensorNetworks是库的主要对象。它保持跟踪自己的节点(Node)对象集，并包含用于添加额外节点、用边连接节点、缩并节点和以其他方式操作节点的方法。 Nodes节点是张量网络的基本构件之一。它们在计算中表示一个张量。每个轴都有对应的边，可以将不同的节点(甚至相同的节点)连接在一起。边的数目表示底层张量的秩。例如，没有任何边的节点是标量，只有一条边的节点是向量，等等。通过向add_node传递张量的方式，在张量网络中创建节点。 12345import tensornetworkimport tensorflow as tfnet = tensornetwork.TensorNetwork()a = net.add_node(tf.eye(2)) # Numpy arrays can also be passed.print(a.get_tensor()) #This is how you access the underlying tensor. Edges边描述了张量网络中底层张量的不同缩并。每条边都指向要缩并的张量轴。张量网络中有三种基本的边 Standard Edges：标准边和无向图中的任何边一样。它们连接两个不同的节点，并定义给定向量空间之间的点积。在numpy术语中，这条边定义了给定轴上的tensordot操作。 Trace Edges：迹边将节点连接到自身。要缩并这种类型的边，需要对由两个给定轴创建的矩阵求迹。 Dangling Edges：悬边表示尚未连接到其他悬空边的输出轴或中间轴。这些边是在向网络中添加节点时自动创建的。 Basic OperationsConnecting Dangling Edges在缩并一个边之前，它必须连接在网络中。在构造张量网络时，可以使用connect方法连接以悬空开始的边。这个方法将创建一个新的Edge对象，它指向要连接的两个节点，替换悬边。 用一个量子计算的例子来说明。在这里，有一个单比特的量子电路，我们应用了几次Hadamard运算。即将比特的悬边连接到Hadamard操作，并返回结果边: 12345678910111213def apply_hadamard(net, edage): hadamard_op = np.array([[1.0, 1.0], [1.0, -1.0]]) / np.sqrt(2.0) hadamard_node = net.add_node(hadamard_op) # Connect the \"qubit edge\" to the operator \"input edage\". net.connect(edge, hadamard_node[1]) return hadamard_node[0] #This is the \"output edge\".# Build the quantum circuit.net = tensornetwork.TensorNetwork()qubit = net.add_node(np.array([1.0, 0.0])) # A \"zero state qubit\".qubit_edge = qubit.get_edge(0) # qubit[0] is equivalent.for i in range(5): qubit_edge = apply_hadarmard(net, qubit_edge) Edge Flattening两个节点之间通常有多条边连接在一起。如果一次只缩并一条边，那么所有剩余的边都成为迹边。这通常对计算非常不利，因为新节点分配的内存将远远大于所需的内存。此外，由于迹边只对底层矩阵的对角线求和，因此在第一次缩并期间计算的所有其他值都是无用的。扁平化是一种有效的自由操作，所以每次都应该这样做。如下图所示： 在API中扁平化非常简单： 12345a = net.add_node(np.eye(2))b = net.add_node(np.eye(2))edge1 = net.connect(a[0], b[0])edge2 = net.connect(a[1], b[1])flattened_edge = net.flatten_edges([edge1, edge2]) 所有连接一对节点的边都可以通过调用flatten_edges_between来扁平化： 1flattened_edge = net.flatten_edges_between(a, b) 为了便于预先优化，可以使用flatten_all_edges来平坦化网络中的所有边。这将返回网络中所有非悬空边: 1contractible_edges = net.flatten_all_edges() Edge Contraction缩并一条边只是一个简单的调用。张量网络API足够智能，可以计算出传递的边的类型，并相应地进行正确的计算。这是一个计算两个向量的点积的例子。 123456net = tensornetwork.TensorNetwork()a = net.add_node(tf.ones(2))b = net.add_node(tf.ones(2))edge = net.connect(a[0], b[0])c = net.contract(edge)print(c.get_tensor().numpy()) #Should print 2.0 也可以通过调用contract_between来自动地将连接两个节点的所有边压平和缩并: 1c = net.contract_between(a, b) Node Outer Product两个张量的外积(也称为张量积或克罗内克积)在给定的指标分配上的值是具有相同分配的每个组成张量的值的元素乘积。外积的形式是用下标符号显式表示的 (A \\otimes B)_{i_1\\cdots i_r j_1 \\cdots j_s} = A_{i_1 \\cdots i_i}B_{j_1 \\cdots j_s}从图形上看，外部积只是由两个相邻的节点表示，并作为单个单元处理。 简单使用API就可以直接实现： 1c = net.outer_product(a, b) 这将创建一个新节点来替换网络中的旧节点。这看起来像是一个奇怪的操作，因为张量网络有效之处在于这些节点没有合并成一个高维的物体。然而，以这种方式组合两个节点通常是有用的，因为将用不同的分解方式将它们再次分开。这是下一节的主题。 Node Splitting张量网络算法的一个常见步骤是对一个张量进行奇异值分解。例如，在DMRG算法中用于计算量子系统的低能态，以及在机器学习中的MPS。 在API中，可以调用split_node或split_node_full_svd来实现。这个函数需要3个参数：node，left_edges和right_edges。参数节点是要分割的节点，left_edges是要在分割后附加到$U$节点上的边，right_edges是在分割后添加到$V^\\dagger$节点上的边。这个函数需要left_edges和right_edges都与节点连接，且不能为迹边。 分割后创建的新边将指向维度轴 new \\ dim = min(\\Pi \\ left \\ edge \\ dims ,\\Pi \\ right \\ edge \\ dims)例如，如果我们要分割一个节点的形状为(2,3,4,5,6)左边沿为前三组，维度为(2,3,4)，右边为剩下的两组。则新的左结点形状为(2,3,4,24)，右边的新节点为(24,5,6)。根据处理奇异值的方式，可以使用两种不同的方法来决定是否拆分单个节点。现在将解释这两种选择 Split Node：对于默认的split_node方法，节点被分成两个新节点。这些节点的值是酉矩阵乘以奇异值的平方根。通过去掉小的奇异值可以得到更有效的近似奇异值分解。在trun_err中返回丢弃的奇异值， 1u_s, s_vh, trun_err = net.split_node(node, left_edges, right_edges) Split Node Full SVD：通过使用split_node_full_svd，可以在单独的节点中获得奇异值。参数完全相同，只是现在返回三个节点而不是两个。 1u, s, vh, trun_err = net.split_node_full_svd(node, left_edges, right_edges)","link":"/2020/02/22/TensorNetwork-google/"},{"title":"计算物理--计算方法","text":"插值 \\widetilde f(x) \\mathop{\\longrightarrow}^{逼近} f(x)注意图像 误差的分析为数值方法的重点。但在物理中这并不是很关键的问题，因为如果使用代码包，给定误差，代码包可以智能的选定步长。 并不是阶数越高越好，Runge现象。 拉格朗日(Lagrange)插值线性插值设$x_0 \\neq x_1$，用两点式表示直线 L_1(x) = \\frac{x-x_1}{x_0-x_1}f(x_0)+\\frac{x-x_0}{x_1-x_0}f(x_1)记$l_0(x) = \\frac{x-x_1}{x_0-x_1}$，$l_1(x) = \\frac{x-x_0}{x_1-x_0}$，为插值基函数。这样的形式为拉格朗日(Lagrange)插值多项式。 误差 R(x)=f(x)-L_1(x)=\\frac{f''(\\xi)}{2!}(x-x_0)(x-x_1), \\quad \\xi \\in [x_0,x_1]二次插值 L_2(x) = \\frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}f(x_0)+\\frac{(x-x_0)(x-x_1)}{(x_1-x_0)(x_1-x_2)}f(x_1)+\\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}f(x_2) \\\\ l_i(x_j)=\\delta_{ij}=\\begin{cases} 1, & i=j \\cr 0 & i \\neq j \\end{cases}误差 R_2(x) = \\frac{f^{(3)(\\xi)}}{3!}(x-x_0)(x-x_1)(x-x_2),\\\\ \\xi \\in [\\min\\{x_0,x_1,x_2,x_3,x\\},\\max\\{x_0,x_1,x_2,x\\}]$n$次拉格朗日插值多项式 L_n(x) = \\sum^n_{i=0} l_i(x)f(x_i),\\\\ l_i(x)= \\prod_{0 \\leq j \\leq n,j \\neq i} \\frac{x-x_j}{x_i-x_j}误差 R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)(x-x_1)\\cdots(x-x_n), \\quad \\xi \\in [a,b]牛顿(Newton)插值零阶差商 f[x_0]=f(x_0)一阶差商 f[x_0,x_1]=\\frac{f(x_1)-f(x_0)}{x_1-x_0}二阶差商 f[x_0,x_1,x_3]= \\frac{f[x_1,x_2]-f[x_0,x_1]}{x_2-x_0}$k$阶差商 f[x_0,x_1,\\cdots,x_k]=\\frac{f[x_1,x_2,\\cdots,x_k]-f[x_0,x_1,\\cdots,x_{k-1}]}{x_k-x_0}性质1 f[x_0,x_1,\\cdots,x_k]=\\sum^k_{i=0} f(x_i)\\prod^k_{j \\neq i}\\frac{1}{(x_i-x_j)}性质2 f[x_0,x_1,\\cdots,x_k]=f[x_{i_0},x_{i_1},\\cdots,x_{i_k}]性质3 若$f(x)$为$m$次多项式，则$f[x_0,x_1,\\cdots,x_{k-1},x]$为$m-k$次多项式。 $n$次牛顿插值 N(x)=f[x_0]+\\sum_{k=1}^n f[x_0,x_1,\\cdots,x_k](x-x_0)(x-x_1)\\cdots(x-x_{k-1}),\\\\ R(x)=f[x,x_0,x_1,\\cdots,x_n]\\prod_{i=0}^n (x-x_i)三次样条插值数值积分$\\dot{y}=f(x)$ 牛顿-柯特斯数值积分插值型数值积分 \\int_a^b f(x)dx \\approx \\int_a^b L_n(x)dx = \\int_a^b \\sum_{i=0}^n l_i(x)f(x_i)dx = \\sum_{i=0}^n [\\int_a^b l_i(x)dx]f(x_i)记$\\alpha_i = \\int_a^b l_i(x)dx$，有 I_n(f)=\\int_a^bL_n(x)dx=\\sum_{i=0}^n \\alpha_i f(x_i)Newton-Cotes积分对积分区间$[a,b]$进行$n$等分，记步长为$h=(b-a)/n$，取等分点${x_i = a+ih,i=0,1,\\cdots,n}$为数值积分节点，构造Langrange插值多项式$L_n(x)$，称为Newton-Cotes积分。 积分系数和积分节点及积分区间无关系，系数固定易于计算。 梯形积分 \\int_a^b L_1(x)dx = \\int_a^b (l_0(x)f(x_0)+l_1(x)f(x_1))dx\\\\ \\alpha_0 = \\int_a^b l_0(x)dx = \\int_a^b \\frac{x-b}{a-b}dx =\\frac{1}{2}(b-a)=(b-a)C_0^{(1)}\\\\ \\alpha_1 = \\int_a^b l_1(x)dx = \\int_a^b \\frac{x-a}{b-a}dx =\\frac{1}{2}(b-a)=(b-a)C_1^{(1)}辛普森(Simpson)积分对区间$[a,b]$作二等分，记$x_0=a,x_1=(a+b)/2,x_2=b$ \\int_a^b f(x) \\approx \\int_a^b L_2(x)dx =\\int_a^b(l_0(x)f(x_0)+l_1(x)f(x_1)+l_2(x)f(x_2))dx\\\\ \\alpha_0 = \\int_a^b l_0(x)dx = \\int_a^b \\frac{(x-\\frac{a+b}{2})(x-b)}{(a-\\frac{a+b}{2})(a-b)}dx = \\frac{1}{6} (b-a) =(b-a)c_0^{(2)}\\\\ \\alpha_1 = \\int_a^b l_1(x)dx = \\frac{4}{6}(b-a) = (b-a)c_1^(2)\\\\ \\alpha_2 = \\int_a^b l_2(x)dx = \\frac{1}{6}(b-a) = (b-a)c_2^(2)化简为 \\int_a^b f(x)dx \\approx I_2(f) = S(f) = \\frac{b-a}{6} [f(a)+4f(\\frac{a+b}{2})+f(b)]Newton-Cotes积分系数对积分区间$[a,b]$进行$n$等分，记步长为$h=(b-a)/n$，取等分点${x_i = a+ih,i=0,1,\\cdots,n}$为数值积分节点 \\int_a^b L_n(x)dx = \\sum_{i=0}^{n} \\alpha_i f(x_i)令$x=a+th,x_i=a+ih$ \\alpha_i = (b-a)c_i^{(n)}\\\\ c_i^{(n)} =\\frac{(-1)^{n-i}}{i!(n-i)!n} \\int_0^n t(t-1)\\cdots(t-i+1)(t-i-1)\\cdots(t-n)dt 复化数值积分复化梯形积分对积分区间$[a,b]$进行$n$等分，记步长为$h=(b-a)/n$，取等分点${x_i = a+ih,i=0,1,\\cdots,n}$ I(f)=\\int_a^b f(x)dx =\\sum_{i=0}^{n-1} \\int_{x_i}^{x_{i+1}}f(x)dx T(h)=T_n(f)=h[\\frac{1}{2}f(a)+\\sum_{i=1}^{n-1}f(a+ih)+\\frac{1}{2}f(b)]复化Simpson积分把积分区间分成偶数$2m$等分，记$n=2m$，$h=(b-a)/n$，${x_i = a+ih,i=0,1,\\cdots,n}$ I(f)=\\int_a^b f(x)dx = \\sum_{i=0}^{m-1}\\int_{x_{2i}}^{x_{2i+2}} f(x)dx S_n(f)=\\frac{h}{3}[f(a)+4\\sum_{i=0}^{m-1}f(x_{2i+1})+2\\sum_{i=1}^{m-1}f(x_{2i})+f(b)]常微分方程 \\left\\{ \\begin{aligned} y'(x) & = f(x,y), \\\\ y(a) & = y_0, \\end{aligned} \\right. \\quad a \\leq x \\leq b欧拉(Euler)公式基于数值微商的Euler公式向前Euler公式： y_{n+1}=y_n + hf(x_n,y_n)向后Euler公式 y_{n+1}=y_n+hf(x_{n+1},y_{n+1})从算法结构上，显式公式比隐式公式简单；从方法稳定性和精度上看，隐式公式优于显式公式。 可以使用最简单的皮卡(Picard)迭代格式求解向后Euler公式： \\left\\{ \\begin{aligned} y_{n+1}^{(0)} & = y_n + hf(x_n,y_n), \\\\ y_{n+1}^{(k+1)} & = y_n+ hf(x_{n+1},y_{n+1}^{(k)}) , \\end{aligned} \\right. \\quad k=0,1,2,\\cdots一般先用显示公式算出初始值，再用隐式公式进一步迭代，采用预估-校正公式： \\left\\{ \\begin{aligned} \\bar{y}_{n+1} & = y_n + hf(x_n,y_n), \\\\ y_{n+1} & = y_n+ hf(x_{n+1},\\bar{y}_{n+1}) , \\end{aligned} \\right.基于数值积分的近似公式梯形公式 y_{n+1} = y_n + \\frac{h}{2}(f(x_n,y_n)+f(x_{n+1},y_{n+1}))用显式Euler公式和隐式的梯形公式组成的预估-校正公式： \\left\\{ \\begin{aligned} \\bar{y}_{n+1} & = y_n + hf(x_n,y_n), \\\\ y_{n+1} &= y_n + \\frac{h}{2}(f(x_n,y_n)+f(x_{n+1},\\bar{y}_{n+1})) , \\end{aligned} \\right.合并为 y_{n+1} = y_n + \\frac{h}{2}(f(x_n,y_n)+f(x_{n+1},y_n + hf(x_n,y_n)))Runge-Kutta方法二阶Runge-Kutta公： \\left\\{ \\begin{aligned} y_{n+1} & = y_n + \\frac{h}{2}(k_1+k_2) \\\\ k_1 & = f(x_n,y_n) \\\\ k_2 & = f(x_n+h,y_n+hk_1) \\end{aligned} \\right.四阶Runge-Kutta公式： \\left\\{ \\begin{aligned} y_{n+1} & = y_n + \\frac{h}{6}(k_1+2k_2+2k_3+k_4) \\\\ k_1 & = f(x_n,y_n) \\\\ k_2 & = f(x_n+\\frac{1}{2}h ,y_n+\\frac{1}{2}hk_1) \\\\ k_3 & = f(x_n+\\frac{1}{2}h ,y_n+\\frac{1}{2}hk_2) \\\\ k_4 & = f(x_n+h,y_n+hk_3) \\end{aligned} \\right.学会使用软件包rk45 非线性方程求解迭代法实根的对分法，一种简单直观的方法。 不动点迭代 给定方程$f(x)=0$，将它转化为等价形式$x = \\varphi(x)$。给定初值$x_0$，构造迭代序列$x_{k+1}=\\varphi(x_k)$，$k=1,2,\\cdots$；如果$\\varphi(x)$连续且迭代收敛 \\lim_{k \\rightarrow \\infty} x_{k+1} = \\lim_{k \\rightarrow \\infty} \\varphi(x_k) = \\alpha则有$\\alpha = \\varphi(\\alpha)$，$\\alpha$就是方程$f(x)=0$的根。 Newton迭代法 x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)} , \\quad k=1,2,\\cdots弦截法 x_{k+1} = x_k - \\frac{f(x_k)(x_k - x_{k-1})}{f(x_k)-f(x_{k-1})},\\quad k=1,2,\\cdots求解非线性方程组的Newton方法 \\left\\{ \\begin{aligned} f_1 (x_1,x_2,&\\cdots,x_n) = 0 \\\\ f_2 (x_1,x_2,&\\cdots,x_n) = 0 \\\\ &\\vdots \\\\ f_n (x_1,x_2,&\\cdots,x_n) = 0 \\\\ \\end{aligned} \\right.记$X=(x_1,x_2,\\cdots,x_n)^T$，$F(x)=(f_1(x),f_2(x),\\cdots,f_n(x))^T$ 用Newton迭代法求方程组$F(x)=0$的迭代公式为 X^{(k+1)}=X^{(k)}-J^{-1}(X^{(k)})F(X^{(k)})其中 J(X)= \\begin{pmatrix} \\frac{\\partial f_1(X)}{\\partial x_1} & \\frac{\\partial f_1(X)}{\\partial x_2} & \\cdots & \\frac{\\partial f_1(X)}{\\partial x_n}\\\\ \\frac{\\partial f_2(X)}{\\partial x_1} & \\frac{\\partial f_2(X)}{\\partial x_2} & \\cdots &\\frac{\\partial f_2(X)}{\\partial x_n} \\\\ \\vdots & \\vdots & & \\vdots \\\\ \\frac{\\partial f_n(X)}{\\partial x_1} & \\frac{\\partial f_n(X)}{\\partial x_2} & \\cdots & \\frac{\\partial f_n(X)}{\\partial x_n} \\\\ \\end{pmatrix}迭代计算公式 J(X^{(k)})\\Delta X^{(k)} = -F(X^{(k)}) \\\\ X^{(k+1)} = X^{(k)} + \\Delta X^{(k)}一直做到$||\\Delta x^{(k)}||_{\\infty}$小于给定精度为止 在$X$的邻域中若$\\rho(X)&lt;1$或$||J(X)||_\\infty &lt;1$，而初始值充分接近于解，则迭代收敛。 Conjugate gradient方法 \\left\\{ \\begin{aligned} x_{n+1} & =x_n+ \\lambda_n x_n , \\\\ \\lambda_{n+1} & = \\lambda_n + \\beta_nx_n , \\end{aligned} \\right.作业1.求$AX^2+BX+C=0$的根，其中$A,B,C$都是可逆矩阵，自己给定(用随机数生成，$3 \\times 3$或$5 \\times 5$)，$X$为$N \\times N$的矩阵，求根$X$，收敛性如何。 2.Lorenz Attractor \\left\\{ \\begin{aligned} \\dot{x} &= \\sigma(y-x) , \\\\ \\dot{y} &= \\rho x -y -xz , \\\\ \\dot{z} &= xy - \\beta z, \\end{aligned} \\right. 取合适的$\\sigma,\\rho,\\beta$，画出运动轨迹 $dx/dt=0,dy/dt=0,dz/dt=0$，求$x^,y^,z^*$ Euler算法迭代求运动轨迹 \\left\\{ \\begin{aligned} x &= x^* + \\widetilde{x} , \\\\ y &= y^* + \\widetilde{y} , \\\\ z &= z^* + \\widetilde{z} , \\end{aligned} \\right. \\Longrightarrow \\dot{\\vec r}=A \\vec{r},\\vec{r}=(x,y,z)求A的本征值及其稳定性 $x^,y^,z^*$若非正中心，稳定性如何？ 3.找一本经典力学和线性代数的书，总结主要结果。","link":"/2020/03/10/computational-physics-2/"},{"title":"TensorNetwork documentation","text":"这是阅读TensorNetwork documentation的一些简单记录，因为原文档的类操作没有目录。这里用目录的形式记录方便查询，详细的内容要看原文档。 TensorNetwork注意，对节点的操作都是生成新节点，而不是在原节点上操作。 tensornetwork.conj共轭 tensornetwork.copy复制 tensornetwork.transpose转置 tensornetwork.reachable计算从节点或边缘可到达的所有节点 tensornetwork.remove_node从网络中删除一个节点 tensornetwork.splittensornetwork.split_node奇异值分解 tensornetwork.split_node_qrQR分解 tensornetwork.split_node_rqRQ分解 tensornetwork.split_node_full_svd全奇异值分解 tensornetwork.checktensornetwork.check_connected检查节点列表中的所有节点是否都连接了 tensornetwork.check_correct检查节点定义的网络是否满足必要的一致性关系 tensornetwork.gettensornetwork.get_all_nodes返回连接到边的节点集 tensornetwork.get_all_edges返回所有节点的边集 tensornetwork.get_all_nondangling返回所有非悬空边的集合 tensornetwork.get_all_dangling返回所有悬空边的集合 tensornetwork.get_parallel_edges得到所有与给定边平行的边 tensornetwork.get_shared_edges获取两个节点之间共享的所有边 tensornetwork.contracttensornetwork.contract_trace_edges缩并节点的所有迹边 tensornetwork.contract缩并连接两个节点的边 tensornetwork.contract_copy_node在给定的复制节点上缩并所有的边 tensornetwork.contract_between缩并两个给定节点之间的所有边 tensornetwork.contract_parallel缩并所有与这条边平行的边。 tensornetwork.outertensornetwork.outer_product计算两个节点的外积 tensornetwork.outer_product_final_nodes得到节点集的外积 tensornetwork.flattentensornetwork.flatten_edges把边压扁成单边 tensornetwork.flatten_all_edges将所有属于节点的边压平 tensornetwork.flatten_edges_between将给定两个节点之间的所有边压平 Contractorstensornetwork.contractors.greedy贪心缩并 tensornetwork.contractors.branch分支缩并 tensornetwork.contractors.optimal最优缩并 tensornetwork.contractors.auto根据网络大小自动选择上述算法之一 tensornetwork.contractors.custom使用用户创建的自定义路径优化器来计算缩并路径 NodesTensorNetwork的操作都是对边进行的，以下为节点类 class tensornetwork.Node class tensornetwork.CopyNodecompute_contracted_tensor calss tensornetwork.BaseNode节点的基类，可以从它派生出子类 add_axis_names向节点添加轴名称 add_edge向节点的给定轴上添加一条边 get_all_dangling返回连接到此节点的悬空边集 get_all_nondangling返回连接到此节点的非悬挂边集 get_axis_number获取给定轴名或值的轴号 get_dimension得到给定轴上的维数 get_rank返回张量的秩 reorder_axes重新排列节点张量的轴 reoder_edges对给定节点的边重新排序 set_signature设置节点的签名 Edgesclass tensornetwork.Edgedisconnect断开链接 get_nodes得到连接边的节点 is_being_used检查此边所指向的节点是否使用了此边 is_dangling检查是否是悬边 update_axis更新边所连接的节点 Ncontensornetwork.ncon根据一个张量网络规范缩并张量或节点列表 tensornetwork.ncon_netwrok根据张量从张量列表创建一个网络 Matrix Product Statesclass tensornetwork.matrixprductstates.base_mps.BaseMPSMPS的基类。BaseMPS是一个有限单元的无限矩阵乘积状态。 apply_one_site_gateapply_transfer_operatorapply_two_site_gatebond_dimensioncheck_orthonormalityget_nodemeasure_local_operatormeasure_two_body_correlatorphysical_dimensionspositionswitch_backend class tensornetwork.matrixprductstates.finite_mps.FiniteMPS表示有限系统的MPS类 canonicalizecheck_canonicalleft_envsclassmethod randomright_envs class tensornetwork.matrixprductstates.infinite_mps.InfiniteMPS表示无限系统的MPS类 canonicalizeclassmethod randomtransfer_matrix_eigs","link":"/2020/02/27/TensorNetwork-documentation/"},{"title":"computational physics 4","text":"Rigid Body Dynamics Lagrange及动量守恒约束条件如下 \\left\\{ \\begin{aligned} &L = \\frac{1}{2} I_\\psi (\\dot{\\psi}+\\dot{\\phi} \\cos \\theta)^2 + \\frac{1}{2} I_0 (\\dot{\\theta}^2+\\dot{\\phi}^2 \\sin \\theta^2) -mgl \\cos \\theta \\\\ &\\frac{\\partial L}{\\partial \\dot{\\psi}} = p_\\psi = I_\\psi (\\dot{\\psi}+\\dot{\\phi} \\cos \\theta) = const \\\\ &\\frac{\\partial L}{\\partial \\dot{\\phi}} = p_\\phi = I_\\psi (\\dot{\\psi}+\\dot{\\phi} \\cos \\theta)\\cos \\theta +I_0 \\dot{\\phi} \\sin \\theta^2 = const \\end{aligned} \\right.用$p_\\phi,p_\\psi,\\theta$代替$\\dot{\\psi},\\dot{\\phi}$，得到 L = \\frac{1}{2} I_0 \\dot{\\theta}^2 - V_{eff}(\\theta)求运动方程 \\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{\\theta}} - \\frac{\\partial L}{\\partial \\theta} = 0 \\Longrightarrow I_0 \\ddot{\\theta} = f(\\theta)Parametric resonance \\ddot{\\theta}+ w_0^2(t)\\theta= 0,w_0(t)=w_0(1+\\alpha \\cos wt),|\\alpha| \\ll 1 \\\\ w = 2w_0 + \\varepsilon \\Longrightarrow \\ddot{\\theta}+w_0^2[1+2 \\alpha \\cos(2w_0+\\varepsilon)t] \\theta = 0\\\\有解为 \\theta = a(t) \\cos (w_0+ \\frac{\\varepsilon}{2})t + b(t) \\sin(w_0+\\frac{\\varepsilon}{2}t) \\\\ \\Longrightarrow \\ddot{\\theta} = \\cdots$a(t),b(t)$为慢变化项，忽略二阶导数$\\ddot{a},\\ddot{b}$，有$a \\sim e^{\\mu t},b \\sim e^{\\mu t}, a\\sim \\mu a, b \\sim \\mu b$ \\mu = \\pm \\frac{1}{2} \\sqrt{(\\alpha w_0)^2-\\varepsilon^2}共振判断条件 $|\\varepsilon|&lt;|\\alpha w_0|$，不稳定 $|\\varepsilon|&gt;|\\alpha w_0|$，稳定 周期问题历史发展 Mathieu eq(1868)，$y’’ + (a-2q \\cos 2x)y = 0$ Floquet(1883)，$\\dot{x}=A(t)x,A(t)=A(t+T)$ Hill eq(1886)，$\\ddot{y}+f(t)y=0,f(t)=f(t+\\tau)$ Bloch定理 Floquet \\dot{x} = A(t)x \\\\ \\Longrightarrow \\dot{\\phi} = A \\phi, \\ \\phi=(x_1,x_2,\\cdots)解满足一下性质 \\phi (t+T) = \\phi(t) \\phi^{-1}(0)\\phi(T) \\\\ \\phi(t) = P(t)e^{tB},P(t)=P(t+T) \\\\ \\phi(t+T) = \\phi(t)e^{TB} \\\\ Tr [TB] = \\int_0^T Tr[A(s)]ds \\ or \\ Tr[B]=T^{-1}\\int_0^T Tr[A(s)]ds \\\\ Tr[\\ln A] = \\ln[Det A],e^B=e^{A_1}e^{A_2} \\Rightarrow TrB=TrA_1+TrA_2Bloch - \\frac{d^2}{dx^2} \\phi - 2q \\cos x \\phi = \\varepsilon \\phi \\\\ \\phi _k(x) = e^{ikx} \\sum_n C_n e^{inx} \\\\ \\Longrightarrow (n+k)^2 C_n - q(C_{n+1}+C_{n-1})=\\varepsilon C_n \\begin{pmatrix} \\ddots & & & & \\\\ -q & (1+k)^2 & -q & & \\\\ & -q & (0+k)^2 & -q & \\\\ & & -q & (-1+k)^2 & -q \\\\ & & & & \\ddots \\end{pmatrix} \\begin{pmatrix} \\vdots \\\\ C_1 \\\\ C_0 \\\\ C_{-1} \\\\ \\vdots \\end{pmatrix} = \\varepsilon \\begin{pmatrix} \\vdots \\\\ C_1 \\\\ C_0 \\\\ C_{-1} \\\\ \\vdots \\end{pmatrix}Mathieu eq - \\frac{d^2}{dt^2} \\phi + (a - 2q \\cos t) \\phi = 0$t \\Rightarrow x$，变为Bloch问题 不同点 $t \\Rightarrow $演化$\\Rightarrow$给定$a$，$q \\Rightarrow \\phi(t)$ $x \\Rightarrow $本征值问题$\\Rightarrow \\varepsilon$，$\\phi (x)$ 作业作业5 利用Mathematica推导Rigid Body Dynamics的各方程 (Simplify,Fullsimplify) 用NDSolve求解$\\theta(t),\\psi(t),\\phi(t)$ 作业6 用NDSolve研究参数共振问题 如何取$w$值，使其共振 作业7 从无穷矩阵看出，$|k| \\leq 1/2$ 计算Bloch能带 扫描a和q，画出稳定区域 作业8参考Compartmental models in epidemiology(wiki))，计算里面所有模型 The SIR model without vital dynamics The SIR model with vital dynamics and constant population The SIS model The MSIR model The SEIR model The MSEIR model （1）用NDSolve求演化过程；（2）变化参数，看哪种情况疫情可以得到控制","link":"/2020/03/23/computational-physics-4/"},{"title":"计算物理-3","text":"矩阵与线性变换 解方程问题可以部分转化为矩阵问题，表示会变得更清晰。 矩阵变换 Schmidt分解 QR分解 LU分解 本征值/对角化 方阵$A_{n \\times n}$ Hermite A=A^\\dagger,A=U^{\\dagger} \\lambda U,U^{\\dagger}U=1,\\lambda_i \\in \\mathrm{R} \\\\ 若 A,U \\in \\mathrm{R},则U^{T}U=1 not-Hermite A \\neq A^{\\dagger} ,相似变换 A=P^{-1} \\lambda P 非方阵$A_{m \\times n}$，SVD分解 A_{m \\times n} = U \\lambda V ,其中U^{\\dagger}U=1,V^{\\dagger}V=1,\\lambda 为对角阵 LAPACK一个Fortron和C的线性代数软件包 需要关注其命名法则，命名表现了矩阵的特性 XYYZZZ $X:= s,d,c,z$，分别代表单精度，双精度，复数，复数+双精度 YY代表矩阵类型，bd(bidiagonal)，ge(general) ZZZ代表对角化方法 经典力学中的计算问题经典力学 L = L(q,\\dot{q}) \\\\ \\delta S=0 \\\\ S= \\int L dt \\Longrightarrow \\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{q}} - \\frac{\\partial L}{\\partial q} = 0几类特殊的L平动转动 L=T-V \\\\ L = \\frac{1}{2} m \\dot{x}^2 - V(x)EM Field L = \\frac{1}{2} m v^2 -e \\phi + e \\vec{A} \\cdot \\vec{v}相对论 L = -m_0 c^2 \\sqrt{1-v^2/c^2} - V(x)一些问题这些问题可以使用NDSolve数值的求解。 单摆 L = \\frac{1}{2}ml^2 \\dot{\\theta}^2 + mgl\\cos \\theta \\\\ ml^2 \\ddot{\\theta} = -mgl \\sin \\theta \\\\ \\theta \\rightarrow 0, \\ddot{\\theta} = -g/l \\theta振子 T = \\frac{1}{2}m(\\dot{x}_1^2+\\dot{x}_2^2+\\dot{x}_3^2)\\\\ V = \\frac{1}{2}k(x_1^2 + (x_1-x_2)^2+x_3^2)代入Lagrange方程，可以得到线性方程组，转化为解参数矩阵的解的问题。 RCL电路 \\begin{aligned} V & = L \\frac{di}{dt} + Ri + \\frac{1}{C} \\int_0^t i dt' \\\\ & = L \\ddot{Q} + R \\dot{Q} +\\frac{1}{C} Q \\end{aligned}可以与一般的耗散系统，带摩擦力的简谐振子运动方程$m \\ddot{x} - \\mu mg \\dot{x} + kx = 0$一一对应。 类比的思想 RCL电路的类比 热力学第一定律$\\Longleftrightarrow$哈密顿力学 dU=-PdV+TdS \\Longleftrightarrow dH= \\dot{q}dp-\\dot{p}dq","link":"/2020/03/23/computational-physics-3/"},{"title":"计算物理作业1","text":"第一次计算物理作业 作业1求$AX^2+BX+C=0$的根，其中$A,B,C$都是可逆矩阵，自己给定(用随机数生成，$3 \\times 3$或$5 \\times 5$)，$X$为$N \\times N$的矩阵，求根$X$，收敛性如何。 初始化$A,B,C$ 12345678910n = 3;iternum = 20;Amatrix = RandomReal[1, {n, n}];Bmatrix = RandomReal[1, {n, n}];Cmatrix = RandomReal[1, {n, n}];Echo[MatrixForm[Amatrix], \"A:\"];Echo[MatrixForm[Bmatrix], \"B:\"];Echo[MatrixForm[Cmatrix], \"C:\"];Xstart = RandomReal[1, {n, n}]; 第一种迭代方式 X_{n+1} = X_n + \\beta(AX_n^2+BX_n+C)12345678910beta = RandomReal[1];XmTable1 = Table[Table[0 , {i, n}, {j, n}], {i, iternum}];XmTable1[[1]] = Xstart;Table[XmTable1[[i + 1]] = XmTable1[[i]] + beta*(Amatrix.XmTable1[[i]].XmTable1[[i]] + Bmatrix.XmTable1[[i]] + Cmatrix), {i, iternum - 1}];Table[Echo[MatrixForm[XmTable1[[i]]], \"iter:\", i], {i, iternum}];TestIter1 = XmTable1[[iternum]] - XmTable1[[iternum - 1]];Echo[MatrixForm[TestIter1], \"Def1:\"]; 可以看到，因为存在平方项的原因，数值越来越大 第二种迭代方式 X_{n+1} = B^{-1}(-AX_{n}^2-C)123456789XmTable2 = Table[Table[0 , {i, n}, {j, n}], {i, iternum}];XmTable2[[1]] = Xstart;BmatrInver = Inverse[Bmatrix];Table[XmTable2[[i + 1]] = BmatrInver.(-Amatrix.XmTable2[[i]].XmTable2[[i]] - Cmatrix), {i, iternum - 1}];Table[Echo[MatrixForm[XmTable2[[i]]], \"iter:\", i], {i, iternum}];TestIter2 = XmTable2[[iternum]] - XmTable2[[iternum - 1]];Echo[MatrixForm[TestIter2], \"Def2:\"]; 和第一种方法类似的，结果很快就变得很大。 第三种迭代方式 X_{n+1} = A^{-1}(-BX_n-C)X_n^{-1}123456789XmTable3 = Table[Table[0 , {i, n}, {j, n}], {i, iternum}];XmTable3[[1]] = Xstart;AmatrInver = Inverse[Amatrix];Table[XmTable3[[i + 1]] = AmatrInver.(-Bmatrix.XmTable3[[i]] - Cmatrix).Inverse[ XmTable3[[i]]], {i, iternum - 1}];Table[Echo[MatrixForm[XmTable3[[i]]], \"iter:\", i], {i, iternum}];TestIter3 = XmTable3[[iternum]] - XmTable3[[iternum - 1]];Echo[MatrixForm[TestIter3], \"Def3:\"]; 虽然没有像前两种方法一样数值变得很大，但也没有收敛的趋势，数值来回震荡。迭代次数增加也求不出结果。 使用FindRoot求解123456789Xmatrix = Array[xn, {n, n}];Echo[MatrixForm[Xmatrix], \"X:\"];ResSol = FindRoot[ Amatrix.Xmatrix.Xmatrix + Bmatrix.Xmatrix + Cmatrix == 0, Flatten[Array[{Xmatrix[[#1, #2]], 0} &amp;, {n, n}], 1]]ResX = Xmatrix /. ResSol;Echo[MatrixForm[ResX], \"X ResSol:\"];ResTest = Amatrix.ResX.ResX + Bmatrix.ResX + Cmatrix;Echo[MatrixForm[ResTest], \"X ResTest:\"]; 可以快速的求出根 总结在这个题目中使用迭代法很难求出根，选取的初始点很关键，随机选到的初始点一般都不会收敛。我试了很久，只有一次$n=2$时求出了根。 使用FindRoot内置函数会很快的求出根，因为它可以选择较优的求根方式来解决这个问题。 作业22.Lorenz Attractor \\left\\{ \\begin{aligned} \\dot{x} &= \\sigma(y-x) , \\\\ \\dot{y} &= \\rho x -y -xz , \\\\ \\dot{z} &= xy - \\beta z, \\end{aligned} \\right. 取合适的$\\sigma,\\rho,\\beta$，画出运动轨迹 $dx/dt=0,dy/dt=0,dz/dt=0$，求$x^,y^,z^*$ Euler算法迭代求运动轨迹 \\left\\{ \\begin{aligned} x &= x^* + \\widetilde{x} , \\\\ y &= y^* + \\widetilde{y} , \\\\ z &= z^* + \\widetilde{z} , \\end{aligned} \\right. \\Longrightarrow \\dot{\\vec r}=A \\vec{r},\\vec{r}=(x,y,z)求A的本征值及其稳定性 $x^,y^,z^*$若非正中心，稳定性如何？ a.画出运动轨迹1234567891011121314151617sigma = 7;rho = 28;beta = 3;xstart = RandomReal[1];ystart = RandomReal[1];zstart = RandomReal[1];sol = NDSolve[{x'[t] == sigma (y[t] - x[t]), y'[t] == rho*x[t] - y[t] - x[t]*z[t], z'[t] == x[t]*y[t] - beta*z[t], x[0] == xstart, y[0] == ystart, z[0] == zstart}, {x[t], y[t], z[t]}, {t, 0, 100}]; CoolColor[ z_ ] := RGBColor[z, 1 - z, 1];ParametricPlot3D[{x[t], y[t], z[t]} /. sol, {t, 0, 100}, PlotPoints -&gt; 100, ColorFunction -&gt; CoolColor, PlotStyle -&gt; Directive[Thin]] b.找到导数为零的点求解 \\left\\{ \\begin{aligned} 0 &= \\sigma(y-x) , \\\\ 0 &= \\rho x -y -xz , \\\\ 0 &= xy - \\beta z, \\end{aligned} \\right.1234Solve[ sigma (ystar - xstar) == 0 &amp;&amp; rho*xstar - ystar - xstar*zstar == 0 &amp;&amp; xstar*ystar - beta*zstar == 0, {xstar, ystar, zstar}];Echo[{xstar, ystar, zstar} /. %, \"{xstar,ystar,zstar}:\"]; 结果为 1{xstar,ystar,zstar}: {{-9,-9,27},{0,0,0},{9,9,27}} c.迭代法求运动轨迹使用内置函数使用内置NDSolve函数指定显示Euler方法ExplicitEuler求解 12345sol = NDSolve[{x'[t] == sigma (y[t] - x[t]), y'[t] == rho*x[t] - y[t] - x[t]*z[t], z'[t] == x[t]*y[t] - beta*z[t], x[0] == xstart, y[0] == ystart, z[0] == zstart}, {x[t], y[t], z[t]}, {t, 0, 100}, Method -&gt; {\"ExplicitEuler\"}] 会比系统自动选取的方法慢一些。 自己编写程序使用向前Euler公式 y_{n+1} = y_n + hf(x_n,y_n)可以得到 \\left\\{ \\begin{aligned} x_{n+1} &= x_n + h(\\sigma(y_n-x_n)) , \\\\ y_{n+1} &= y_n + h(\\rho x_n -y_n -x_nz_n) , \\\\ z_{n+1} &= z_n+ h(x_ny_n - \\beta z_n), \\end{aligned} \\right.12345678910111213npoint = 10000;tmax = 100;F = Table[{x[t], y[t], z[t]}, {t, 1, npoint}];h = tmax/npoint;F[[1]] = {xstart, ystart, zstart}Table[F[[t + 1]] = {F[[t, 1]] + h*sigma (F[[t, 2]] - F[[t, 1]]), F[[t, 2]] + h*(rho*F[[t, 1]] - F[[t, 2]] - F[[t, 1]]*F[[t, 3]]), F[[t, 3]] + h*(F[[t, 1]]*F[[t, 2]] - beta*F[[t, 3]])} , {t, 1, npoint - 1}];ListPointPlot3D[F] d.e.求A的特征值及其稳定性 \\begin{pmatrix} \\sigma(y-x) \\\\ \\rho x -y -xz \\\\ xy - \\beta z \\end{pmatrix} = A \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}可设 A= \\begin{pmatrix} -\\sigma & \\sigma & 0\\\\ \\rho & -1 & -x \\\\ y & 0 & -\\beta \\end{pmatrix}程序为 1234567891011121314151617181920212223242526272829sigma = 7;rho = 28;beta = 3;EquSol = Solve[ sigma (ystar - xstar) == 0 &amp;&amp; rho*xstar - ystar - xstar*zstar == 0 &amp;&amp; xstar*ystar - beta*zstar == 0, {xstar, ystar, zstar}];Echo[{xstar, ystar, zstar} /. %, \"{xstar,ystar,zstar}:\"];start = {xstar, ystar, zstar} /. EquSolnpoint = 10;tmax = 1/10;F = Table[{x[t], y[t], z[t]}, {t, 1, npoint}];h = tmax/npoint;F[[1]] = {3, 4, 5} + {RandomReal[1], RandomReal[1], RandomReal[1]}Table[F[[t + 1]] = {F[[t, 1]] + h*sigma (F[[t, 2]] - F[[t, 1]]), F[[t, 2]] + h*(rho*F[[t, 1]] - F[[t, 2]] - F[[t, 1]]*F[[t, 3]]), F[[t, 3]] + h*(F[[t, 1]]*F[[t, 2]] - beta*F[[t, 3]])} , {t, 1, npoint - 1}];ListPointPlot3D[F]A = Table[{{-sigma, -sigma, 0}, {rho, -1, -F[[t, 1]]}, {F[[t, 2]], 0, -beta}}, {t, 1, npoint - 1}]AEign = Table[Eigenvalues[A[[t]]], {t, 1, npoint - 1}] 任意取$(x^,y^,z^*)$为$(3,4,5)$，得到的结果不稳定 在取$(x^,y^,z^*)$为使导数为零点处，得到的结果较稳定 1F[[1]] = start[[1]] + {RandomReal[1], RandomReal[1], RandomReal[1]} 作业4利用Mathematica的NDSolve函数求解$\\ddot{\\theta}=-\\sin \\theta$（取不同初始条件）。 1234thetaStart = {Pi/2, Pi/4, Pi/6, Pi/8};Table[NDSolve[{theta''[t] == Sin[theta[t]], theta[0] == thetaStart[[i]], theta'[0] == 0}, theta[t], {t, 0, 100}], {i, 1, 4}] 运行结果为 可以看到当$\\theta$初始值较高时，势能更高，运动速度较快。","link":"/2020/03/12/computational-physics-homework-1/"},{"title":"计算物理作业2","text":"第二次计算物理作业 作业5 利用Mathematica推导Rigid Body Dynamics的各方程 (Simplify,Fullsimplify) 用NDSolve求解$\\theta(t),\\psi(t),\\phi(t)$ 推导刚体动力学方程Lagrange及动量守恒约束条件如下 \\left\\{ \\begin{aligned} &L = \\frac{1}{2} I_\\psi (\\dot{\\psi}+\\dot{\\phi} \\cos \\theta)^2 + \\frac{1}{2} I_0 (\\dot{\\theta}^2+\\dot{\\phi}^2 \\sin \\theta^2) -mgl \\cos \\theta \\\\ &\\frac{\\partial L}{\\partial \\dot{\\psi}} = p_\\psi = I_\\psi (\\dot{\\psi}+\\dot{\\phi} \\cos \\theta) = const \\\\ &\\frac{\\partial L}{\\partial \\dot{\\phi}} = p_\\phi = I_\\psi (\\dot{\\psi}+\\dot{\\phi} \\cos \\theta)\\cos \\theta +I_0 \\dot{\\phi} \\sin \\theta^2 = const \\end{aligned} \\right.用$p_\\phi,p_\\psi,\\theta$代替$\\dot{\\psi},\\dot{\\phi}$，得到 L = \\frac{1}{2} I_0 \\dot{\\theta}^2 - V_{eff}(\\theta)求使用Lagrange方程求运动方程 \\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{\\theta}} - \\frac{\\partial L}{\\partial \\theta} = 0 \\Longrightarrow I_0 \\ddot{\\theta} = f(\\theta)下面用Mathematica推导上述过程（参考guide/Formula Manipulation） 1234567891011L = 1/2*I\\[Psi] (\\[Psi]'[t] + \\[Phi]'[t]*Cos[\\[Theta][t]])^2 + 1/2 I0 ((\\[Theta]'[t])^2 + (\\[Phi]'[t])^2 Sin[\\[Theta][t]]^2) - m*g*l*Cos[\\[Theta][t]]const1 = p\\[Psi] == D[L, \\[Psi]'[t]]const2 = p\\[Phi] == D[L, \\[Phi]'[t]]Solve[const1 &amp;&amp; const2, {\\[Psi]'[t], \\[Phi]'[t]}]LNew = Simplify[L /. %[[1]]]Eq = FullSimplify[ D[D[LNew, \\[Theta]'[t]], t] - D[LNew, \\[Theta][t]] == 0] 数值求解 用NDSolve求解$\\theta(t),\\psi(t),\\phi(t)$ 12345678Const = {p\\[Psi] -&gt; 1, p\\[Phi] -&gt; 1, I\\[Psi] -&gt; 1, I0 -&gt; 1, l -&gt; 1, m -&gt; 1, g -&gt; 1}\\[Theta]t = NDSolve[{Eq, const1, const2 , \\[Theta][0] == 0.1, \\[Theta]'[0] == 0.1, \\[Psi][0] == 0.1, \\[Phi][0] == 0.1} /. Const, {\\[Theta], \\[Psi], \\[Phi]}, {t, 0, 2}] 作业6 用NDSolve研究参数共振问题 如何取$w$值，使其共振 理论推导 \\ddot{\\theta}+ w_0^2(t)= 0,w_0(t)=w_0(1+\\alpha \\cos wt),|\\alpha| \\ll 1 \\\\ w = 2w_0 + \\varepsilon \\Longrightarrow \\ddot{\\theta}+w_0^2[1+2 \\alpha \\cos(2w_0+\\varepsilon)t] \\theta = 0\\\\有解为 \\theta = a(t) \\cos (w_0+ \\frac{\\varepsilon}{2})t + b(t) \\sin(w_0+\\frac{\\varepsilon}{2}t) \\\\ \\Longrightarrow \\ddot{\\theta} = \\cdots$a(t),b(t)$为慢变化项，忽略二阶导数$\\ddot{a},\\ddot{b}$，有$a \\sim e^{\\mu t},b \\sim e^{\\mu t}, a\\sim \\mu a, b \\sim \\mu b$ \\mu = \\pm \\frac{1}{2} \\sqrt{(\\alpha w_0)^2-\\varepsilon^2}共振判断条件 $|\\varepsilon|&lt;|\\alpha w_0|$，不稳定 $|\\varepsilon|&gt;|\\alpha w_0|$，稳定 使用NDSolve验证取参数如下： $\\alpha$ $\\omega_0$ $\\varepsilon$ $ \\varepsilon &lt; \\alpha \\omega_0 $ 1 0.1 5 0.1 &lt; 2 0.1 -4 0.1 &lt; 3 0.1 1 0.1 = 4 0.1 0.5 0.1 &gt; 5 0.1 -0.2 0.1 &gt; 1234567891011\\[Alpha] = 0.1;\\[Epsilon] = 0.1;tmax = 80;Parame = {{\\[Omega]0 -&gt; 5}, {\\[Omega]0 -&gt; -4}, {\\[Omega]0 -&gt; 1}, {\\[Omega]0 -&gt; 0.5}, {\\[Omega]0 -&gt; -0.2}}PREq = \\[Theta]''[ t] + (\\[Omega]0)^2 (1 + 2 \\[Alpha]*Cos[2 \\[Omega]0 + \\[Epsilon]] t) \\[Theta][t] == 0Table[NDSolve[{PREq, \\[Theta][0] == 0.1, \\[Theta]'[0] == 0.1} /. Parame[[i]], \\[Theta], {t, 0, tmax}], {i, 5}]Table[Plot[\\[Theta][t] /. %[[i]], {t, 0, tmax}], {i, 5}] 运行，得到输出 可以看到编号为1，2，3参数所得图像都不稳定，都不收敛，1发散的速度较快，2为震荡发散，速度较慢，这取决于$\\mu$参数的大小和幅度项的因子。在编号为3的参数下，$|\\varepsilon| = |\\alpha \\omega_0|$，还是发散了，这是因为近似误差的原因。4，5收敛，都与讨论结果相符。 作业7 从无穷矩阵看出，$|k| \\leq 1/2$ 计算Bloch能带 扫描a和q，画出稳定区域 关于k范围的讨论 - \\frac{d^2}{dx^2} \\phi - 2q \\cos x \\phi = \\varepsilon \\phi \\\\ \\phi _k(x) = e^{ikx} \\sum_n C_n e^{inx} \\\\ \\Longrightarrow (n+k)^2 C_n - q(C_{n+1}+C_{n-1})=\\varepsilon C_n \\begin{pmatrix} \\ddots & & & & \\\\ -q & (1+k)^2 & -q & & \\\\ & -q & (0+k)^2 & -q & \\\\ & & -q & (-1+k)^2 & -q \\\\ & & & & \\ddots \\end{pmatrix} \\begin{pmatrix} \\vdots \\\\ C_1 \\\\ C_0 \\\\ C_{-1} \\\\ \\vdots \\end{pmatrix} = \\varepsilon \\begin{pmatrix} \\vdots \\\\ C_1 \\\\ C_0 \\\\ C_{-1} \\\\ \\vdots \\end{pmatrix}因为存在周期性，假设$k$范围任取，$k$可以表示为$k=m+k’$，其中$m$为整数部分，$k’$为小数部分。代入周期式得 (n+k)^2 C_n - q(C_{n+1}+C_{n-1})=\\varepsilon C_n \\\\ \\Longrightarrow(n'+k')^2 C_n' - q(C_{n'+1}+C_{n'-1})=\\varepsilon C_n'式子并没有改变，对体系的描述并没有变化，存在简并，对$k$的周期为1。 因此，可以假设$|k|&lt;1/2$。 计算Bloch能带123456789101112nmax = 3;q = 0.5;f[i_, j_] := Which[i == j, (i + k)^2, i == j + 1, -q, i == j - 1, -q, True, 0]; matrix = Table[f[i, j], {i, nmax, -nmax, -1}, {j, nmax, -nmax, -1}];step = 0.01;Table[Eigenvalues[matrix /. k -&gt; r], {r, -0.5, 0.5, step}];Table[{step*(i - 1) - 0.5, %[[i, j]]}, {i, 1/step + 1}, {j, 2 nmax + 1}];Flatten[%, 1];ListPlot[%] 当q=0时，无能带间隙 取q=0.5，得到的图像，可以开到低能级出现能带间隙。 取nmax=6，q=3，得到得图像 曲线很直，是因为特征值是根据无穷矩阵的一部分计算出来的，有近似误差。 Mathieu方程 - \\frac{d^2}{dt^2} \\phi + (a - 2q \\cos t) \\phi = 0扫描a和q，画出稳定区域 123456789101112131415tmax = 30;amax = 10;qmax = 10;step = 0.2MathieuEq = -phi''[t] + (a - 2 q*Cos[t])*phi[t] == 0aq = Table[ If[Max[Flatten[ Table[phi[t2] /. NDSolve[{MathieuEq, phi[0] == 0.1, phi'[0] == 0.1} /. {a -&gt; i, q -&gt; j}, phi, {t, 0, tmax}], {t2, 0, tmax}]]] &gt; 10^5, , {i, j}] , {i, -amax, amax, step}, {j, -qmax, qmax, step}];Flatten[%, 1];ListPlot[%] 其实q的符号不会影响稳定性，只用扫描一个符号象限就可以。 作业8参考Compartmental models in epidemiology(wiki))，计算里面所有模型 The SIR model without vital dynamics The SIR model with vital dynamics and constant population The SIS model The MSIR model The SEIR model The MSEIR model （1）用NDSolve求演化过程；（2）变化参数，看哪种情况疫情可以得到控制 The SIR modelSIR模型是最简单的划分模型之一，许多模型都是这种基本形式的派生。 $S$为易感人数，$I$为感染人数，$R$为恢复(或免疫)的人数，转换率$\\gamma=1/D$，$D$为个人感染持续时间。 The SIR model without vital dynamics流行病的动态，例如流感，往往比出生和死亡的动态快得多，因此，出生和死亡在简单的分类模型中经常被忽略。没有所谓的生命动力学(出生和死亡，有时称为人口统计学)的SIR系统可以用下面的一组常微分方程来表示 \\begin{aligned} \\frac{dS}{dt} &= - \\frac{\\beta IS}{N} \\\\ \\frac{dI}{dt} &= \\frac{\\beta I S}{N}- \\gamma I \\\\ \\frac{dR}{dt} &= \\gamma I \\end{aligned}其中$N=S+I+R$。 R_0 = \\frac{\\beta}{\\gamma}1234567891011121314151617s0 = 10000;i0 = 100;r0 = 50;nc = s0 + i0 + r0;tmax = 60;param = {beta -&gt; 1, gamma -&gt; 0.1, S0 -&gt; s0, I0 -&gt; i0, R0 -&gt; r0, Nc -&gt; nc};SIRwvdEq1 = St'[t] == -beta*It[t]*St[t]/Nc;SIRwvdEq2 = It'[t] == beta*It[t]*St[t]/Nc - gamma*It[t];SIRwvdEq3 = Rt'[t] == gamma*It[t];Sol = NDSolve[{SIRwvdEq1, SIRwvdEq2, SIRwvdEq3, St[0] == S0, It[0] == I0, Rt[0] == R0} /. param, {St, It, Rt}, {t, 0, tmax}]Plot[{St[t], It[t], Rt[t]} /. Sol, {t, 0, tmax}, PlotTheme -&gt; \"Detailed\", PlotLegends -&gt; Automatic] 当参数为 $S[0]$ $I[0]$ $R[0]$ $\\beta$ $\\gamma$ $R_0 $ 10000 100 50 1 0.1 10 爆发速度很快，所有人都被感染 参数为| $S[0]$ | $I[0]$ | $R[0]$ | $\\beta$ | $\\gamma$ | $R_0 $ || ——— | ——— | ——— | ———- | ———— | ——— || 10000 | 10 | 0 | 0.2 | 0.1 | 2 | 小部分人不会感染 The SIR model with vital dynamics and constant population考虑人口特征，死亡率$\\mu$，和出生率$\\Lambda$。 \\begin{aligned} \\frac{dS}{dt} &= \\Lambda-\\mu S- \\beta IS \\\\ \\frac{dI}{dt} &= \\beta I S- \\gamma I -\\mu I\\\\ \\frac{dR}{dt} &= \\gamma I -\\mu R \\end{aligned}有 R_0 = \\frac{\\beta \\Lambda}{\\mu(\\mu+\\gamma)}12345678910111213141516s0 = 100000;i0 = 10;r0 = 0;tmax = 60;param = {beta -&gt; 1/s0, gamma -&gt; 0.1, Lambda -&gt; 10^(-5), mu -&gt; 10^(-4), S0 -&gt; s0, I0 -&gt; i0, R0 -&gt; r0};SIRwvdEq1 = St'[t] == Lambda*St[t] - mu*St[t] - beta*It[t]*St[t];SIRwvdEq2 = It'[t] == beta*It[t]*St[t] - gamma*It[t] - mu*It[t];SIRwvdEq3 = Rt'[t] == gamma*It[t] - mu*Rt[t];Sol = NDSolve[{SIRwvdEq1, SIRwvdEq2, SIRwvdEq3, St[0] == S0, It[0] == I0, Rt[0] == R0} /. param, {St, It, Rt}, {t, 0, tmax}]Plot[{St[t], It[t], Rt[t]} /. Sol, {t, 0, tmax}, PlotTheme -&gt; \"Detailed\", PlotLegends -&gt; Automatic] 这个模型调参是真的难，公式省略了N，导致系数的比例差很多 The SIS model有些感染，例如普通感冒和流感，不会带来任何长期的免疫力。这类感染在从感染中恢复后不给予免疫，个人再次成为易感者。 \\begin{aligned} \\frac{dS}{dt} &= - \\frac{\\beta SI}{N}+\\gamma I \\\\ \\frac{dI}{dt} &= \\frac{\\beta S I}{N} - \\gamma I \\end{aligned}12345678910111213s0 = 100000;i0 = 10;nc = s0 + i0;tmax = 60;param = {beta -&gt; 0.5, gamma -&gt; 0.1, S0 -&gt; s0, I0 -&gt; i0, Nc -&gt; nc};SIRwvdEq1 = St'[t] == -beta*It[t]*St[t]/Nc + gamma*It[t];SIRwvdEq2 = It'[t] == beta*It[t]*St[t]/Nc - gamma*It[t];Sol = NDSolve[{SIRwvdEq1, SIRwvdEq2, St[0] == S0, It[0] == I0} /. param, {St, It}, {t, 0, tmax}]Plot[{St[t], It[t]} /. Sol, {t, 0, tmax}, PlotTheme -&gt; \"Detailed\", PlotLegends -&gt; Automatic] The MSIR model \\begin{aligned} \\frac{dM}{dT} &= B - \\delta M -\\mu M\\\\ \\frac{dS}{dT} &= \\delta M - \\beta S I -\\mu S \\\\ \\frac{dI}{dT} &= \\beta S I -\\gamma I -\\mu I \\\\ \\frac{dR}{dT} &= \\gamma I - \\mu R \\end{aligned}12345678910111213141516171819s0 = 10000;i0 = 10;r0 = 0;m0 = 0;nc = s0 + i0 + r0 + m0;tmax = 150;param = {beta -&gt; 0.2/nc, gamma -&gt; 0.1, delta -&gt; 10^(-6), B -&gt; 10^(-6), mu -&gt; 10^(-4), S0 -&gt; s0, I0 -&gt; i0, R0 -&gt; r0, M0 -&gt; m0};SIRwvdEq1 = St'[t] == delta*Mt[t] - beta*It[t]*St[t] - mu*St[t];SIRwvdEq2 = It'[t] == beta*It[t]*St[t] - gamma*It[t] - mu*It[t];SIRwvdEq3 = Rt'[t] == gamma*It[t] - mu*Rt[t];SIRwvdEq4 = Mt'[t] == B - delta*Mt[t] - mu*Mt[t];Sol = NDSolve[{SIRwvdEq1, SIRwvdEq2, SIRwvdEq3, SIRwvdEq4 , St[0] == S0, It[0] == I0, Rt[0] == R0, Mt[0] == M0} /. param, {St, It, Rt, Mt}, {t, 0, tmax}]Plot[{St[t], It[t], Rt[t]} /. Sol, {t, 0, tmax}, PlotTheme -&gt; \"Detailed\", PlotLegends -&gt; Automatic] The SEIR model \\begin{aligned} \\frac{dS}{dT} &= \\Lambda - \\mu S -\\beta \\frac{IS}{N} \\\\ \\frac{dE}{dT} &= \\beta \\frac{IS}{N} - (\\mu+a)E\\\\ \\frac{dI}{dT} &= aE - (\\gamma+\\mu)I \\\\ \\frac{dR}{dT} &= \\gamma I - \\mu R \\end{aligned}1234567891011121314151617181920s0 = 10000;e0 = 8000;i0 = 10;r0 = 0;nc = s0 + i0 + r0 + e0;tmax = 50;param = {beta -&gt; 0.2/nc, gamma -&gt; 0.1, delta -&gt; 10^(-6), a -&gt; 10^(-4), mu -&gt; 10^(-4), S0 -&gt; s0, I0 -&gt; i0, R0 -&gt; r0, E0 -&gt; e0};SIRwvdEq1 = St'[t] == delta - beta*It[t]*St[t] - mu*St[t];SIRwvdEq2 = It'[t] == a*Et[t] - (gamma + mu) It[t];SIRwvdEq3 = Rt'[t] == gamma*It[t] - mu*Rt[t];SIRwvdEq4 = Et'[t] == beta*It[t]*St[t] - (mu + a) Et[t];Sol = NDSolve[{SIRwvdEq1, SIRwvdEq2, SIRwvdEq3, SIRwvdEq4 , St[0] == S0, It[0] == I0, Rt[0] == R0, Et[0] == E0} /. param, {St, It, Rt, Et}, {t, 0, tmax}]Plot[{St[t], It[t], Rt[t]} /. Sol, {t, 0, tmax}, PlotTheme -&gt; \"Detailed\", PlotLegends -&gt; Automatic] 参数没调好。。。 The MSEIR model \\begin{aligned} \\frac{dM}{dT} &= B - \\delta M -\\mu M\\\\ \\frac{dS}{dT} &= \\delta M - \\beta S I -\\mu S \\\\ \\frac{dE}{dT} &= \\beta IS - (\\varepsilon+\\mu)E\\\\ \\frac{dI}{dT} &= \\varepsilon E - (\\gamma+\\mu)I \\\\ \\frac{dR}{dT} &= \\gamma I - \\mu R \\end{aligned}1234567891011121314151617181920212223s0 = 10000;e0 = 8000;i0 = 10;r0 = 0;m0 = 0;nc = s0 + i0 + r0 + e0;tmax = 50;param = {beta -&gt; 0.2/nc, gamma -&gt; 0.1, delta -&gt; 10^(-6), a -&gt; 10^(-4), mu -&gt; 10^(-4), B -&gt; 10^(-6), S0 -&gt; s0, I0 -&gt; i0, R0 -&gt; r0, E0 -&gt; e0, M0 -&gt; m0};SIRwvdEq1 = St'[t] == delta*Mt[t] - beta*It[t]*St[t] - mu*St[t];SIRwvdEq2 = It'[t] == a*Et[t] - (gamma + mu) It[t];SIRwvdEq3 = Rt'[t] == gamma*It[t] - mu*Rt[t];SIRwvdEq4 = Et'[t] == beta*It[t]*St[t] - (mu + a) Et[t];SIRwvdEq5 = Mt'[t] == B - delta*Mt[t] - mu*Mt[t];Sol = NDSolve[{SIRwvdEq1, SIRwvdEq2, SIRwvdEq3, SIRwvdEq4 , SIRwvdEq5, St[0] == S0, It[0] == I0, Rt[0] == R0, Et[0] == E0, Mt[0] == M0} /. param, {St, It, Rt, Et, Mt}, {t, 0, tmax}]Plot[{St[t], It[t], Rt[t]} /. Sol, {t, 0, tmax}, PlotTheme -&gt; \"Detailed\", PlotLegends -&gt; Automatic] 作业9若$UU^{\\dagger}=1$，$\\tilde{b}=Ub$，$b$为玻色或费米算符，证明变换后$U$不改变粒子的统计性质。 玻色子 a_i^{\\dagger}a_j^{\\dagger}-a_j^{\\dagger}a_i^{\\dagger} = [a_i^{\\dagger},a_j^{\\dagger}]=0 \\\\ a_i a_j-a_j a_i = [a_i,a_j]=0 \\\\ a_i a_j^{\\dagger} - a_j^{\\dagger} a_i = [a_i,a_j^{\\dagger}]=\\delta_{ij}费米子 a_i^{\\dagger}a_j^{\\dagger}+a_j^{\\dagger}a_i^{\\dagger} = \\{a_i^{\\dagger},a_j^{\\dagger}\\}=0 \\\\ a_i a_j+a_j a_i = \\{a_i,a_j\\}=0 \\\\ a_i a_j^{\\dagger} + a_j^{\\dagger} a_i = \\{a_i,a_j^{\\dagger}\\}=\\delta_{ij}用上述规则证明变换后统计性质不变。 作业10 H=\\sum_i [t(C_i^{\\dagger}C_{i+1}+\\mathbf{h.c.})+\\mu_i C_i^{\\dagger}C_i ]\\\\ \\mu_i=\\mu+\\varepsilon_i 若$\\varepsilon_i$为高斯分布，$\\langle \\varepsilon_i \\rangle=0 ,\\langle \\varepsilon_i \\varepsilon_j \\rangle = \\sigma^2 \\delta_{ij} $，数值对角化给出局域的波函数。 $\\varepsilon_i = V \\cos(2 \\pi qi)$，$q$为无理数，验证存在扩展态到局域态相变过程。 数值对角化写将$H$写成矩阵形式 \\begin{pmatrix} \\cdots & C^{\\dagger}_1 & C^{\\dagger}_0 & C^{\\dagger}_{-1} & \\cdots \\end{pmatrix} \\begin{pmatrix} \\ddots & & & & \\\\ t & \\mu+\\varepsilon_{-1} & t & & \\\\ & t & \\mu+\\varepsilon_{-0} & t & \\\\ & & t & \\mu+\\varepsilon_{1} & t \\\\ & & & & \\ddots \\end{pmatrix} \\begin{pmatrix} \\vdots \\\\ C_1 \\\\ C_0 \\\\ C_{-1} \\\\ \\vdots \\end{pmatrix}123456789101112131415161718192021222324nmax = 1000;H = zeros(nmax);mu = 1;t = 1;varepsilon = normrnd(0,1,nmax,1);for i = 1 : nmax for j = 1 : nmax if i == j H(i,j) = mu + varepsilon(i,1); continue; end if j == i+1 H(i,j) = t; continue; end if j == i-1 H(i,j) = t; continue; end endend[V,D] = eig(H); 验证存在扩展态到局域态相变过程还不理解什么意思","link":"/2020/03/27/computational-physics-homework-2/"},{"title":"本博客的搭建方法","text":"博客搭建过程参考了TRHX的文章 使用 Github Pages 和 Hexo 搭建自己的独立博客 主题选择使用的是ICARUS主题 ICARUS主题展示 在github上clone了ICARUS主题再修改了一些配置项 ICARUS文件 主题的修改过程参考了 搭建自己的技术博客系列（六)","link":"/2020/02/17/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/"},{"title":"tensor network and quantum information","text":"​ 在这一节中，将讨论一些量子信息概念的例子，这些概念可以用张量网络符号更好地理解。 Bell state and the Bell basis​ Bell基(Bell basis)构成了两粒子最大纠缠态的正交集合。Bell基标准的标记如下： |\\Phi^{\\pm}\\rangle :=(|0\\rangle \\otimes |0\\rangle \\pm |1\\rangle \\otimes |1\\rangle)/\\sqrt{2}\\\\ |\\Psi^{\\pm}\\rangle :=(|0\\rangle \\otimes |1\\rangle \\pm |1\\rangle \\otimes |0\\rangle)/\\sqrt{2}\\\\对于第一个基$|\\Phi^{+}\\rangle$，称为Bell态(Bell state)，用$|\\Omega\\rangle$表示。 |\\Omega \\rangle = \\frac{1}{\\sqrt{2} } \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix} \\quad \\mathop{\\rightleftharpoons}_{Vectorise}^{Matricise} \\quad \\frac{1}{\\sqrt{2} } \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} =\\frac{I}{\\sqrt{2} }在张量网络符号中，它被简单地表示为一条连接两条腿的线。 ​ 要注意，这样一个表示包含很深刻的意义，如果将线的末端视为两个比特，对一个比特执行操作相当与对另一个比特执行转置操作，这很容易验证。那么，连线就意味着比特的纠缠。 ​ 定义$|\\Omega(\\Omicron)\\rangle=(\\Omicron\\otimes I)|\\Omega\\rangle$。根据这个定义，我们可以看到Bell基简单的对应着泡利算子的向量化。 |\\Phi^+ \\rangle = |\\Omega(I)\\rangle,\\quad |\\Phi^- \\rangle = |\\Omega(Z)\\rangle, \\quad |\\Psi^+ \\rangle = |\\Omega(X)\\rangle, \\quad |\\Psi^- \\rangle \\propto |\\Omega(Y)\\rangle \\quad​ 因此，可以看到Bell基与Pauli算符密切相关，在Bell基上的欧几里德内积(Euclidean inner product)状态对应于上Pauli算符的希伯特-施密特内积(Hilbert-Schmidt inner product)。 Quantum teleportation​ 给定上面的Bell基标记，我们就可以用TNN来表示和理解量子隐态传输。 |\\phi_B\\rangle = \\mathop{\\overbrace{(p_B)}}^{Correction} \\mathop{\\overbrace{(\\langle\\Omega_{A_1A_2}(p))}}^{Teleportation} \\mathop{\\overbrace{(|\\psi_{A_1}\\rangle \\otimes |\\Omega_{A_2B}\\rangle)}}^{Setup} = |\\psi_B\\rangle/2 ​ 可以看到公式与TNN相对应，公式和TNN都从右往左看。在TNN上用一条竖线往下画，可以截断3条横线，这三条并列的横线与Setup相对应。Teleportation过程相作用了一个左矢，相当于在TNN作用一个开口向右的弧线，将腿的数量减少到1。最后Correction的过程，在B上作用一个$p$。可以看到B最后可以得到$|\\psi\\rangle/2$。然后要验证一下，隐态传输算法中，$p$是否满足如上的关系，确定这TNN表达的合理性。 Gate teleportation |\\phi\\rangle = \\mathop{\\overbrace{(C_p)}}^{Correction} \\mathop{\\overbrace{(\\langle\\Omega_{A_1A_2}(p))}}^{Teleportation} \\mathop{\\overbrace{(|\\psi_{A_1}\\rangle \\otimes |\\Omega_{A_2B}(U^T)\\rangle)}}^{Setup} =C_pUp^{\\dagger}|\\psi\\rangle/2 ​ 如果令$C_p:=UpU^\\dagger$，那么Bob总是可以得到$U|\\psi\\rangle$。如果$U$是Clifford操作(Clifford群是将Paulis映射到Paulis的操作群)，这个修正也是一个泡利，这个传送过程在传送门的使用上并不比标准的传送需要更多的资源。 Purification​ 对于一个混合态$\\rho$，提纯(purification)就是一个将原系统拓展到更大系统(添加的系统称为提纯系统)的纯态(pure state)$|\\psi \\rangle$，以减少原系统$\\rho$的密度。这样的提纯可以给出为$|\\psi\\rangle \\propto (\\sqrt{\\rho} \\otimes I)|\\Omega \\rangle = |\\Omega (\\sqrt{\\rho})\\rangle$。 ​ 通过维度计数，可以看出上述提纯在提纯系统的等轴自由度范围内是唯一的，所以的提纯都是$(\\sqrt{\\rho} \\otimes U)|\\Omega \\rangle$的形式，其中$U^\\dagger U= 1$，即所有的提纯正比于$(\\sqrt{\\rho} \\otimes I)|\\Omega \\rangle$，$|\\Omega\\rangle$可以是其他最大纠缠态。 Stinespring’s Dilation theorem​ Stinespring’s Theorem指出，任意量子通道$\\varepsilon$，即一个完全的正保迹映射(completely positive trace preserving map(CPTP))，可以被表示为一个幺正算符作用在更大的系统上，再取偏迹。 \\varepsilon(\\rho) = Tr_1[V^\\dagger(\\rho \\otimes|0\\rangle\\langle0|)V]在物理上，这意味着，一个动态的开放系统等价于一个更大的封闭系统的子系统。 ​ 任意CPTP映射可以被表示为Kraus操作$K_i$的集合： \\varepsilon(\\rho)=\\sum_i K_i^\\dagger \\rho K_i,\\quad 其中\\sum_i K_iK_i^\\dagger=I.其TNN表示为 接着定义张量$U$为 可以看到$U$满足$U^\\dagger U=I$，可将其视为$V$加上一个附加比特 ​ 通过这样的表示，再对上指标取偏迹，Stinespring Dilation Theorem可以表示为： Problems1.考虑隐态传输的反向。Alice想要将一个经典比特发送给Bob，且她有一个可以传输量子比特的通道。那么单量子比特可以传输多少比特的信息呢？为了简单考虑，只考虑Bob可以执行投影测量的情况。 2.假设Alice和Bob初始共享一个Bell对。这个提前共享的纠缠资源是否可以增加成功传输的经典信息的数量，如果可以的话，增加了多少呢？ superdense coding","link":"/2020/02/19/tensor-network-and-quantum-information/"},{"title":"统计学习方法","text":"统计学习方法目录 第1篇 监督学习第1章 统计学习及监督学习概论1.1 统计学习1.2 统计学习的分类1.2.1 基本分类1.2.2 按模型分类1.2.3 按算法分类1.2.4 按技巧分类1.3 统计学习方法三要素1.3.1 模型1.3.2 策略1.3.3 算法1.4 模型评估与模型选择1.4.1 训练误差与测试误差1.4.2 过拟合与模型选择1.5 正则化与交叉验证1.5.1 正则化1.5.2 交叉验证1.6 泛化能力1.6.1 泛化误差1.6.2 泛化误差上界1.7 生成模型与判别模型1.8 监督学习应用1.8.1 分类问题1.8.2 标注问题1.8.3 回归问题第2章 感知机2.1 感知机模型2.2 感知机学习策略2.2.1 数据集的线性可分性2.2.2 感知机学习策略2.3 感知机学习算法2.3.1 感知机学习算法的原始形式2.3.2 算法的收敛性2.3.3 感知机学习算法的对偶形式第3章 k近邻法3.1 k近邻算法3.2 k近邻模型3.2.1 模型3.2.2 距离度量3.2.3 k值的选择3.2.4 分类决策规则3.3 k近邻法的实现：kd树3.3.1 构造kd树3.3.2 搜索kd树第4章 朴素贝叶斯法4.1 朴素贝叶斯法的学习与分类4.1.1 基本方法4.1.2 后验概率最大化的含义4.2 朴素贝叶斯法的参数估计4.2.1 极大似然估计4.2.2 学习与分类算法4.2.3 贝叶斯估计第5章 决策树5.1 决策树模型与学习5.1.1 决策树模型5.1.2 决策树与if-then规则5.1.3 决策树与条件概率分别5.1.4 决策树学习5.2 特征选择5.2.1 特征选择问题5.2.2 信息增益5.2.3 信息增益比5.3 决策树的生成5.3.1 ID3算法5.3.2 C4.5的生成算法5.4 决策树的剪枝5.5 CART算法5.5.1 CART生成5.5.2 CART剪枝第6章 逻辑斯谛回归与最大熵模型6.1 逻辑斯谛回归模型6.1.1 逻辑斯谛分布6.1.2 二项逻辑斯谛回归模型6.1.3 模型参数估计6.1.4 多项逻辑斯谛回归6.2 最大熵模型6.2.1 最大熵原理6.2.2 最大熵模型的定义6.2.3 最大熵模型的学习6.2.4 极大似然估计6.3 模型学习的最优化算法6.3.1 改进的迭代尺度法6.3.2 拟牛顿法第7章 支持向量机7.1 线性可支持向量机与硬间隔最大化7.1.1 线性可支持向量机7.1.2 函数间隔和几何间隔7.1.3 间隔最大化7.1.4 学习的对偶算法7.2 线性支持向量机与软间隔最大化7.2.1 线性支持向量机7.2.2 学习的对偶算法7.2.3 支持向量7.2.4 合页损失函数7.3 非线性支持向量机与核函数7.3.1 核技巧7.3.2 正定核7.3.3 常用核函数7.3.4 非线性支持向量分类机7.4 序列最小最优化算法7.4.1 两个变量二次规划的求解方法7.4.2 变量的选择方法7.4.3 SMO算法第8 章 提升方法8.1 提升方法AdaBoost算法8.1.1 提升方法的基本思路8.1.2 AdaBoost算法8.1.3 AdaBoost的例子8.2 AdaBoost算法的训练误差分析8.3 AdaBoost算法的解释8.3.1 前分布算法8.3.2 前分布算法与AdaBoost8.4 提升树8.4.1 提升树模型8.4.2 提升树算法8.4.3 梯度提升第9章 EM算法及其推广9.1 EM算法的引入9.1.1 EM算法9.1.2 EM算法的导出9.1.3 EM算法在无监督学习中的应用9.2 EM算法的收敛性9.3 EM算法在高斯混合模型学习中的应用9.3.1 高斯混合模型9.3.2 高斯混合模型参数估计的EM算法9.4 EM算法的推广9.4.1 F函数的极大-极大算法9.4.2 GEM算法第10章 隐马尔可夫模型10.1 隐马尔可夫模型的基本概念10.1.1 隐马尔可夫模型的定义10.1.2 观测序列的生成过程10.1.3 隐马尔可夫模型的3个基本问题10.2 概率计算算法10.2.1 直接计算法10.2.2 前向算法10.2.3 后向算法10.2.4 一些概率与期望值的计算10.3 学习算法10.3.1 监督学习方法10.3.2 Baum-Welch算法10.3.3 Baum-Welch模型参数估计公式10.4 预测算法10.4.1 近似算法10.4.2 维特比算法第11章 条件随机场11.1 概率无向图模型11.1.1 模型定义11.1.2 概率无向图模型的因子分解11.2 条件随机场的定义与形式11.2.1 条件随机场的定义11.2.2 条件随机场的参数化形式11.2.3 条件随机场的简化形式11.2.4 条件随机场的矩阵形式11.3 条件随机场的概率计算问题11.3.1 向前-向后算法11.3.2 概率计算11.3.3 期望值的计算11.4 条件随机场的学习算法11.4.1 改进的迭代尺度法11.4.2 拟牛顿法11.5 条件随机场的预测算法监督学习方法总结第2篇 无监督学习第13章 无监督学习概论13.1 无监督学习基本原理13.2 基本问题13.3 机器学习三要素13.4 无监督学习方法第14章 聚类方法14.1 聚类的基本概念14.1.1 相似度或距离14.1.2 类或簇14.1.3 类与类之间的距离14.2 层次聚类14.3 k均值聚类14.3.1 模型14.3.2 策略14.3.3 算法14.3.4 算法特性第15章 奇异值分解15.1 奇异值分解的定义与性质15.1.1 定义与定理15.1.2 紧奇异值分解与截断奇异值分解15.1.3 几何解释15.1.4 主要性质15.2 奇异值分解的计算15.3 奇异值分解与矩阵近似15.3.1 弗罗贝尼乌斯范数15.3.2 矩阵的最优近似15.3.3 矩阵的外积展开式第16章 主成分分析16.1 总体主成分分析16.1.1 基本想法16.1.2 定义和导出16.1.3 主要性质16.1.4 主成分的个数16.1.5 规范化变量的总体主成分16.2 样本主成分分析16.2.1 样本主成分的定义和性质16.2.2 相关矩阵的特征值分解算法16.2.3 数据矩阵的奇异值分解算法第17章 潜在语义分析17.1 单词向量空间与话题向量空间17.1.1 单词向量空间17.1.2 话题向量空间17.2 潜在语义分析算法17.2.1 矩阵奇异值分解算法17.2.2 例子17.3 非负矩阵分解算法17.3.1 非负矩阵分解17.3.2 潜在语义分析模型17.3.3 非负矩阵分解的形式化17.3.4 算法第18章 概率潜在语义分析18.1 概率潜在语义分析18.1.1 基本想法18.1.2 生成模型18.1.3 共现模型18.1.4 模型性质18.2 概率潜在语义分析算法第19章 马尔可夫链蒙特卡罗法19.1 蒙特卡罗法19.1.1 随机抽样19.1.2 数学期望估计19.1.3 积分计算19.2 马尔可夫链19.2.1 基本定义19.2.2 离散状态马尔可夫链19.2.3 连续状态马尔科夫链19.2.4 马尔可夫链的性质19.3 马尔可夫链蒙特卡罗法19.3.1 基本想法19.3.2 基本步骤19.3.3 马尔可夫链蒙特卡罗与统计学习19.4 Metropolis-Hastings算法19.4.1 基本原理19.4.2 Metropolis-Hastings算法19.4.3 单分量Metropolis-Hastings算法19.5 吉布斯抽样19.5.1 基本原理19.5.2 吉布斯抽样算法19.5.3 抽样算法第20章 潜在狄利克雷分配20.1 狄利克雷分布20.2 潜在狄利克雷分配模型20.3 LDA的吉布斯抽样算法20.4 LDA的变分EM算法第21章 PageRank算法21.1 PageRank的定义21.1.1 基本想法21.1.2 有向图和随机游走模型21.1.3 PageRank的基本定义21.1.4 PageRank的一般定义21.2 PageRank的计算21.2.1 迭代算法21.2.2 幂法21.2.3 代数算法第22章 无监督学习方法总结22.1 无监督学习方法的关系和特点22.1.1 各种方法之间的关系22.1.2 无监督学习方法22.1.3 基础机器学习方法22.2 话题模型之间的关系和特点","link":"/2020/03/23/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"title":"计算物理--序","text":"教材 wiki Hoffmann 丁泽军 计算物理 张韵华 计算方法 tao pang 计算物理导论 四大力学，非线性物理，量子信息，随机物理，多体物理 讲义（无） 要求考核 $40\\%$作业$+40\\%$期末$+20\\%$project 期末 现场编程，八个题选四个 四大力学，量子，多体，随机过程…… 重点 计算+简单的物理 project paper+推导结果+simulation+论文 编程语言 mathematica matlab python c，c++，fortran 问题的分类 方程求根。$f(\\vec{x})=0$ 求面积，体积，积分。 \\int f(\\vec x) d \\vec x \\begin{align} Z &= Tr(e^{-\\beta H}) \\\\ & =\\int d \\vec x d \\vec p e^{-\\beta H(\\vec x , \\vec p)} \\end{align} 极值。$f’(\\vec x)=0$ 本征值(算子或者矩阵)。 随机过程。$m \\ddot{\\vec x} = -\\vec{F} + \\xi(\\vec r)$","link":"/2020/03/10/computational-physics-1/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/02/15/hello-world/"},{"title":"“量子霸权”","text":"“量子霸权”2月底，《MIT科技评论》发布了2020年“全球十大突破性技术”，其中之一“量子霸权”就是量子计算领域的突破。 量子计算是区别于经典数字计算的一种计算范式，它使用了量子力学现象例如叠加和纠缠来进行计算。经典的二进制数字计算机采用经典比特作为信息表示单元，同一时刻只能表示确定的信息（0或1状态），而量子计算机采用量子比特作为基础单元，可以表示状态的叠加。这样的量子比特可以用许多不同的物理方式实现，可以由单个原子、单个电子、单个光子或者复杂的系统（例如由很多电子构成的超导量子比特）承载表示。 量子计算的概念在上世纪80年代由费曼（Feynman)等人提出，“自然不是经典的，如果你想模拟自然，你最好让模拟是遵循量子力学规范的”，使用量子系统来模拟自然量子体系是更自然且有效的方式。随着Shor算法的提出，人们看到了量子计算的潜力，它可以在多项式时间内解决质因数分解问题，而这会给目前广泛使用的RSA加密算法带来威胁。在2001年，IBM的研究小组使用7量子比特的核磁共振（NMR）计算机演示了用Shor算法分解整数15，拉开了量子计算研究竞赛的序幕。 近年来，许多国家政府和研究机构都在资助量子计算研究，努力开发用于民用、商业、贸易、环境和国家安全目的的量子计算机。同时量子计算也吸引了资本的注意，许多知名公司和创业公司也参与其中，较著名的玩家有Google、IBM、Intel、Rigetti、IonQ等。 2019年10月，Google在Nature上发表了一篇文章，实验展示了称为悬铃木（Sycamore）超导量子计算处理器可以用200秒来实现一个量子电路的采样实例，而同样的任务在最先进的经典超级计算机上处理需要大约1万年，因此宣称实现了“量子霸权”（Quantum Supremacy）。“量子霸权”这个概念由John Preskill提出，量子计算装置在特定测试案例上表现出超越所有经典计算机的计算能力，没有现有的(或容易预见的)经典设备可以执行相同的任务，不管该任务在其它方面是否有用。 尽管IBM对Google取得的“量子霸权”结果有一些争议，同时Google的实验基准为一个特定的问题，商业用途非常有限，但不可否认的是这是一个量子计算的重要里程碑。有人将Google的实验与1903年12月莱特兄弟的第一次飞行作比较，它证明了量子加速在真实世界地系统中是可以实现的，显示了量子计算存在的潜力。 但目前的量子计算机距离可以执行有用的Shor算法还相距甚远，要运行包含数千个受保护的量子比特的算法，我们需要大量的物理量子逻辑，以百万计，甚至更多，而目前量子计算机的量子比特数量还没到达上百个。Google的研究者声称“量子霸权”的实现意味着噪声中间尺度的量子计算（NISQ）时代的到来。 在NISQ阶段中，量子计算机拥有的量子比特还比较少（大概50-100个），同时因为实现量子误差校正需要的开销很大，还未能实现纠错。这个阶段的量子计算机或许可以执行一些超越当今计算机能力的任务，但量子门中的噪声将限制可执行量子电路的大小。这个阶段的量子计算系统更多的是作为探究多体量子物理的有用工具，或者用于量子系统的模拟，这是量子计算机所擅长的，而目前经典计算机尚没有用于模拟量子动力学系统的良好算法。同时，采用混合量子-经典算法解决一些优化问题，例如量子近似优化算法（QAOA）、变分量子特征值求解算法（VQE），也得到了研究者的关注。还有很多NISQ阶段的应用设想，但是受限于量子比特数目和噪声，目前的量子计算平台还不能改变世界，商用化的案例还没有出现，短期的主要目标是为未来的更先进的量子设备铺平道路。 值得注意的是，不应该将量子计算机视为经典计算机的高级替代。John Preskill在提出NISQ概念的论文中指出，“经典计算和量子计算各自难以解决的问题是不同的，不能期望量子计算机可以解决经典计算机难以解决的NP-hard问题”。量子计算和经典计算各有其优势，可以解决的问题的范畴不同，量子计算在未来也许会与经典计算处于互补的状态。 目前，量子计算的发展专注于构建更低门错误率的量子硬件，这将有助于实现更大规模的量子电路，完成一些NISQ阶段的实用案例演示；同时更精确的量子比特错误率也将减少量子误差校正的开销，向实现量子纠错靠近。随着量子计算实用化进程的演变，量子计算研究成为了一个系统性的问题，既需要底层的物理实现，需要先进的材料和制造工艺，同时也需要精确的电子学控制系统，上层软件系统和量子算法的不断发展，这需要多学科人才的叉合作和更多相关人才的培养。 量子计算还处于发展开始的阶段，还需要完成更多阶段性的里程碑才能到达最后的终点，要实现量子计算的全部前景(例如使用Shor的因式分解算法)仍然需要技术飞跃来设计容错逻辑量子比特，这需要工程师和科学家继续不断优化芯片和硬件系统的设计。至于其应用，将在不断地在向前发展中涌现出来。各公司在未来将开发更多的云平台接口，完善软件、库、应用程序和用户社区，为算法研究者探索算法应用提供支持。 因为量子计算的巨大潜力，我国对量子计算的投入也不断增多。中国科学技术大学、清华大学、浙江大学、南京大学等大学，本源量子、阿里巴巴、腾讯、百度、华为等公司，还有鹏城实验室都开展了量子计算研究。但因为起步较晚，与国外还有一些差距。 量子计算机最终会对社会产生变革性的影响，这可能还需要几十年的时间，但近五到十年内，会涌现出越来越多的令人惊喜的结果，显示量子计算的能力。未来是光明的，道路是曲折的。我们还有很长的路要走，新的见解、发展和创新有可能极大地改变我们的前景。 参考资料 Preskill J. Quantum computing and the entanglement frontier[J]. arXiv preprint arXiv:1203.5813, 2012. Preskill J. Quantum Computing in the NISQ era and beyond[J]. Quantum, 2018, 2: 79. Arute F, Arya K, Babbush R, et al. Quantum supremacy using a programmable superconducting processor[J]. Nature, 2019, 574(7779): 505-510. Kjaergaard M, Schwartz M E, Braumüller J, et al. Superconducting qubits: Current state of play[J]. Annual Review of Condensed Matter Physics, 2019, 11. Nielsen M A, Chuang I. Quantum computation and quantum information[J]. 2002. https://quantumcomputingreport.com/our-take/our-take-on-quantum-supremacy/ https://quantumcomputingreport.com/our-take/after-quantum-supremacy-what-comes-next/ https://quantumcomputingreport.com/scorecards/qubit-count/ http://nautil.us/blog/physicists-say-googles-quantum-computer-is-still-far-from-practical https://www.stevenvanbelleghem.com/blog/what-quantum-computing-could-mean-for-customer-experience/ https://www.technologyreview.com/lists/technologies/2020/ https://en.wikipedia.org/wiki/Quantum_computing","link":"/2020/03/29/quantum%20supremacy/"},{"title":"论文修改意见","text":"ABSTRACT 先说了最近提出的一种gate model架构有什么，这个架构有什么作用（写得比较大概）。然后提出架构还应能支持波形补偿和波形标定。因此，文章提出了一种关于电极事件队列的用于超导控制的微架构。它有两个核心：1、电极事件操作单元。2、局部和全局事件的混合电路描述方法。（这里加上这个架构的效果如何，对上面提出问题的解决效果如何）（最后结束的两句话感觉有一些突兀，用FPGA实现可以放到前面，FPGA用缩写就可以） 总的来说，写得有些简略。可以再思考下重点和创新之处如何体现，可以对这些内容多叙述一些。 INTRODUCTION 这一段可以写得更详细一些。运用商用的设备会消耗很多的资源，不具备拓展性。所以现在大家用的都是自定义的专用超导芯片FPGA控制板，这已经部分解决了资源消耗大的问题。付祥的结构应该也是在这之后提出的，所以这个前因要改一下。可以加上目前大家都在用的控制方案，都解决的哪些问题。叙述好整个研究的背景，为后面的要解决的问题做铺垫。 这段以由于量子芯片的硬件限制，架构设计面临新的挑战开头。后面两大块应以硬件限制在哪里，以什么方式去解决的逻辑去说的。第二点，波形补偿段应该改下，这一段看起来就变成了简单的介绍这个方法有什么用，不是从问题提出到解决。可以叙述为串扰有什么影响，然后波形补偿可以如何解决。 it指代什么可以具体化。 可以调整一下叙述顺序，把具体的方法是什么放前面，再说这样的方法有什么效果。参照第一点。 RELATED WORKS distribued和centralized是形容词，可以加个form。开始说主要有两种处理器架构适配不同的语言，段尾又说一次，反复读感觉有些奇怪。 这段介绍了分布式结构，缺少了这样的结构有什么优势和问题。我觉得related works要有目的介绍，介绍的这些要对自己的主题有用，这些架构都有各自的优点，也有各自的缺点，它们又什么做不到的地方，而这些地方是我们架构可以做的，这就让人提起精神。这些虽然会在挑战那部分具体说，前面也需要提，一步步引导。如果只是简单的介绍，让人不太明白这一段跟整个文章又多少联系。 这段是如何与上面相关联的要叙述清楚。前两段分别介绍了分布式和集中式，这一段突然跳到高层抽象的特点，high-level abstration这个词之前没有出现和提到过，用As for得有些奇怪。 全局事件是可行的是本段的论点，可以放前面，更清晰一些。这两段的问题是如何与前面介绍的前人工作联系到一起的，可以说清楚。global event和global event operation用词可以统一一下，统一用一个词。 总的来说，related works结构有些松散，有哪些联系没有说清楚。可以将段间联系加强，变得有连续性。 MICROARCHITECTURAL CHALLENGESLimitations Of The Gate Model 这段介绍了gate model是什么，末尾提到这样的结构不支持波形补偿和波形参数标定。接下来的两部分具体介绍波形补偿和参数标定，讨论gate model为什么不能支持这两种操作。 Waveform compensation 电路模型的波形补偿增加指令数量，减少了电路并行性。可以统一一下说法，改为增加电路深度。因为后两段，说的是gate model在两种情况下考虑补偿所导致的需要描述的操作增加和电路深度的提高。X180这些表示，180放下标或上标可能比较好。另外，高亮这两个公式看不太懂。 Calibration experiment 因为存在噪声等因素，需要进行周期性的标定，这个标定过程不能用门描述完成。 Description Of High Gate Diversity Circuit在高门密度时，付祥的架构会遇到问题。但是一般的控制架构并没有问题，一般的控制架构只是执行测量实验时，波形较长。因此，文章中的gate model说的只是付祥的架构，用gate model来指代付祥的架构是否合适，还应该再考虑一下。如IBM的系统执行时，在qiskit语言编写阶段也是用门操作来描述的，只是后面转化为波形了。 QUANTUM MICROARCHITECTURE 这段介绍结构的大概文件流过程。 这段介绍量子指令集。叙述上，ebQIS包括经典指令和量子指令，经典指令有哪些。这里少了一句话，量子指令有哪些。并在figure 6中表现出来。 Electrode Based Quantum Operation Unit lower-level control具体指代什么。 这一整段看不懂。XYevent_1,XYevent_2在图上代表什么。有XY和Z操作为什么说是单电极事件。这两个例子是怎么和图片对上的。图片注释也需要加上说明上下两幅图都分别代表什么抽象。 Hybrid Event Description Scheme这一部分很长，叙述的结构可以修改一下，不然很难读下去。这部分目前的结构是，第一段说明需要全局事件和部分事件，第二段局域事件是什么和有什么用，第三段全局事件是什么有什么用，这是读者对局域事件和全局事件是什么并没有一个具体的认识。应该把对图10的说明提前，提到局域事件和全局事件的说明中，配合图一起说明，这样读者才容易对这两个概念产生具体的图像。然后再说这样的设定有说明作用，为什么可以用在不同的实验中。 图b左边是如何对应于右边的要说清楚。 XYevent_1、XYevent_2,3、XYevent_4，代表说明图中并没有相应的对应。这和前面的XYevent_1,XYevent_2是不是一个东西。 总的来说，Hybrid Event Description Scheme，这一段太长了，而且很多指代不明，不是按照图来说的，很难看懂。 Multi-level Compilation Scheme 这张图的图b可以改为上下并列的，并用相同的时间刻度，标上哪部分是XY电极执行的，哪部分是Z电极执行的。 这一段太长了，而且没有明显的分点分段突出，读不下去。和前面一样，可以多分段，多分点。 IMPLEMENTATIONfigure 15是不是和figure 5有些重复了。 implementation将微架构各小部件介绍了一遍。很多都是经典计算机中很成熟的东西，不用介绍那么多。我们没实际做过，这部分写起来就像写流水账一样。另外，注意分点。 EVALUATION 按照SG、MG、EB分段，把这些词放在段首，并斜体化。后面也要根据不同的讨论点分点分段。","link":"/2020/02/17/%E8%AE%BA%E6%96%87%E4%BF%AE%E6%94%B9%E6%84%8F%E8%A7%81/"},{"title":"量子线路","text":"计算机是物理的对象，而计算是物理的过程。计算机计算的范围完全由物理定律而不是纯数学决定 ———-David Deutsch 量子线路语言是描述量子算法有效和有力的描述方式，它包含描述计算过程的一组离散元件的集合。这个工具将使我们能够用类似于需要的门的总数或线路深度来量化算法的花销，也带来了一些简化算法设计的丰富技巧，并较容易从概念上形象的认识算法。 单量子比特计算单量子比特表示 |\\psi\\rangle = a|0\\rangle+b|1\\rangle \\qquad其中，复数a,b满足 \\quad{|a|}^2+|b|^2=1一些重要矩阵，Pauli矩阵： X\\equiv\\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix} , Y\\equiv\\begin{bmatrix} 0 & -i \\\\ i & 0 \\end{bmatrix} , Z\\equiv\\begin{bmatrix} 1 & 0 \\\\ 0 & -1 \\end{bmatrix}Hadamard门、Phase gate和$\\pi/8$门： H=\\frac{1}{\\sqrt{2}}\\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix} , S=\\begin{bmatrix} 1 & 0 \\\\ 0 & i \\end{bmatrix} , T=\\begin{bmatrix} 1 & 0 \\\\ 0 & exp(i\\pi/4) \\end{bmatrix}旋转算子定义如下： 练习4.1受控运算本节说明，如何从基本运算基础搭建起来的量子线路实现复杂的受控运算。 CNOT 相当于$|c\\rangle|t\\rangle \\rightarrow |c\\rangle|t\\bigoplus c\\rangle$ controlled-U 相当于$|c\\rangle |t\\rangle \\rightarrow |c\\rangle U^c |t\\rangle$ 测量量子线路测量有两个重要原理值得记住。 _推迟测量原理(principle of deferred measurement)_总可以把测量从量子线路的中间步骤移到线路的末端；如果测量的结果被用于线路的某些阶段，则经典的运算可以被条件量子运算代替。 \\langle !— more —&gt; 隐含测量原理（principle of implicit measurement)不失一般性，量子线路中任何未终结的量子连线（未被测量的量子比特）总可以假设为被测量。 测量的一个普遍特点——为使一个测量是可逆的，它一定不能揭示被测量子状态的任何信息 通用量子门Two-level unitary gates are universal 对于作用在d维Hilbert空间上的酉矩阵U，可以分解非两级酉矩阵的乘积，即只不平凡地作用在向量的一个或两个分量上的酉矩阵， Single qubit and CNOT gates are universal 单量子比特门和受控非门可以实现n量子比特状态空间上的任意两级酉运算。因此，结合前一条结论，单量子比特门和受控非门可以实现n量子比特状态空间上的任意酉运算，于是它们对量子计算是通用的。 A discrete set of universal operations 门的离散集合不可能精确实现任意的酉运算，因为酉运算的集合是连续的。然而，可以用一个离散的集合去近似任意的酉运算。 Hadamard + phase + CNOT + π/8 是一个通用门集合。 但是要注意的是近似任意酉门通常是难的。 量子线路模型的关键要素 经典资源。量子计算机包括两部分，经典计算部分和量子计算部分。在计算中允许部分计算以经典的方式进行，某些任务的完成将容易得多。 适当的状态空间。量子线路在某个数目为n的量子比特组上进行操作，因此状态空间是$2^n$维复Hilbert空间。积形式$|x_1,\\cdots,x_n\\rangle$，其中$x_i = 0,1$的状态称为计算机的计算基态。$|x\\rangle$表示一个计算基态，其中$x$是二进制表示为$x_1 \\cdots x_n$的数。 将状态置于计算基中的能力。假设任何的计算基态$|x_1,\\cdots,x_n\\rangle$可以在至多n步内制备出来。 进行量子门运算的能力。门可以随意应用到量子比特的任意子集，并可以实现一组通用门。例如，在量子计算机上可以把受控非门用到任何一对量子比特上，Hadamard门、相位、受控非门和$\\pi/8$门构成一组可以近似任意酉运算的门，因此是一组通用门，还存在其他的通用类。 在计算基中测量的能力，计算机中可以进行在计算基中一个或多个量子比特的测量。 量子系统的仿真仿真原理用经典计算机模拟量子系统是可能的，但一般而言不是很有效。许多简单量子系统的动态行为服从Schrodinger方程 i\\hbar \\frac{d}{dt} | \\psi\\rangle = H | \\psi\\rangle我们常常将$\\hbar$放入$H$中。对于一个研究空间中实际粒子的物理学家感兴趣的Hamilton量，这个方程可以简化为 i\\frac{\\partial}{\\partial t} \\psi(x) = [-\\frac{1}{2m}\\frac{\\partial^2}{\\partial x^2} + V(x)]\\psi(x)其中使用了称为位置表示的约定$\\langle x|\\psi\\rangle = \\psi (x)$。 仿真Schrodinger方程并不是模拟量子系统中面临的特殊困难。模拟量子系统的关键挑战是，必须求解的微分方程为指数数目。对$n$量子比特的系统，必须求解$2^n$个方程。有时具有洞察力的近似可以减少方程个数，从而使这种量子系统的经典仿真成为可行。然而，有许多物理上有意义的量子系统，人们尚不知道它们的这类近似。 量子仿真算法量子仿真算法的核心是渐近近似定理。 (Trotter公式) 令$A$和$B$是Hermite算子，则对任意实数$t$，有 {\\lim_{n \\to +\\infty}}(e^{iAt/n}e^{iBt/n})^n = e^{i(A+B)t/n}注意，即使对$A$和$B$不对易的情况也是成立的。 算法 量子仿真 输入 （1）作用在N维系统上的Hamilton量$H = \\sum_{k} H_k$，其中每个$H_k$作用在规模独立于N的小的子系统上；（2）系统在$t=0$时刻的初态$| \\psi_0\\rangle$；（3）正的非零精度$\\delta $；（4）获得期望状态的时间$ t_f $。 输出 状态$|\\widetilde{\\psi}(t_f)\\rangle$，使得$|\\langle \\widetilde{\\psi}(t_f)|e^{-iHt_f}|\\psi_0\\rangle|^2 \\geq 1-\\delta$。 运行时间 $O(poly(1/\\delta))$数目的操作。 过程 选择一个表示，使得$n=poly(logN)$量子比特的状态$| \\widetilde{\\psi}\\rangle$能近似系统状态，且算子$e^{-iH_k \\Delta t}$有有效的量子线路近似。选择一个近似方法和$\\Delta$，使得期望误差是可接受的（并且对某个整数$j$，$j\\Delta t = t_f$），为迭代构造一个相应的量子线路$ U_{\\Delta t}$，并且执行： $|\\widetilde{\\psi}_0\\rangle \\leftarrow |\\psi_0\\rangle$；$j=0$ //状态初始化 $\\rightarrow |\\widetilde{ {\\psi} }_{j+1}\\rangle =U_{\\Delta}|\\widetilde{ {\\psi} }_{j}\\rangle$ //迭代更新 $\\rightarrow j=j+1$，转到（2）直到$j\\Delta t \\geq t_f$ //循环 $\\rightarrow |\\widetilde{\\psi}(t_f)\\rangle = |\\widetilde{\\psi}_{j}\\rangle$ //最终结果","link":"/2020/02/17/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF/"},{"title":"链接整理","text":"常用谷歌学术镜像 Wiki百科镜像 量子计算quantumcomputingreport Andrew M. Childs 量子计算讲义John PreskillQIP’23 蔻享学术视频 TensorNetworkTensorNetworkgoogle/TensorNetwork 计算机dblp: computer science bilbliography","link":"/2020/02/17/%E9%93%BE%E6%8E%A5%E6%95%B4%E7%90%86/"},{"title":"compiling SU(4) quantum circuits","text":"一篇文章，研究了如何在IBM的设备上实现$SU(4)$门。 Compiling SU(4) Quantum Circuits to IBM QX Architectures. http://iic.jku.at/eda/research/ibm_qx_mapping/ 这包含两个步骤，先把操作分解到设备提供的基础门操作上，再将操作mapping到实际的物理比特上。已经有了一些分解的方案被提出，更关键也更难的步骤是mapping。 背景IBM的QX芯片结构 IBM的设备支持两种门 $U(\\theta,\\phi,\\lambda)=R_z(\\phi)R_y(\\theta)R_z(\\lambda)$ CNOT 其它所有操作都由这两种操作构成。 IBM QX backend information. https://github.com/QISKit/ibmqx-backend-information. CNOT门只能应用于由总线谐振器连接的量子位。此外，只有低频的量子位可以作为目标，只有高频的量子位可以作为控制。这些限制在所谓的耦合映射中进行了总结。 IBM QX Devices. https://quantumexperience.ng.bluemix.net/qx/devices. CNOT操作保真度比单个量子门要小10倍。正因为如此，使CNOT门的数量尽可能少是极其重要的。 分解SU(4)在电路的每一层，可用的量子比特被随机分组成两对一组(如果它们的数目是偶数)。然后对每一对比特，从SU(4)中随机的选择两比特操作执行。因为这些两比特操作在IBM QX架构上是不可执行的，所以需要进行分解。 文章采用的是KAK-decomposition F. Vatan and C. Williams. Optimal quantum circuits for general two-qubit gates.Physical Review A, 69(3):032315, 2004. 将这两比特门分解成3个CNOT和7个单比特门的序列。 考虑的问题如何有效的对分解得到的线路进行编译，mapping到IBM QX架构上执行。 第一步量子电路中的操作必须被分解成在目标硬件上可用的基本操作。 在文献中，有很多这样的方法，分解到一些门集上，例如Clifford+T、NCV library。 M. Amy, D. Maslov, M. Mosca, and M. Roetteler. A meet-in-the-middle algorithmfor fast synthesis of depth-optimal quantum circuits. IEEE Trans. on CAD ofIntegrated Circuits and Systems, 32(6):18–830, 2013. K. Matsumoto and K. Amano. Representation of quantum circuits with Cliffordand π/8 gates. arXiv preprint arXiv:0806.3834, 2008. D. M. Miller, R. Wille, and Z. Sasanian. Elementary quantum gate realizationsfor multiple-control Toffolli gates. In Int’l Symp. on Multi-Valued Logic, pages288–293, 2011. R. Wille, M. Soeken, C. Otterstedt, and R. Drechsler. Improving the mapping ofreversible circuits to quantum circuits using multiple target lines. In Asia andSouth Pacific Design Automation Conf., pages 85–92, 2013. 第二步就是通常所说的mapping问题，没有较好的通用方法。 思路已经有很多文献考虑了将量子线路mapping到实际的物理设备。但是大部分都只考虑到最近邻约束，或者mapping特殊的量子线路。在相应的最近邻体系结构中，2-量子位门可以应用于任何相邻的量子位，也可以应用于任何想要的方向——显然违反了由耦合映射表示的IBM QX体系结构。此外，以前提出的许多方法只适用于数量非常有限的量子位(甚至比IBM已经提供的16个量子位还要少)。 相比之下，很少有方法能将量子电路的逻辑比特映射到IBM QX架构的物理比特。 A. Zulehner, A. Paler, and R. Wille. An efficient methodology for mappingquantum circuits to the IBM QX architectures. IEEE Trans. on CAD of IntegratedCircuits and Systems, 2018 这是他们之前发表的一篇论文，已经可以mapping到IBM QX架构上了，通过更大的搜索空间和附加信息得到比IBM编译器更好的效果。 然而，这种方法很难适用于SU(4)电路。 这个解决方案基于这样一个主要思想:首先把电路分成几层gates，然后确定每一层满足所有物理特性的排列。即需要一层一层的考虑。 SU(4)电路由多层门组成，这些门通常包含$n/2$种不同的CNOT配置(n是比特的数目)。这基本上是最坏的情况，因为层中使用的CNOT门越多，量子比特的排列就必须满足越多的约束。 方法为了克服他们之前提出的方法的局限性，同时保持前瞻性方案的可用性，他们打破了基于分层的方法，并单独考虑每个门。 Pre-Process-Grouping Gates可以看到每个SU(4)都一组对一对比特的操作，只要两比特门可以执行，一组操作都可以执行，所以论文采用这样的分组方式，形成有向无环图。 Solving the Mapping Problem对于这样的一个有向无环图，没有前驱，第一层即初始mapping可以任取。 随后的mapping由两个步骤组成 如果后续的层中，有组可以直接在上面的mapping中执行，也可以直接添加到编译中。 根据优先级确定接下来可以执行的组$G_{next}$，它们的前驱需要是已经编译的。然后，映射算法的任务是确定一个新的映射(通过插入交换门)以满足$G_{next}$中至少一个门组的物理约束。 因为mapping搜索空间很大，为$m!$，采用$A^*$搜索算法来避免搜索整个空间。 Post-Mapping Optimization在满足目标架构给出的物理约束之后，为了进一步降低编译电路的成本，最后采用了一个专门的后mapping优化。","link":"/2020/04/05/compiling-SU-4-quantum-circuits/"},{"title":"computational physics 5","text":"量子化一次量子化与二次量子化一次量子化，坐标量子化，$[x,p]=i \\hbar$ 二次量子化，波函数量子化 与哈密顿正则方程的类比 \\left\\{\\begin{array}{l} \\frac{d p}{d t}=-\\frac{\\partial H}{\\partial q} \\\\ \\frac{d q}{d t}=\\frac{\\partial H}{\\partial p} \\end{array}\\right.写成泊松括号形式 \\left\\{\\begin{array}{l} \\frac{d p}{d t}=\\{q, H\\} \\\\ \\frac{d q}{d t}=\\{p, H\\} \\end{array} \\Rightarrow\\left\\{\\begin{array}{c} \\left\\{q_{i}, q_{j}\\right\\}=0,\\left\\{p_{i}, p_{j}\\right\\}=0 \\\\ \\left\\{q_{i}, p_{j}\\right\\}=\\delta_{i, j} \\end{array}\\right.\\right.对波函数量子化 \\left\\{\\begin{array}{c} i \\frac{\\partial \\psi}{\\partial t}=H \\psi \\\\ \\psi=\\sum_{n} c_{n}(t)\\left|\\phi_{n}\\right\\rangle \\end{array} \\Rightarrow\\left\\{\\begin{array}{c} E=\\langle\\psi|H| \\psi\\rangle=\\sum_{n m} t_{n m} c_{n}^{*} c_{m} \\\\ i \\dot{c}_{n}=\\sum_{m} c_{m}\\left\\langle\\phi_{n}|H| \\phi_{m}\\right\\rangle=\\sum_{m} t_{n m} c_{m} \\end{array} \\Rightarrow\\left\\{\\begin{array}{l} i \\dot{c}_{n}=\\frac{\\partial E}{\\partial c_{n}^{*}} \\\\ i \\dot{c}_{n}^{*}=-\\frac{\\partial E}{\\partial c_{n}} \\end{array}\\right.\\right.\\right.类比有，$c_{n} \\sim q, c_{n}^{} \\sim p$，将$c_n,c_n^{}$提升到算符$c_n,c_n^{\\dagger}$ \\left\\{c_{n}, c_{m}\\right\\}=\\left\\{c_{n}^{\\dagger}, c_{m}^{\\dagger}\\right\\}=0,\\left\\{c_{n}, c_{m}^{\\dagger}\\right\\}=\\delta_{n m}等价描述 \\{\\psi, \\psi\\}=\\left\\{\\psi^{\\dagger}, \\psi^{\\dagger}\\right\\}=0,\\left\\{\\psi(x), \\psi^{\\dagger}(y)\\right\\}=\\delta(x-y)波函数量子化和$[x,p]=i \\hbar$是同一回事 二次量子化重新表示态，将一个多粒子态定义为 \\left|n_{1}, n_{2}, \\cdots, n_{i}, \\cdots\\right\\rangle该空间称为Fock空间，需要关注其置换对称性 先定义两种特殊情况 |0,0, \\cdots, 0, \\cdots\\rangle \\equiv|\\mathbf{0}\\rangle \\left|0,0, \\cdots, n_{i}=1, \\cdots\\right\\rangle \\equiv\\left|k_{i}\\right\\rangle再定义“场算符”$a_i^{\\dagger}$，它使本征值为$k_i$的态上的粒子数增加一个 a_{i}^{\\dagger}\\left|n_{1}, n_{2}, \\cdots, n_{i}, \\cdots\\right\\rangle \\propto\\left|n_{1}, n_{2}, \\cdots, n_{i}+1, \\cdots\\right\\rangle假设已经归一化，粒子产生算符作用于真空 a_{i}^{\\dagger}|\\mathbf{0}\\rangle=\\left|k_{i}\\right\\rangle有 \\begin{aligned} 1=\\left\\langle k_{i} | k_{i}\\right\\rangle &=\\left[\\langle\\mathbf{0}| a_{i}\\right]\\left[a_{i}^{\\dagger}|\\mathbf{0}\\rangle\\right] \\\\ &=\\left\\langle\\mathbf{0}\\left|\\left[a_{i} a_{i}^{\\dagger}|\\mathbf{0}\\rangle\\right]=\\left\\langle\\mathbf{0}\\left|a_{i}\\right| k_{i}\\right\\rangle\\right.\\right. \\end{aligned}意味着 a_i | k_i \\rangle = | \\mathbf{0 } \\rangle$a_i$起到了粒子湮灭算符的作用。 置换两粒子 a_{i}^{\\dagger} a_{j}^{\\dagger}|\\mathbf{0}\\rangle=\\pm a_{j}^{\\dagger} a_{i}^{\\dagger}|\\mathbf{0}\\rangle$+(-)$分别对玻色子(费米子)成立。 因此对玻色子(费米子)分别有 \\begin{array}{l} a_{i}^{\\dagger} a_{j}^{\\dagger}-a_{j}^{\\dagger} a_{i}^{\\dagger}=\\left[a_{i}^{\\dagger} \\cdot a_{j}^{\\dagger}\\right]=0 \\\\ a_{i}^{\\dagger} a_{j}^{\\dagger}+a_{j}^{\\dagger} a_{i}^{\\dagger}=\\left\\{a_{i}^{\\dagger}, a_{j}^{\\dagger}\\right\\}=0 \\end{array}验证所有的对易关系，有表格 玻色子 a_i^{\\dagger}a_j^{\\dagger}-a_j^{\\dagger}a_i^{\\dagger} = [a_i^{\\dagger},a_j^{\\dagger}]=0 \\\\ a_i a_j-a_j a_i = [a_i,a_j]=0 \\\\ a_i a_j^{\\dagger} - a_j^{\\dagger} a_i = [a_i,a_j^{\\dagger}]=\\delta_{ij}费米子 a_i^{\\dagger}a_j^{\\dagger}+a_j^{\\dagger}a_i^{\\dagger} = \\{a_i^{\\dagger},a_j^{\\dagger}\\}=0 \\\\ a_i a_j+a_j a_i = \\{a_i,a_j\\}=0 \\\\ a_i a_j^{\\dagger} + a_j^{\\dagger} a_i = \\{a_i,a_j^{\\dagger}\\}=\\delta_{ij}还可定义粒子数算符 N = \\sum_i a_i^{\\dagger}a_i算符的二次量子化单粒子算符 \\boldsymbol{K}=\\sum_{m n} b_{m}^{\\dagger} b_{n}\\left\\langle l_{m}|K| l_{n}\\right\\rangle多粒子算符，由于粒子间存在相互作用，设对称实矩阵$V_{ij}$确定处于单粒子态$|k_i \\rangle$和$| k_j \\rangle$的两个粒子之间的相互作用的本征值。算符的二次量子化版本为 \\mathcal{V}=\\frac{1}{2} \\sum_{i \\neq j} V_{i j} N_{i} N_{j}+\\frac{1}{2} \\sum_{i} V_{i i} N_i\\left(N_{i}-1\\right)第一项为所有两粒子相互作用，第二项为处于相同态粒子间的自相互作用。为$C_n^2$。 可以更简单的表示为 \\mathcal{V}=\\frac{1}{2} \\sum_{i j} V_{i j}\\left(N_{i} N_j-N_{i} \\delta_{i j}\\right)=\\frac{1}{2} \\sum_{i j} V_{i j} \\Pi_{i j}其中$\\Pi_{i j} \\equiv N_iN_j - N_i \\delta_{ij}$，称为分布算符 \\begin{aligned} \\Pi_{i j} &=a_{i}^{\\dagger} a_j a_{j}^{\\dagger} a_{j}-a_{i}^{\\dagger} a_{i} \\delta_{i j} \\\\ &=a_{i}^{\\dagger}\\left(\\delta_{i j} \\pm a_{j}^{\\dagger} a_{i}\\right) a_{j}-a_{i}^{\\dagger} a_{i} \\delta_{i j} \\\\ &=\\pm a_{i}^{\\dagger} a_{j}^{\\dagger} a_{i} a_{j} \\end{aligned}所以有 \\mathcal{V}=\\frac{1}{2} \\sum_{i j} V_{i j} a_{i}^{\\dagger} a_{j}^{\\dagger} a_{j} a_{i} \\mathcal{V}=\\frac{1}{2} \\sum_{m m pq}\\langle m n|V| p q\\rangle b_{m}^{\\dagger} b_{n}^{\\dagger} b_{q} b_{p}其中 \\langle m n|V| p q\\rangle \\equiv \\sum_{i j} V_{i j}\\left\\langle l_{m} | k_{i}\\right\\rangle\\left\\langle k_{i} | l_{p}\\right\\rangle\\left\\langle l_{n} | k_{j}\\right\\rangle\\left\\langle k_{j} | l_{q}\\right\\rangleTight-binding model H=- \\frac{1}{2m} \\frac{\\partial ^2}{\\partial x^2} +V(kx)局域波函数 | \\psi \\rangle = \\sum_n C_n | \\phi(x) \\rangle周期性 | \\phi_n (x) \\rangle = |\\phi(x-na) \\rangle粒子化有 H=\\sum_{n} t\\left[c_{n}^{\\dagger} c_{n+1}+\\mathrm{h.c.}\\right]+\\mu c_{n}^{\\dagger} c_{n} \\begin{pmatrix} \\cdots & C^{\\dagger}_1 & C^{\\dagger}_0 & C^{\\dagger}_{-1} & \\cdots \\end{pmatrix} \\begin{pmatrix} \\ddots & & & & \\\\ t & \\mu+\\varepsilon_{-1} & t & & \\\\ & t & \\mu+\\varepsilon_{-0} & t & \\\\ & & t & \\mu+\\varepsilon_{1} & t \\\\ & & & & \\ddots \\end{pmatrix} \\begin{pmatrix} \\vdots \\\\ C_1 \\\\ C_0 \\\\ C_{-1} \\\\ \\vdots \\end{pmatrix}根据平移对称性，做傅里叶变换 c_{n}=N^{-1 / 2} \\sum_{k} c_{k} e^{i k R_{n}} \\Rightarrow H=\\sum_{n}(2 t \\cos k+\\mu) c_{k}^{\\dagger} c_{k}推导技巧有$\\sum_n e^{ikR_n} = N \\delta_{k,0}$ Hubbard model H = \\frac{p^2}{2m} + \\frac12 m \\omega^2 x^2 + \\alpha x^4 \\qquad \\alpha \\rightarrow 0其中假设 H_0 = \\frac{p^2}{2m} + \\frac12 m \\omega^2 x^2 = \\hbar \\omega(a^{\\dagger}a+\\frac12)反推 a^{\\dagger}a+\\frac12 = (\\sqrt{\\frac{m \\omega}{2 \\hbar}x})^2-(\\frac{ip}{\\sqrt{2 m \\hbar\\omega}})^2 a =\\sqrt{\\frac{m \\omega}{2 \\hbar}x} \\pm \\frac{ip}{\\sqrt{2 m \\hbar\\omega}} \\\\ a^{\\dagger} = \\sqrt{\\frac{m \\omega}{2 \\hbar}x} \\mp \\frac{ip}{\\sqrt{2 m \\hbar\\omega}}注意，其中蕴含了$[x,p]=i \\hbar$。 有 x=\\sqrt{\\frac{\\hbar}{2 m \\omega}}(a+a^{\\dagger})代入$H$ H=\\hbar \\omega(a^{\\dagger}a+\\frac12)+ \\alpha (\\frac{\\hbar}{2 m \\omega})^2(a+a^{\\dagger})^4位移$x \\rightarrow x \\sim a+a^{\\dagger},H(x) \\rightarrow H(a,a^{\\dagger})$。 场$\\phi \\rightarrow \\phi \\sim (a,a^{\\dagger}),H(\\phi) \\rightarrow H(a,a^{\\dagger})$。 a|n \\rangle = \\sqrt n |n-1 \\rangle \\\\ a^{\\dagger}|n \\rangle = \\sqrt{n+1} |n+1 \\rangle注意$x^4 \\sim (a+a^{\\dagger})^4$项 展开有几个因子 a^4,a^3 a^{\\dagger},a^2{a^{\\dagger}}^2,a{a^{\\dagger}}^3,{a^{\\dagger}}^4注意项$a^2{a^{\\dagger}}^2$ a^2{a^{\\dagger}}^2=aaa^{\\dagger}a^{\\dagger}=a(n+1)a^{\\dagger}=(n+1)^2=()n^2+()n+c$()n^2$即为Hubbard $U$，表示为$Un^2$或$Un_i n_j$ 推导Hubbard model相互作用$g \\delta(x-y)$ H= \\int \\phi^{\\dagger}[\\frac{p^2}{2m}+u(x)]\\phi +g \\int \\phi^{\\dagger}\\phi^{\\dagger}\\phi\\phi dx场量子化$\\phi = \\sum_n C_n \\psi_n$，$\\psi_n(x)$位于$x=na$ [\\phi(x),\\phi(y)]=0 \\\\ [\\phi(x),\\phi^{\\dagger}(y)] = \\delta(x,y)Fermi-Hubbard model作业作业11计算$H$的本征值 \\begin{aligned} H &=H_0+V \\\\ H_0 &= \\hbar w\\left(a^{\\dagger} a+\\frac{1}{2}\\right) \\\\ V &=\\alpha\\left(\\frac{\\hbar}{2 m w}\\right)^{2}\\left(a+a^{\\dagger}\\right)^{4} \\end{aligned} H|\\phi\\rangle=E|\\phi\\rangle,H_{0}|n\\rangle=\\varepsilon_{n}|n\\rangle,|\\phi\\rangle=\\sum_{n} c_{n}|n\\rangle作业12推导Fermi-Hubbard model(spinless)的$Un_i n_{i+1}$项。 推导Fermi-Hubbard model(spinful)的$U n_{i \\uparrow} n_{i \\downarrow}$项。 作业13计算Fermi-Hubbard model(spinless)的能谱： a.$L=10,N=5$ b.$L=14,N=5$ 作业14计算Bose-Hubbard model的能谱：$L=10,N=5,Q=3$","link":"/2020/04/12/computational-physics-5/"},{"title":"量子线路模拟","text":"什么是量子线路模拟？这里说的量子线路模拟是指用经典计算机来模拟量子线路。即模拟量子线路运行过程，给出理论计算结果。整个过程可以简单描述为，构建量子线路，输入初态，经过中间的运算模拟，最终采样得到末态。 一般来说，模拟量子线路是困难的，因为随线路规模指数增加的描述空间，这是由量子计算的基本概念，如叠加、纠缠等带来的，无法避免。 研究量子线路模拟主要有两个目的。 给出一个经典计算模拟量子计算所能到达的阈值。在NISQ阶段\\cite{preskill2018quantum}，展示“量子霸权”，证明量子计算机具有经典计算机无法处理的计算能力\\cite{preskill2012quantum}。常用的评估标准为随机量子线路(RQCs)\\cite{boixo2018characterizing,bouland2018quantum}。这样的计算需要在超算上运行，有很多的研究者进行了这样的模拟。\\cite{guo2019general,pednault2017breaking,haner20175,chen2018classical,chen201864} 用于开发研究。由于量子计算机的物理实现还处于起步阶段，这一领域的大量研究仍然依赖与传统计算机上的量子计算模拟。模拟平台的建立，允许研究者对算法进行验证和调试，并探索软硬件协同设计，以指导量子硬件和体系结构的开发。\\cite{khammassi2017qx,steiger2018projectq,wecker2014liqui} 不同的模拟方法模拟量子线路有一些不同的方法。 基于数组的模拟方法。这是最早期使用的，也是最直接的方法，使用一维数组和矩阵来描述量子态和操作，线路执行过程就是矩阵的直接运算。这会产生指数级的复杂性，因此需要开发并行性和应用大量的硬件计算能力(如由数千个节点和超过1拍字节的分布式内存组成的超级计算机)来处理。这样的模拟方式会很快的受限于量子系统的大小。 \\cite{green2013quipper,haner2016high,khammassi2017qx,pednault2017breaking,smelyanskiy2016qhipster,steiger2018projectq,wecker2014liqui} 基于决策图模型的模拟方法。在基于数组模拟方法的基础上，观察到一些表示空间上的冗余，考虑利用冗余来解决模拟量子计算的指数复杂性。使用了决策图模型来模拟量子计算，利用性质，给出对矩阵和向量自然的分解方案，让量子态和量子操作的表示更紧凑。得到了相比于基于数组模拟方法更优的模拟器。 \\cite{viamontes2009quantum,hiraishi2014bdd,niemann2015qmdds,samoladas2008improved} 基于张量网络模型的模拟方法。上面的方法都将量子态作为向量储存，由于希尔伯特空间的指数增长，会受限于量子比特数目的限制。而基于张量的方法，将量子态表示为张量，将纠缠信息隐含在网络结构中，模拟器的经典计算复杂度会直接与底层量子电路的纠缠产生相关，而与量子比特或单比特门的运算数目无关。是一种更适合的描述量子线路的方法。 \\cite{mccaskey2018validating,guo2019general} 量子计算模拟技术的提升也带来了“量子霸权”标准的提高，量子计算机也需要与不断发展的经典计算竞争。 模拟平台对于经典计算机所能模拟的量子线路上限，即“量子霸权”边界的探究，需要用于经典计算的强大算力-超算。但一般的研究者还用不到这样昂贵且不方便使用的计算资源。 如今虽然不是所有的量子软件平台都提供与真正量子计算机的连接，但许多平台都包含了量子线路模拟器。这是一个运行在经典CPU上的模拟程序，模拟器的性能参数为可模拟的量子比特状态数、执行时间、可添加的噪声等。 下面简单介绍几个常见的模拟器平台： pyQuil：它是Rigetti提供的量子计算编程框架，其中的模拟器叫量子虚拟机（QVM），不运行在用户本机计算机上，而是为用户提供一个API接口，利用云上的计算资源来运行。QVM的特点是包含复杂灵活的噪声模型，用户可以定义任意的噪声模型来测试程序，特别是定义噪声门、添加退相干噪声和模型读出噪声。\\cite{computing2019pyquil} Qiskit: Qiskit可以有多个量子模拟器作为后端选择，分别集成了不同的模拟技术。酉模拟器实现了基本的(酉)矩阵乘法，直接储存完整的信息，内存增长很快。状态矢量模拟器不存储完整的酉矩阵，只存储状态矢量和单/多量子位门。适用于不同的线路模拟。\\cite{aleksandrowicz2019qiskit} ProjectQ: ProjectQ，一个用于量子计算的开源软件。该框架能够针对各种类型的硬件，并具有仿真功能的高性能模拟器。它的高性能量子模拟器可以在单个门级上模拟量子程序。因为较好的优化，是表现较好的c++模拟器。 \\cite{steiger2018projectq} 文章列表@article{preskill2018quantum, title={Quantum Computing in the NISQ era and beyond}, author={Preskill, John}, journal={Quantum}, volume={2}, pages={79}, year={2018}, publisher={Verein zur F{\\”o}rderung des Open Access Publizierens in den Quantenwissenschaften}} @article{preskill2012quantum, title={Quantum computing and the entanglement frontier}, author={Preskill, John}, journal={arXiv preprint arXiv:1203.5813}, year={2012}} @article{boixo2018characterizing, title={Characterizing quantum supremacy in near-term devices}, author={Boixo, Sergio and Isakov, Sergei V and Smelyanskiy, Vadim N and Babbush, Ryan and Ding, Nan and Jiang, Zhang and Bremner, Michael J and Martinis, John M and Neven, Hartmut}, journal={Nature Physics}, volume={14}, number={6}, pages={595—600}, year={2018}, publisher={Nature Publishing Group}} @article{bouland2018quantum, title={Quantum supremacy and the complexity of random circuit sampling}, author={Bouland, Adam and Fefferman, Bill and Nirkhe, Chinmay and Vazirani, Umesh}, journal={arXiv preprint arXiv:1803.04402}, year={2018}} @inproceedings{green2013quipper, title={Quipper: a scalable quantum programming language}, author={Green, Alexander S and Lumsdaine, Peter LeFanu and Ross, Neil J and Selinger, Peter and Valiron, Beno{\\^\\i}t}, booktitle={Proceedings of the 34th ACM SIGPLAN conference on Programming language design and implementation}, pages={333—342}, year={2013}} @inproceedings{haner2016high, title={High performance emulation of quantum circuits}, author={H{\\”a}ner, Thomas and Steiger, Damian S and Smelyanskiy, Mikhail and Troyer, Matthias}, booktitle={SC’16: Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis}, pages={866—874}, year={2016}, organization={IEEE}} @inproceedings{khammassi2017qx, title={QX: A high-performance quantum computer simulation platform}, author={Khammassi, Nader and Ashraf, Imran and Fu, Xiang and Almudever, Carmen G and Bertels, Koen}, booktitle={Design, Automation \\&amp; Test in Europe Conference \\&amp; Exhibition (DATE), 2017}, pages={464—469}, year={2017}, organization={IEEE}} @article{steiger2018projectq, title={ProjectQ: an open source software framework for quantum computing}, author={Steiger, Damian S and H{\\”a}ner, Thomas and Troyer, Matthias}, journal={Quantum}, volume={2}, pages={49}, year={2018}, publisher={Verein zur F{\\”o}rderung des Open Access Publizierens in den Quantenwissenschaften}} @article{wecker2014liqui, title={LIQUi|&gt;: A software design architecture and domain-specific language for quantum computing}, author={Wecker, Dave and Svore, Krysta M}, journal={arXiv preprint arXiv:1402.4467}, year={2014}} @inproceedings{haner20175, title={5 petabyte simulation of a 45-qubit quantum circuit}, author={H{\\”a}ner, Thomas and Steiger, Damian S}, booktitle={Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis}, pages={1—10}, year={2017}} @article{chen2018classical, title={Classical simulation of intermediate-size quantum circuits}, author={Chen, Jianxin and Zhang, Fang and Huang, Cupjin and Newman, Michael and Shi, Yaoyun}, journal={arXiv preprint arXiv:1805.01450}, year={2018}} @article{li2018quantum, title={Quantum supremacy circuit simulation on Sunway TaihuLight}, author={Li, Riling and Wu, Bujiao and Ying, Mingsheng and Sun, Xiaoming and Yang, Guangwen}, journal={arXiv preprint arXiv:1804.04797}, year={2018}} @article{chen201864, title={64-qubit quantum circuit simulation}, author={Chen, Zhao-Yun and Zhou, Qi and Xue, Cheng and Yang, Xia and Guo, Guang-Can and Guo, Guo-Ping}, journal={Science Bulletin}, volume={63}, number={15}, pages={964—971}, year={2018}, publisher={Elsevier}} @article{guo2019general, title={General-purpose quantum circuit simulator with projected entangled-pair states and the quantum supremacy frontier}, author={Guo, Chu and Liu, Yong and Xiong, Min and Xue, Shichuan and Fu, Xiang and Huang, Anqi and Qiang, Xiaogang and Xu, Ping and Liu, Junhua and Zheng, Shenggen and others}, journal={Physical review letters}, volume={123}, number={19}, pages={190501}, year={2019}, publisher={APS}} @book{viamontes2009quantum, title={Quantum circuit simulation}, author={Viamontes, George F and Markov, Igor L and Hayes, John P}, year={2009}, publisher={Springer Science \\&amp; Business Media}} @inproceedings{hiraishi2014bdd, title={BDD operations for quantum graph states}, author={Hiraishi, Hidefumi and Imai, Hiroshi}, booktitle={International Conference on Reversible Computation}, pages={216—229}, year={2014}, organization={Springer}} @inproceedings{samoladas2008improved, title={Improved bdd algorithms for the simulation of quantum circuits}, author={Samoladas, Vasilis}, booktitle={European Symposium on Algorithms}, pages={720—731}, year={2008}, organization={Springer}} @article{zulehner2018advanced, title={Advanced simulation of quantum computations}, author={Zulehner, Alwin and Wille, Robert}, journal={IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, volume={38}, number={5}, pages={848—859}, year={2018}, publisher={IEEE}} @article{niemann2015qmdds, title={QMDDs: Efficient quantum function representation and manipulation}, author={Niemann, Philipp and Wille, Robert and Miller, David Michael and Thornton, Mitchell A and Drechsler, Rolf}, journal={IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, volume={35}, number={1}, pages={86—99}, year={2015}, publisher={IEEE}} @article{mccaskey2018validating, title={Validating quantum-classical programming models with tensor network simulations}, author={McCaskey, Alexander and Dumitrescu, Eugene and Chen, Mengsu and Lyakh, Dmitry and Humble, Travis}, journal={PloS one}, volume={13}, number={12}, year={2018}, publisher={Public Library of Science}} @misc{computing2019pyquil, title={pyQuil Documentation Release 2.4. 0}, author={Computing, Rigetti}, year={2019}} @article{aleksandrowicz2019qiskit, title={Qiskit: An open-source framework for quantum computing}, author={Aleksandrowicz, Gadi and Alexander, Thomas and Barkoutsos, Panagiotis and Bello, Luciano and Ben-Haim, Yael and Bucher, D and Cabrera-Hern{\\’a}ndez, FJ and Carballo-Franquis, J and Chen, A and Chen, CF and others}, journal={Accessed on: Mar}, volume={16}, year={2019}}","link":"/2020/04/12/%E6%A8%A1%E6%8B%9F%E5%99%A8/"},{"title":"纠错理论","text":"量子纠错初步困难 不可克隆 差错连续 测量会破坏量子态 差错分析差错对于量子力学中的状态影响不同，量子状态处于连续空间中，有的差错只会使状态造成轻微破坏，而有的差错会使状态完全混乱。 例如，$X$对于状态$(|0 \\rangle+|1 \\rangle)/ \\sqrt{2}$没有影响，但是会使$|0 \\rangle$翻转变为$|1 \\rangle$。 考虑保真度 F(|\\psi\\rangle, \\rho)=\\sqrt{\\langle\\psi|\\rho| \\phi\\rangle}量子纠错的目标就是提高保真度，以接近最大保真度的状态来存储（或传送）量子信息。 考虑一个例子，比较三量子比特反转码能达到的最小保真度和当不执行纠错时的保真度来作比较。设所感兴趣的量子状态为$| \\psi \\rangle$，经过信道之后，变为 \\rho=(1-p)|\\psi\\rangle\\langle\\psi|+p X| \\psi\\rangle\\langle\\psi| X保真度为 F=\\sqrt{\\langle\\psi|\\rho| \\psi\\rangle}=\\sqrt{(1-p)+p\\langle\\psi|X| \\psi\\rangle\\langle\\psi|X| \\psi\\rangle}可以看到，第二项非负，所以最小保真度为$F= \\sqrt{(1-p)}$。 设使用三量子比特纠错码来编码状态$|\\psi\\rangle=a\\left|0_{L}\\right\\rangle+b\\left|1_{L}\\right\\rangle$。噪声和纠错两者作用之后的量子状态为 \\rho=\\left[(1-p)^{3}+3 p(1-p)^{2}\\right]|\\psi\\rangle\\langle\\psi|+\\cdots系数$(1-p)^{3}+3 p(1-p)^{2}$表示不出现翻转或只出现一次翻转时，可纠错。省略项都是半正定算子。 所以有 F=\\sqrt{\\langle\\psi|\\rho| \\psi\\rangle} \\geq \\sqrt{(1-p)^{3}+3 p(1-p)^{2}}所以量子状态的保真度会在$p &lt; 1/2$下被改善。 Shor码 \\begin{aligned}&|0\\rangle \\rightarrow\\left|0_{L}\\right\\rangle \\equiv \\frac{(|000\\rangle+|111\\rangle)(|000\\rangle+|111\\rangle)(|000\\rangle+|111\\rangle)}{2 \\sqrt{2}}\\\\&|1\\rangle \\rightarrow\\left|1_{L}\\right\\rangle \\equiv \\frac{(|000\\rangle-|111\\rangle)(|000\\rangle-|111\\rangle)(|000\\rangle-|111\\rangle)}{2 \\sqrt{2}}\\end{aligned} 可以保护比特翻转或者相位翻转，甚至更多*。 纠错理论 噪声描述为量子运算$\\mathcal{E}$，纠错运算表示为一个保迹量子运算$\\mathcal{R}$，为确保纠错是成功的，状态$\\rho$需要位于码空间$C$中 (\\mathcal{R} \\circ \\mathcal{E})(\\rho) \\propto \\rho量子纠错条件 令$C$为一个量子码，令$P$为到$C$的投影算子。设$\\mathcal{E}$为具有运算元${E_i}$的量子运算。则纠正$C$上$\\mathcal{E}$的纠错运算$\\mathcal{R}$存在的充分必要条件为，对某个复数Hermite矩阵$\\alpha$成立 P E_{i}^{\\dagger} E_{j} P=\\alpha_{i j} P称运算元${E_i}$为噪声$\\mathcal{E}$的差错，如果$\\mathcal{R}$存在，则${E_i}$构成一个可纠错的差错集合。 差错离散化定理，差错的线性组合也可纠正 设$C$为量子码，$\\mathcal{R}$为构造的纠错运算，用以从具有算子元${E_i}$的噪声过程中恢复。设$\\mathcal{F}$为具有运算元${F_i}$的量子运算，运算元${F_i}$为$E_i$的线性组合，$F_i = \\sum_i m_{ji} E_i$，$m_{ji}$为复数矩阵。那么纠错运算$\\mathcal{R}$也可以纠正量子码$C$上的量子运算$\\mathcal{F}$。 差错离散化的例子 设$\\mathcal{E}$为作用于单量子比特上的量子运算。那么，其每个运算元${E_i}$都可以写成Pauli矩阵$\\sigma_{0}, \\sigma_{1}, \\sigma_{2}, \\sigma_{3}$的线性组合。那么检验Shor码能对第一量子比特上的单量子比特差错进行纠错，只需要验证满足方程 P \\sigma_{i}^{1} \\sigma_{j}^{1} P=\\alpha_{i j} P就可以了，其中$\\sigma_{i}^{1}$为作用于第一量子比特上的Pauli矩阵$(I,X,Y,Z)$。 所以对退极化信道 \\mathcal{E}(\\rho) = (1-p) \\rho+\\frac{p}{3}(X \\rho X+Y \\rho Y+Z \\rho Z)纠错的能力自动地暗含了对任意单量子比特地量子运算地纠错能力。 独立差错模型假设噪声独立的作用于码中的不同量子比特上。 还是考虑退极化噪声 \\mathcal{E}(\\rho) = (1-p) \\rho+\\frac{p}{3}(X \\rho X+Y \\rho Y+Z \\rho Z)其最小保真度为 F=\\sqrt{1-2 p / 3}=1-p / 3+O\\left(p^{2}\\right)假设用能纠正任何单量子比特上差错的一个$n$量子比特码来对单比特进行编码。设具有参数$p$的退极化噪声独立地作用于这个量子比特地每一个，则在所有$n$个量子比特上的联合作用为 \\mathcal{E}^{\\otimes n}(\\rho)=(1-p)^{n} \\rho+\\sum_{j=1}^{n} \\sum_{k=1}^{3}(1-p)^{n-1} \\frac{p}{3} \\sigma_{k}^{j} \\rho \\sigma_{k}^{j}+\\cdots那么执行纠错后 \\left(\\mathcal{R} \\otimes \\mathcal{E}^{\\otimes n}\\right)(\\rho)=\\left[(1-p)^{n}+n(1-p)^{n-1} p\\right] \\rho+\\cdots保真度满足 F \\geq \\sqrt{(1-p)^{n-1}(1-p+n p)}=1-\\frac{\\left(\\begin{array}{l}n \\\\2\\end{array}\\right)}{2} p^{2}+O\\left(p^{3}\\right)振幅阻尼并非所有噪声污染的信道都可以解释为由无差错、比特翻转、相位翻转及两两组合的随机组合。许多自然出现的量子信道都不具备这样的解释。 考虑振幅阻尼的例子，其具有运算元$E_0$和$E_1$ E_{0}=\\left[\\begin{array}{cc}1 & 0 \\\\0 & \\sqrt{1-\\gamma}\\end{array}\\right] ; \\quad E_{1}=\\left[\\begin{array}{cc}0 & \\sqrt{\\gamma} \\\\0 & 0\\end{array}\\right]${\\gamma}$为表征振幅阻尼过程强度的一个小正参数，${\\gamma}$越大，噪声强度越大。 因为对于$\\gamma&gt;0$，没有一个$E_0$和$E_1$的线性组合可以在任何时候都正比于单位阵，所有对幅值阻尼信道没有一组运算元可以在任何时候都包含正比于单位阵的项。 用$E_{j,k}$表示$E_j$在第$j$个量子比特上的作用，则噪声在编码后量子比特上的影响可写为 \\begin{aligned}\\mathcal{E}^{\\otimes n}(\\rho)=\\left(E_{0,1} \\otimes E_{0,2} \\otimes \\cdots \\otimes E_{0, n}\\right) \\rho\\left(E_{0,1}^{\\dagger} \\otimes E_{0,2}^{\\dagger} \\otimes \\cdots \\otimes E_{0, n}^{\\dagger}\\right) \\\\+\\sum_{j=1}^{n}\\left[E_{1, j} \\otimes\\left(\\bigotimes_{k \\neq j} E_{0, k}\\right)\\right] \\rho\\left[E_{1, j}^{\\dagger} \\otimes\\left(\\bigotimes_{k \\neq j} E_{0, k}^{\\dagger}\\right)\\right] \\\\+O\\left(\\gamma^{2}\\right)\\end{aligned}设$E_{0}=(1-\\gamma / 4) I+\\gamma Z / 4+O\\left(\\gamma^{2}\\right)$，$E_{1}=\\sqrt{\\gamma}(X+i Y) / 2$ 有 \\begin{aligned}\\mathcal{E}^{\\otimes n}(\\rho)=(1-&\\left.\\frac{\\gamma}{4}\\right)^{2 n} \\rho+\\frac{\\gamma}{4}\\left(1-\\frac{\\gamma}{4}\\right)^{2 n-1} \\sum_{j=1}^{n}\\left(Z_{j} \\rho+\\rho Z_{j}\\right) \\\\&+\\frac{\\gamma}{4}\\left(1-\\frac{\\gamma}{4}\\right)^{2 n-2} \\sum_{j=1}^{n}\\left(X_{j}+i Y_{j}\\right) \\rho\\left(X_{j}-i Y_{j}\\right)+O\\left(\\gamma^{2}\\right)\\end{aligned}考虑同上面相似的纠错过程，$Z_j \\rho$，$X_j \\rho Y_j$和$Y_j \\rho X_j$这样的项会消失。$X_j \\rho X_j$和$Y_j \\rho Y_j$会会到$\\rho$，所有纠错后系统的状态为 \\left(1-\\frac{\\gamma}{4}\\right)^{2 n} \\rho+2 n \\frac{\\gamma}{4}\\left(1-\\frac{\\gamma}{4}\\right)^{2 n-2} \\rho+O\\left(\\gamma^{2}\\right)=\\rho+O\\left(\\gamma^{2}\\right)因此，准确到阶$\\gamma^2$，纠错会使量子系统返回到它原始的状态$\\rho$，而对弱噪声(小$\\gamma$)，如同退极化信道一样，纠错会对差错产生净抑制。 量子Hamming界设想，以能纠正$t$或更少数目的量子比特上差错的方式，一个非简并编码将$k$量子比特编码为$n$量子比特。设出现$j$个差错，其中$j \\leq t$。总共有$\\left(\\begin{array}{l}n \\j\\end{array}\\right)$组差错的可能出现位置。对应每组这样的位置，会有三个可能的差错$(X,Y,Z)$，总共有$3^j$个可能的差错。 在$t$或更少比特上出现差错的总个数为 \\sum_{j=0}^{t}\\left(\\begin{array}{c}n \\\\j\\end{array}\\right) 3^{j}为了以非简并编码方式来编码$k$个量子比特，这些差错的每一个都必须对应于一个正交空间$2^k$维子空间。所有这些子空间必须置于对$n$个量子比特可利用的整个$2^n$维空间中，从而有不等式 \\sum_{j=0}^{t}\\left(\\begin{array}{c}n \\\\j\\end{array}\\right) 3^{j} 2^{k} \\leq 2^{n}这就是量子Hamming界。 考虑用$n$个量子比特来编码一个量子比特，在这种情况下，量子Hamming界为 2(1+3 n) \\leq 2^{n}可以看到$n \\geq 5$才能满足，因此不存在用少于$5$个量子比特对一个量子比特编码的非简并编码。其实对于任意量子码都要符合这个规定*。","link":"/2020/04/12/%E7%BA%A0%E9%94%99%E7%90%86%E8%AE%BA/"},{"title":"量子码的构造","text":"量子码的构造经典线性码编码$k$个量子比特信息到$n$个比特码空间的一个线性码$C$，可由一个$n \\times k$生成矩阵$G$来指定，$G$的所有元属于$\\mathbf{Z}_2$，即0和1。$k$个比特消息$x$被编码为$Gx$，其中消息$x$被显式地写为一个列向量。 例如，将单比特映射到三个重复比特地重复码可由如下生成矩阵来给定 G=\\left[\\begin{array}{l} 1 \\\\ 1 \\\\ 1 \\end{array}\\right]有$G[0]=(0,0,0)$和$G[1]=(1,1,1)$。 用$n$个比特编码$k$个比特信息地码为$[n,k]$码。 一个$[6,2]$码可以表示为 G=\\left[\\begin{array}{ll} 1 & 0 \\\\ 1 & 0 \\\\ 1 & 0 \\\\ 0 & 1 \\\\ 0 & 1 \\\\ 0 & 1 \\end{array}\\right]有 \\begin{aligned} &G(0,0)=(0,0,0,0,0,0) ; \\quad G(0,1)=(0,0,0,1,1,1)\\\\ &G(1,0)=(1,1,1,0,0,0) ; \\quad G(1,1)=(1,1,1,1,1,1) \\end{aligned}线性码相比于一般纠错码的一大优点是它们的紧凑表示。 按线性码的另一种替代的奇偶校验矩阵形式，可以容易的理解线性码。在这个定义中，一个$[n,k]$码定义为由$\\mathbf{Z}_2$上使 Hx=0成立的所有$n$元向量$x$来组成。其中$H$称为奇偶校验矩阵，为一个$(n-k) \\times n$矩阵，其元均为0和1。一个编码$k$比特的码具有$2^k$个可能的码字。所有$H$的核必须是$k$维的，因此要求$H$为行线性无关。 奇偶校验矩阵具有标准形$[A|I_{n-k}]$，其中$A$为$(n-k) \\times k$矩阵。 从奇偶校验矩阵$H$到生成矩阵$G$，挑选$k$个线性无关的向量$y_1,\\cdots,y_k$来张成$H$的核，并使$G$具有列$y_1$直到$y_k$。 从生成矩阵$G$到奇偶校验矩阵$H$，挑选$n-k$个正交于$G$各列的线性无关的向量$y_1,\\cdots,y_{n-k}$，并使$H$的行为$y_{1}^{T}, \\ldots, y_{n-k}^{T}$。（这里正交指模2内积必须为0） 例子，考虑$[3,1]$重复码，为构造$H$，挑选$3-1=2$个正交于$G$各列的线性无关向量，例如$(1,1,0)$和$(0,1,1)$，则奇偶校验矩阵为 H \\equiv\\left[\\begin{array}{lll} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\end{array}\\right]容易检验，$Hx=0$仅对码字$x=(0,0,0)$和$x=(1,1,1)$成立。 奇偶校验矩阵使得差错检测和恢复变得十分明显。设编码消息$x$为$y=Gx$，但由噪声引起的一个差错$e$使$y$受到污染，并给出污染后的码字为$y’=y+e$。因为对所有码字$Hy=0$，有$Hy’=He$，为差错症状，将$Hy’$与不同的$He_j$值进行比较，便可以确定哪个比特需要被纠正。 为了更深入了解线性码如何被执行，引入距离的概念。设$x$和$y$各为$n$比特的字，$x$和$y$之间的Hamming距离$d(x,y)$定义为$x$和$y$有差异的位置数目。例如，$d((1,1,0,0),(0,1,0,1))=2$。字$x$的Hamming权重定义为全零字串到其的距离$\\operatorname{wt}(x) \\equiv d(x, 0)$。注意$d(x,y)=\\operatorname{wt}(x+y)$。 一个码的全局性质可以用Hamming距离来理解。定义一个码的距离为其任意两个码字之间的最小距离： d(C) \\equiv \\min _{x, y \\in C, x \\neq y} d(x, y)但是$d(x,y)=\\operatorname{wt}(x+y)$。由于码是线性的，若$x$和$y$为码字，则$x+y$也是码字，所以可以看到 d(C) \\equiv \\min _{x \\in C, x \\neq 0} \\operatorname{wt}(x)令$d \\equiv d(C)$，则$C$为一个$[n,k,d]$码。距离的重要性在于，对某个整数$t$，简单地通过解码受污染地编码消息$y’$为满足$d(y,y’) \\leq t$的唯一码字$y$，具有距离至少为$2t+1$的一个码就可以纠正最多$t$个比特上的差错。 对偶构造。设$C$为一个$[n,k]$码，其具有生成矩阵$G$和奇偶校验矩阵$H$，那么，可定义另一个码，$C$的对偶码并记为$C^{\\perp}$，其具有生成矩阵$G^{T}$和奇偶校验矩阵$H^{T}$。等价的，$C$的对偶码由正交于$C$中所有码字的全部码字$y$组成。如果$C \\subseteq C^{\\perp}$，称一个码为弱自对偶；如果$C=C^{\\perp}$，称为严格自对偶。 CSS码设$C_1$和$C_2$为$[n,k_1]$和$[n,k_2]$经典线性码，使$C \\subset C_1$，且$C_1$和$C_2^{\\perp}$，两者可纠正$t$个差错。通过下面的构造，将要定义能纠正$t$个量子比特上差错的一个$[n,k_1-k_2]$量子码$CSS(C_1,C_2)$，即$C_2$上$C_1$的CSS码。设$x \\in C_1$为$C_1$中的任一量子码，那么，定义量子状态$|x+C_2 \\rangle$为 \\left|x+C_{2}\\right\\rangle \\equiv \\frac{1}{\\sqrt{\\left|C_{2}\\right|}} \\sum_{y \\in C_{2}}|x+y\\rangle其中，$+$为按比特的模2加。设$x’$为$C_1$的一个元，使得$x-x’ \\in C_2$。那么，容易看到$|x+C_2 \\rangle = |x’=C_2 \\rangle$，因此状态$|x+C_2 \\rangle $只依赖于$x$所在的陪集$C_1 / C_2$。如果$x$和$x’$属于$C_2$的不同陪集，那么不存在$y,y’ \\in C_2$，使得$x+y=x’+y’$，因而$|x+C_2 \\rangle$和$| x’ +C_2 \\rangle$为正交状态。量子码$CSS(C_1,C_2)$定义为所有$x \\in C_1$的状态$| x+C_2 \\rangle$所张成的向量空间，维数为$|C_1|/|C_2|=2^{k_1-k_2}$，因此其为一个$[n,k_1-k_2]$量子码。 纠错过程 设比特翻转差错由$n$比特向量$e_1$来描述，且在比特翻转出现的比特上为1，在其它比特上为0。相位翻转差错由$n$比特向量$e_2$来描述，且在相位翻转出现的比特上为1，在其它比特上为0。那么受到污染的状态为 \\frac{1}{\\sqrt{\\left|C_{2}\\right|}} \\sum_{y \\in C_{2}}(-1)^{(x+y) \\cdot e_{2}}\\left|x+y+e_{1}\\right\\rangle为检测比特翻转出现在什么地方，方便的做法是引入一个辅助码，包含足够多的量子比特来存储码$C_1$的差错症状，且初始处于全0状态$|0 \\rangle$。采用可逆计算，即对码$C_1$应用奇偶矩阵$H_1$，把$|x+y+e_1 \\rangle$变为$\\left|x+y+e_{1}\\right\\rangle\\left|H_{1}\\left(x+y+e_{1}\\right)\\right\\rangle=|x+y+e\\rangle\\left|H_{1} e_{1}\\right\\rangle$，产生状态 \\frac{1}{\\sqrt{\\left|C_{2}\\right|}} \\sum_{y \\in C_{2}}(-1)^{(x+y) e_{2}}\\left|x+y+e_{1}\\right\\rangle\\left|H_{1} e_{1}\\right\\rangle对比特翻转差错的差错检测时通过测量辅助码得到结果$H_1 e_1$，并消去辅助码而完成，并给出状态为 \\frac{1}{\\sqrt{\\left|C_{2}\\right|}} \\sum_{y \\in C_{2}}(-1)^{(x+y) e_{2}}\\left|x+y+e_{1}\\right\\rangle得到差错症状$H_1 e_1$后，就可以推断差错$e_1$。恢复可简单地通过对差错$e_1$中出现比特翻转地位置上应用非门而执行，消去所有比特翻转差错后给出状态 \\frac{1}{\\sqrt{\\left|C_{2}\\right|}} \\sum_{y \\in C_{2}}(-1)^{(x+y) e_{2}}\\left|x+y\\right\\rangle为检测相位翻转差错，对每个量子比特应用Hadamard门，把状态变为 \\frac{1}{\\sqrt{\\left|C_{2}\\right| 2^{n}}} \\sum_{z} \\sum_{y \\in C_{2}}(-1)^{(x+y) \\cdot\\left(e_{2}+z\\right)}|z\\rangle令$z’ \\equiv z+e_2$，这个状态可重写为 \\frac{1}{\\sqrt{\\left|C_{2}\\right| 2^{n}}} \\sum_{z^{\\prime}} \\sum_{y \\in C_{2}}(-1)^{(x+y) \\cdot z^{\\prime}}\\left|z^{\\prime}+e_{2}\\right\\rangle如$z’ \\in C_2^{\\perp}$，有$\\sum_{y \\in C_2} (-1)^{y \\cdot z’}=|C_2|$；如$z’ \\notin C_2^{\\perp}$，有$\\sum_{y \\in C_2} (-1)^{y \\cdot z’}=0$，所有状态重写为 \\frac{1}{\\sqrt{2^{n} /\\left|C_{2}\\right|}} \\sum_{z^{\\prime} \\in C_{2}^{\\perp}}(-1)^{x \\cdot z^{\\prime}}\\left|z^{\\prime}+e_{2}\\right\\rangle这与比特翻转差错类似，引入辅助码并对$C_2^{\\perp}$逆向地应用奇偶校验矩阵$H_2$以得到$H_2 e_2$，并纠正比特翻转差错$e_2$，得到状态为 \\frac{1}{\\sqrt{2^{n} /\\left|C_{2}\\right|}} \\sum_{z^{\\prime} \\in C_{2}^{\\perp}}(-1)^{x \\cdot z^{\\prime}}\\left|z^{\\prime}\\right\\rangle纠错可通过再次对每个量子比特应用Hadamard门来完成。最后得到初始的编码状态。 \\frac{1}{\\sqrt{\\left|C_{2}\\right|}} \\sum_{y \\in C_{2}}|x+y\\rangleSteane码一个$[7,4,3]$的Hamming码，其奇偶校验矩阵为 H=\\left[\\begin{array}{lllllll} 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\ 1 & 0 & 1 & 0 & 1 & 0 & 1 \\end{array}\\right]标记这个码为$C$，定义$C_1 \\equiv C$和$C_2 \\equiv C^{\\perp}$。为了使用这些码来定义一个CSS码，需要检查$C_2 \\subset C_1$。根据定义，$C_2 = C^{\\perp}$的奇偶效验矩阵等于$C_1 = C$的生成矩阵的转置 H\\left[C_{2}\\right]=G\\left[C_{1}\\right]^{T}=\\left[\\begin{array}{lllllll} 1 & 0 & 0 & 0 & 0 & 1 & 1 \\\\ 0 & 1 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 0 & 1 & 0 & 1 & 1 & 0 \\\\ 0 & 0 & 0 & 1 & 1 & 1 & 1 \\end{array}\\right]可以看到$H[C_2]$的行张成的空间严格包含$H[C_1]$的行张成的空间，且由于相应的码是$H[C_2]$和$H[C_1]$的核，因此可以得出结论$C_2 \\subset C_1$。进而$C_2^{\\perp}=(C^{\\perp})^{\\perp}=C$，所以$C_1$和$C_2$两均为距离为3的码，可以用来纠正1比特上的差错。因为$C_1$是$[7,4]$码，$C_2$是$[7,3]$码，所以$CSS(C_1,C_2)$是能纠正单比特上差错的一个$[7,1]$量子码。 这个码就是Steane码，现在非显式地写出，如对其逻辑单元$|0_L \\rangle$元$| 0 + C_2 \\rangle$有 \\begin{aligned} \\left|0_{L}\\right\\rangle=\\frac{1}{\\sqrt{8}}[|0000000\\rangle+|1010101\\rangle+|0110011\\rangle+|1100110\\rangle& \\\\ +|0001111\\rangle+|1011010\\rangle+|0111100\\rangle+|1101001\\rangle] \\end{aligned}为确定其他逻辑码字，需要找出$C_1$的一个不在$C_2$中的一个元，这样元的一个例子为$(1,1,1,1,1,1,1)$，给出 \\begin{aligned} \\left|1_{L}\\right\\rangle=\\frac{1}{\\sqrt{8}}[|1111111\\rangle+|0101010\\rangle+|1001100\\rangle+|0011001\\rangle& \\\\ +|1110000\\rangle+|0100101\\rangle+|1000011\\rangle+|0010110\\rangle] \\end{aligned}稳定子码稳定子体系酉门和稳定子体系稳定子体系中的测量Gottesman-Knill定理稳定子码构造例子稳定子码的标准形纠错线路容错量子计算","link":"/2020/04/12/%E9%87%8F%E5%AD%90%E7%A0%81%E7%9A%84%E6%9E%84%E9%80%A0/"}],"tags":[{"name":"计算物理","slug":"计算物理","link":"/tags/%E8%AE%A1%E7%AE%97%E7%89%A9%E7%90%86/"},{"name":"Tensor Netwowrk","slug":"Tensor-Netwowrk","link":"/tags/Tensor-Netwowrk/"},{"name":"Quantum Volume","slug":"Quantum-Volume","link":"/tags/Quantum-Volume/"},{"name":"TFQ","slug":"TFQ","link":"/tags/TFQ/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"量子线路","slug":"量子线路","link":"/tags/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF/"},{"name":"链接","slug":"链接","link":"/tags/%E9%93%BE%E6%8E%A5/"}],"categories":[{"name":"计算物理","slug":"计算物理","link":"/categories/%E8%AE%A1%E7%AE%97%E7%89%A9%E7%90%86/"},{"name":"Tensor Netwowrk","slug":"Tensor-Netwowrk","link":"/categories/Tensor-Netwowrk/"}]}